
[
  
  
  {
    "objectID": "1740348600",
    "permalink": "/post/%E8%AE%A4%E7%9F%A5%E5%BF%83%E7%90%86%E5%AD%A6/",
    "title": "认知心理学复习纲要",
    
    "content": " “出题极其阴险。”\n题型有 名词解释、成对概念分析、填空、判断对错、匹配连线、填图、实验分析、psychopy。\n认知心理学以研究黑箱方法为主，神经生物学以白箱研究为主，二者均启发计算神经工程。神经生物学为认知心理学提供了机理与证据。\nMental progress: Private psychological activities that include thinking, perceiving, and feeling.\n认知心理学研究的基本问题： 心理表征问题——心理表征的形成与对心理表征的加工。表征是指信息或知识在心理活动中的表现和记载的方式，是外部事物在心理活动中的内部表现。\n认知活动（心理表征及其加工）的意识水平：意识和无意识\n身心关系问题\n认知心理学的研究范式 信息加工范式 研究目的是确定认知操作的过程和结构，将外部信息转换为可操作的离散符号——心理表征 对信息的加工范式是序列(sequential)进行的 该模式可以回答自下而上的加工过程，却忽视了自上而下的加工过程。\n[信息加工的一般原理图] 感受器、效应器、信息加工系统 [对信息加工观点的批评图] 认知系统、调节系统、情绪系统、物理信号、运动和声音 联结主义范式 模拟神经网络的集成平行加工方式。\n信息表征是以神经网络的激活模式实现的，不同的激活模式表征不同信息，一个网络当中可以存储和表征不同的信息（一个网络有不同的激活模式）。信息是以非符号的分布式存储于神经网络中，存储具有非局部性；信息加工就是以一定模式在网络当中激活扩散，在空间上是平行分布式加工。 这种网络具有学习能力。 联结主义范式图他敢考？\n此外，认知心理学研究的生态学取向也日趋明显，强调人与环境的动态交互过程，从更为整体的观点认识人的认知过程。\n认知心理学的产生基础 哲学：\n柏拉图的理性主义（知识的基础是大脑的先天特征） VS 亚里士多德的经验主义（一切皆学习所得）\n认知心理学既依赖于理性主义研究，也依赖于经验主义研究。\n心理学：\n实验内省法：冯特主张以意识作为研究对象。\n行为主义：华生主张用纯粹客观的自然科学方法来研究，认为心理学应该研究similate-react。\n早期注重于研究行为主义，而托尔曼、班杜拉等行为主义者已开始注意行为的认知过程。\n格式塔学派也反对冯特的观点，但强调心理活动的整体性。“整体大于部分之和。”\n控制论 冯诺依曼提出自复制自动机理论，构造出了一种基于29状态的二维元胞自动机模型的自复制自动机的理论原型\n1948年，维纳发表的控制论《控制论——关于在动物和机器中控制和通讯的科学》提出核心思想——控制、反馈和人机交互。\n1956年，认知心理学正式诞生，1967年出版史上第一部《认知心理学》专著。\n感觉 什么是absolute threshold？ 能够被感知到的最小强度的刺激。在50%的时间里可以检测到的最小能量。 sensory adaptation？\n[感觉适应图]\n长时间暴露于不变的刺激下感觉能力的调整。 在大多数情况下，我们的感官会适应他们所经历的刺激水平。 敏感性的明显下降是由于感觉神经受体无法无限期地向大脑发送信息。 双目立体视觉的深度计算 $d$是两眼之间的距离。${x_{right}}$ ${x_{left}}$是眼中成像与视网中心点之间的距离。 $$Z = \\frac{{f \\times d}}{{{x_{right}} - {x_{left}}}}$$\n对立过程理论 三套颜色感受器：黄Y-蓝B 红R-绿G 黑B-白W ，非此即彼。 虽然视网膜中有三种颜色受体，但他们传递的信息被视觉系统中的其他神经元编码为对手过程形式。\n视觉系统中的神经元对这些颜色对进行编码，并通过“对立”的方式进行信号传递。例如： 如果红色感受器被激活，则绿色感受器被抑制（或反之），这种对立关系帮助我们感知颜色的不同。 类似地，明亮与黑暗的对立（黑-白）也是通过神经元的对立过程来进行编码的。 这意味着在视觉神经传导过程中，同一颜色感受器的刺激不能同时表现出两个相对的颜色（比如红与绿）。当一个颜色对的一个元素被激活时，另一个颜色就会被抑制，这种机制帮助视觉系统识别和分辨颜色。 听觉位置理论: 人耳的听觉范围16~200Hz。基底膜的不同区域对不同的频率有分离的反应，大致可以分为三个区域。\n傅里叶级数 复指数信号 连续时间信号的傅里叶级数 嗅觉：设计用来模拟生物嗅觉的神经算法……成果有助于未来在未知背景气味的情境下识别特定气味。利用甲苯、氨、丙酮、一氧化碳和甲烷等对其进行气味训练。\n触觉：senses of touch,pressure,temperature and pain. skin senses play critial role in survival,making us aware of danger.\n知觉 概念 神经系统只会关注可能对决策产生影响的主要物体（知觉物体）。\n什么是刺激？ 产生感觉器官反应的能量。\n什么是感觉？感官刺激的体验。 感觉器官被物理能量源激活。\n知觉 (Perception) ： 从原始感觉信息中创建有意义模式的过程。 感觉信息在感觉器官和大脑之间进行分类、解释、分析和整合的过程。\n错觉 （important） 知觉错觉 知觉的欺骗。 知觉错觉主要依赖于我们自身的知觉过程，并且由于刺激包含误导性线索而发生。\n视觉错觉 当我们使用各种感觉线索来创造实际上并不存在的知觉体验时，就会发生视觉错觉。\n感觉≠知觉 错觉并非指出了我们知觉能力的缺陷，而是为我们提供了“知觉系统如何工作”更富洞察的启发。\n格式塔心理学 描述我们如何将零碎的信息组织成有意义的整体的一系列原则。\n邻近律 指邻近的元素更倾向于被分为一组。 相似律 指（形状、颜色、亮度等）相似的元素更倾向于被分为一组。 连续律 组合起来构成直线、平滑曲线、光滑表面的元素，往往被视为属于一组。 封闭律 组合成封闭图案的一组元素往往被认为成一组。 方向对知觉的影响 模式的自发组织是刺激本身的自然作用，与该物体过去的经验几乎没有关系（知觉的直接属性）\n典型视角 典型视角是格式塔心理学观点的拓展，指能对物体做出最佳表征的形象 对典型视角的一种理论解释是，我们对物体的日常经验可以发展出对该物体最具代表性形象的永久记忆。\n胶囊网络 胶囊网络(Capsule Networks)是深度学习三巨头之一的Geofrey Hinton 提出的一种全新的神经网络结构。\n胶囊就是将原有CNN神经网络中的个体神经元替换成了一组神经元组成的向量，这些神经元被包裹在一起，组成了一个胶囊。\n胶囊网络中的每层神经网络都包含了多个胶囊基本单元，这些胶囊与上层网络中的胶囊进行信息交互传递。\n两种对立的知觉理论 核心争议在于知觉是否需要知觉者已有内部心理表征的参与调节。内部表征是指知觉者已有的与知觉对象相关的知识经验、期望、动机和情绪等内部因素。\n知觉的假设考验说：建构主义的间接知觉理论  知觉需要已有内部表征的中介调节 认为感觉信息对知觉是不充分的强调自上而下概念驱动的加工，也包括强调自下而上数据驱动的加工 知觉的刺激物说：Gibson的直接知觉理论 知觉不需要内部表征的中介调节 强调自下而上数据驱动的加工能从环境中获得充分的感觉信息来完成知觉任务，形成直接知觉 强调生态学方法，知觉、行动和环境三者互动的动态知觉 Top-down \u0026amp; Bottom up Top-down processing（自上而下加工）：以更高层次的知识、经验、期望和动机为指导的感知 Bottom-up processing（自下而上加工）：感知，包括识别和处理有关刺激各个组成部分的信息 自下而上和自上而下加工的结合 知觉是自下而上的数据驱动加工与自上而下概念驱动加工两种成分综合的结果，两种成分相对比例的多少取决于知觉任务中的具体因素，随知觉任务的不同而不同 。\n单纯地依赖自下而上的数据驱动加工的知觉任务相对很少，大部分知觉任务是两种加工成分的综合，即知觉是现实刺激和已贮存知识经验相互作用的结果。0\n建构主义的听知觉实验 实验范式解析：\n句子的正确知觉率是音噪比的函数 ——验证了知觉的直接性质\n相同音噪比下： 正常句 \u0026gt; 异常句 \u0026gt; 非语法句 ——验证了知觉的间接性质 结论：\n人的已有语言知识对知觉具有作用 知觉既具有直接性质，也具有间接性质 整体加工与局部加工的争论 （很有可能出现） 对于一个客体（object），是先知觉其各部分，进而再知觉整体？还是先知觉整体，再由此知觉其各部分？\n格式塔心理学认为，整体是在其部分之前被知觉的。\nNavon（1977）的著名视听知觉实验研究证实了上述观点。 平行与序列加工 其他关于知觉的心理表征的争论还包括：平行加工与序列加工。\n模式识别 模式（Pattern） 有若干元素或者成分按照一定关系形成的某种刺激结构，也可以说模式是刺激的组合。 当人能够确认他所知觉的某个模式是什么，并能够将它与其他模式区分开来，这就是模式识别。 模式识别的基本过程 对当前知觉对象特征的知觉表征（特征提取） 记忆中与对象有关的表征在视觉系统中的激活（哈希检索） 当前对象的知觉表征与激活的记忆表征的比较（哈希检索） 决策过程：决定哪个长时记忆中的项目与当前对象有着最佳匹配（距离度量空间）\n模板说 在人的长时记忆中，贮存着许多各式各样的过去在生活中形成的外部模式的袖珍复本，称作模板。\n模板匹配（Template Matching）: 物体识别是基于对物体的知觉输入与记忆中的有关模版进行比较匹配的结果，这种匹配要求两者有最大程度的重叠。\n困难 如果模式在外形、大小、方位等某一方面有所变化，即识别不了。 预处理必不可少 需要在人的记忆中贮存不可计数的模板，增加了记忆负担，且与人的模式识别的高度灵活性不一致。 原型说 原型(prototype)：不是某个特定模式的内部复本，而是一类客体的内部表征，即一个类别或范畴的所有个体概括表征，反映一类客体具有的基本特征。\n原型说的基本观点 在模式识别中，外部刺激只需要与原型进行比较，由于原型是一种概括表征，因此不要求严格匹配，只需近似的匹配即可。当刺激与某一原型有最近似的匹配，即可将该刺激纳入此原型所代表的范畴，从而得到识别。 corr\n视知觉实验(1967) 原型说VS模板匹配说 原型说允许近似匹配，即使某一范畴的个体之间存在外形、大小等方面的差异，所有这些个体都可与原型近似匹配而得到识别； 原型说使人的模式识别更加灵活，更能适应环境，新的不熟悉的模式也可以识别 ；原型说可以大大减轻记忆负担。\n原型形成的两大理论 Centraltendency theory (趋中理论，Posner et al., 1967)：在概念上，原型代表了一组示例的平均值。 Attributefrequency theory (特征-频率理论，Solso and McCarthy, 1981)：原型代表最常见的属性组合模式，与一组模式的 \u0026ldquo;最佳范例 \u0026ldquo;同义。 特征说 特征（feature）：模式是由若干元素或成分按一定关系构成的，这些元素或成分可称为特征。\n外部刺激在人的长时记忆中是由特征符号的集合来表征的 模式识别首先要对刺激的特征进行分析，即抽取刺激的有关特征，然后将这些抽取的特征加以合并，再与长时记忆中的有关特征符号集合进行比较，一旦获得了最佳的匹配，外部刺激就被识别了 与模板匹配模型的关系：特征可以看做是一种局部的部件模板 但特征分析模型较模板匹配模型有如下优点： 更强的适应性，依据刺激的特征和关系进行识别，不管刺激的大小、多少等细节 同样的特征可以出现在不同的模式中，极大地减轻了记忆的负担 【字母搜索实验】验证了特征说，反驳了模板匹配说。\n【静止网像实验】 【幼年猫🐱的视觉皮层实验】 实验发现：某些细胞仅对水平形状有反应，而另一些仅对垂直形状有反应。\n实验结论：因幼年猫缺乏视觉经验，知觉形状的皮层编码是先天的。\n成分说 成分说又称作成分识别理论或几何子理论。\n基于简单三维 \u0026ldquo;几何子 \u0026ldquo;组合检测的感知能力 。\n根据视角不变特性定义的地线：即使从不同角度观察也能保持不变的特性\n几何子（geons）：24 个不同的形式，就像字母表中的字母一样，构成了一种系统类型\n模板说（模板匹配模型）——自下而上模型 原型说（原型匹配模型）——自下而上+自上而下模型 特征说（特征分析模型）——自下而上模型 成分说（几何子理论） ——自下而上+自上而下模型 结构优势效应 上下文效应。指整体的结构在模式识别中所起到的重要作用。\n字词优势效应实验（可能会出现） 句子优势效应 （可能会出现） 客体优势效应实验 解释是：\n存在两种知觉系统：特征系统——自底向上；客体系统——可被结构严谨的整体刺激激活 小结 以整体加工和局部加工为核心的假设，可以为上述各类结构优势效应给出统一的解释  视觉以外的其他感觉通道可能也存在着类似的效应  模式识别任务以外的其他的知觉活动可能也存在着类似的效应 注意 行为主义：否定注意的存在。格式塔心理学：注意完全融化于知觉之中。\n二战期间，工程心理学又开始重视注意的研究。 认知心理学将注意看做信息加工的重要机制。\n注意的定义 注意：是意识接收信息的过程，它是意识从同时呈现的几个对象或思维序列中选择一个对象并给予清晰和生动的关注的过程，意识集中与专注是注意的核心。\n注意的两个实质特征：选择性和改善心理加工的有效性。\n注意的模型 过滤器模型 单通道模型。过滤器至高级水平分析的通道只有一条。 衰减器模型 过滤器并不是按“有或无”的方式来工作的，不是只允许一个通道（追随耳）的信息通过， 而是既允许追随耳信息通过，又允许非追随耳信息通过，只是非追随耳的信号受到衰减，强度减弱了，但一些信息仍然可得到高级加工。\n过滤器VS衰减器模型 共同点\n根本出发点相同：高级分析水平容量有限，需要过滤器调节\n过滤器的位置相同：处于初级分析和高级分析之间\n过滤器的作用相同：选择一部分信息进入高级知觉分析，注意选择都是知觉性质的\n不同点：迟钝的耳朵与失聪的耳朵\n合并称为 Broadbent-Treisman 过滤器衰减器模型——注意的知觉选择模型。\n反应选择模型（新加） 又称为后期选择模型，该模型认为几个输入通道的信息均可以进入高级分析，得到全部知觉加工，注意不在于选择知觉刺激，而在于选择对刺激的反应。\n中枢的分析结构可以识别一切输入，单输出是按照重要性来安排的，对重要的信息作反应，而对不重要的信息不反应，注意是对反应的选择。尽管这是一种“不经济”的工作机制，心理学界仍未在两者间形成定论。 中枢能量理论（新加） 认为人们拥有一个容量有限的非特异的认知资源，这些认知资源可以被灵活的分配给人们面临的各种刺激和任务上。 \n他并没有设想一个瓶颈结构，也没有过滤器，而是将注意看成人能用于执行任务的数量有限的能量或者资源，用这种能量或资源的分配来解释注意。\n解释了常见的双作业操作。\n特征整合理论（新加） 大脑皮层的不同区域的特征地图对客体的不同空间属性进行了编码。\n在特征分析与特征整合两个相继进行的加工过程中，特征分析加工过程快速有效，而特征整合加工过程更慢而且效率不高。\n弹出效应 当奇异元素嵌入彼此相似，但在形状、颜色、大小、运动方向等某一特征截然不同的干扰物区域时，奇异元素很容易被直接识别到。 （奇异元素嵌入干扰物区域）\n计算机视觉显著性的研究方法 多尺度对比特征：在高斯图像金字塔上对比每像素邻域内的相似性，假设显著物体内部通常具有较高的像素相似性，而边缘相似性较低。\n中央-周围直方图特征：假设显著物体与其周围区域往往具有较大的像素差异。\n颜色空间分布特征：图像中所有颜色可以用高斯混合模型（GMM）来表征，据此可以衡量每个像素属于某个高斯元的概率。 这里假设显著物体的颜色一般较为单一。\n控制加工与自动化加工（概念辨析） 认知加工过程按受注意的控制调节程度可分为控制加工和自动加工\n控制加工（controlled process）需要注意力控制，以序列方式进行，相对较慢，但具有弹性 自动化加工（automatic process）很少或几乎不需要注意，以并行加工方式进行，相对较快，但缺少弹性 控制过程是容量有限的，并且在变化情境下可以灵活使用自动化过程没有容量限制，并且一旦掌握就很难改变。 shiffrin \u0026amp; schneider 视觉搜索实验 呈现识记项目，再现识记项目，被试判定是否见过。 stroop实验范式 实验结果：颜色的命名受到词汇语义的干扰，语义的自动识别很难抑制。\n意识 意识：大脑创建内外经验模型的过程\nNonconscious processes（无意识加工）：任何不涉及意识加工的大脑过程\nPreconscious memories（前意识）：目前不在意识中，但可以被唤起\nUnconscious（潜意识）：经典的弗洛伊德理论\n两方面：一是对环境的觉察，二是一个人对心里事件的认知——由记忆和自己的内在意识和自我意识产生的想法。\n潜意识 在弗洛伊德的经典理论中，这是心灵的一部分，它容纳了记忆、欲望和感受，如果这些记忆、欲望和感受被带入意识中，就会造成威胁。\n许多现代认知心理学家认为，无意识并不那么险恶，它只是在意识（知觉）之外运作的心理过程的集合，但通常不会压制信息，也不会与意识相抵触。\n意识的框架：AWAREness理论 该框架吸收了传统意识研究的要素，并提出了一些新的观点，集大成者\n注意（Attention） 觉醒（Wakefulness）：通过从睡眠到清醒的脑电，研究睡眠相关现象 构筑（Architecture）：研究决定意识加工的生理结构及其物理定位 知识回忆（Recall of knowledge）: 包括自我知识、世界知识、共情 情感（Emotion） 新异性（novelty）、浮现（emergence）、选择性（selectivity）、主观性（subjectivity） 新异性（novelty）：人和动物都有追求新异而有新信息刺激的倾向，即偏好“新”事物 浮现（emergence）：意识处理的是私有、内部的思想，是关于内部信息和自我反映的神经过程 选择性（selectivity）：人随时不断选择一小部分想法进行考虑，并频繁受到新想法的干扰，“探照灯”隐喻是其具象表现 主观性（subjectivity）：每个人的意识体验是独一无二的 知识回忆 自我觉察：知道自己就是自己，个人信息：可以即刻回忆起来而无需重新体验实际事件。\n世界知识：长时记忆中保存的所有关于外部世界的事实。\n共情：知道另一个的想法，共情敏感性有利于生存。\n觉醒——关于睡眠的研究 第 1 阶段：相对快速、低振幅 第 2 阶段：较低、更有规律的波形，睡眠纺锤 第 3 阶段：较低、较高的峰值和较低的谷值 第 4 阶段：更慢、更有规律，对外界刺激反应最小 快速眼动睡眠（REM sleep）（快速眼动）。 睡眠的特征 90 分钟一个周期，每晚睡眠 4~6 次\n最深睡眠出现在接近夜幕降临时\n快速眼动持续时间随着睡眠的进展而增加第一个周期只有 10 分钟，最后一个周期将近一个小时\n快速眼动 每90分钟出现一次，占成人总睡眠时间的20%，在闭眼状态下出现的眼球快速运动。\n会产生睡眠性麻痹，除了控制眼睛的肌肉外，其他任何自主肌肉都无法运动。\n与做梦有关。\n做梦 生存活动梦理论：梦源于大脑对白天吸收的信息的再处理，这些信息对有机体的生存很重要。 做梦可以增强我们对重要信息的记忆\n激活-合成理论：梦是各种记忆随机激活的结果，这些记忆在逻辑故事情节中交织在一起。\n白日梦：意识的一种常见变化，其中注意力转移到记忆、期望、欲望或幻想上，而远离眼前的情况。\n催眠 一种诱发的意识状态，通常以高度的暗示性、深度放松和高度集中的注意力为特征。\n冥想 一种意识状态，通常是通过专注于重复行为、采取某些身体姿势以及尽量减少外部刺激而引起的 冥想可以用来增强自我认识、幸福感和灵性。 降低新陈代谢率，降低心率和呼吸频率。 大脑活动类似于放松的清醒状态下的活动，伴随的血乳酸下降可以减轻压力。 Baars(1983)提出的综合工作平台理论（剧院模型）把意识看做是一套在整个大脑里传播信息的全局广播系统\n记忆 短时记忆存在的证据：自由回忆实验 自由回忆实验为两种记忆说提供了证据。\n记忆的多重结构 短时记忆、长时记忆、感觉记忆【又称为感觉登记、瞬时记忆，每一种感觉贮存保持的时间均非常短暂而且是感觉通道特异性的（即只局限于一种感觉通道）——ms为单位】。\n感觉记忆：视觉记忆、声象记忆（三耳人声象记忆）\n实验结果： 部份报告法正确率均优于全部报告法； 声象记忆的作用时间在4秒左右，显著高于视觉记忆的几百毫秒；声象记忆的容量为5个左右，而视觉记忆容量8~9个。\nAtkinson \u0026amp; Shiffrin 三级记忆模型（可能会出现） 简化的记忆信息三级加工模型： 记忆的加工水平理论 Craik \u0026amp; Lockhart（1972）对两种记忆说提出了尖锐的批评，提出了完全 相反的假设：即“信息加工——记忆”，区别于之前的“记忆——信息加工”\n存储是在编码深度这个维度上连续变化的。信息被存储的水平取决于被加工的深入程度。\n浅层加工：只涉及很少的对含义的注意  深层加工：涉及深层次的注意，专注于意义，并把它和其他事物关联 Craik 和 Tulving 的实验 不随意学习 短时记忆理论 短时记忆的信息量不是以信息论中的bit为单位，而是以组块（Chunk）为单位\n人利用贮存于长时记忆的知识，对进入短时记忆的信息进行合并，构成有意义的和熟悉的较大的单位\n分组 组块是有意义的，而即使无意义的组合，即分组，同样有利于短时记忆。（注意概念辨析）\n分组是时间、空间接近项目的合并；分组内部并不存在意义联系，也不构成一个熟悉的单位；分组可以增加短时记忆容纳的项目，但作用远小于组块。\n短期记忆信息的提取 短时记忆的提取是序列加工的，进一步是从头到尾进行扫描的，不会发生自我停止，即循环中不会发生break。 实验范式是相加因素法（相加罂粟法） 从头至尾扫描：类比于最优解（如 A星算法） 自我停止扫描：类比与满意解（如 A 算法）\n短时记忆的遗忘 探测法巧妙实现了两个因素间的解纠缠。 长时记忆理论 长时记忆分为陈述性记忆与隐形记忆。 陈述性记忆分为情景记忆与语义记忆。 隐形记忆分为启动效应和程序性记忆。 【长时记忆的神经生理学机制】 当一个刺激不断被重复时，突触产生结构改变，并导致激活频率的增加，这种激活频率的增加被称为“长时程增强效应”（long-term potentiation, LTP）。\n陈述性记忆 情景记忆是对个人在特定的时空背景下特定的经验或事件的记忆 语义记忆是个人关于世界的一般知识的记忆 语义记忆影响情景记忆 外显和内隐记忆 外显记忆受意识控制，测验时要求被试有意识地回忆早期学过的东西\n内隐记忆又叫自动的无意识记忆，测验时不要求有意识地去提取信息，专注眼前作业。\n启动效应（可能会考？）  先前信息潜在影响了后续任务的表现，并且人可能不曾意识到回忆过先前信息，这就是内隐记忆（Implicit memory），与外显记忆相对应。\n人几乎意识不到内隐记忆，它是启动效应研究的基础。\n剑桥大学的阈下启动实验 采用了LDT（词汇判断任务）实验设计范式，破坏视网膜上的视觉暂留，避免短时记忆的影响。\n阈下刺激：呈现时间非常短，被试甚至未察觉到刺激。\n程序性记忆 程序性记忆是针对“怎样做”或“如何做”事情的记忆，它以技巧性动作为基础，包括知觉技能、运动技能和认知技能的记忆。\n长时记忆的模型 层次网络模型的实验验证\n激活扩散模型\n激活扩散模型的验证——语义启动效应 情况1：说出一种水果名称是以A字母开头 情况2：说出一种以A字母开头的水果名称 结果解释：水果这个概念与其下级概念“Apple”等有紧密联系，扩散到“Apple”等结点的激活既多又快，接近其活动阈限，所以一旦接收到“A字母开头”就可很快出现激活交叉，说出“Apple”；但是，在情况2中，由于扇面效应，反应要慢；情况3中，因为增加了知识间的联系 ，可以克服扇面效应，如说出 “pineapple” 扇面效应 由于从一个给定的结点发出的激活总量是一定的，如与该结点相联的结点越多，则激活分配越分散，每个结点所得到的激活越少，因此提取就越慢和越困难，这就是扇面效应——符合能量守恒原理。\n特征模型 层次网络模型与激活扩散模型都属于网络模型范畴\n特征模型范畴主要包括以下两种： 1.集理论模型：概念由属性集或者特征集组成，诸特征同等重要，两个集之间的重叠程度越高，两个概念越接近——类比于汉明（Hamming）距离\n2.特征比较模型：将两个集的特征进一步细化为定义性特征（mandatory） 和特异性特征（optional），且特征按重要性排列，定义性特征高于特异性特征——类比于主成分分析（PCA）\n表征 表征的分类 意象表征 意象（Imagery）的定义：又被称为表象，是对在当前不被感知的事物形象的再现（记忆表象）或想象（想象表象），是一种心理上的类比表征。\n双重编码理论 人脑中同时存在两种信息编码和存储系统。\n表象系统对具体的事物或事件信息进行编码、存储、 转换和提取，其表征类似于知觉。\n言语符号系统主要用言语听觉、抽象概念或命题形式对信息进行加工。\n命题理论 意象表征 意象表征的理论模型 机能等价假设 认为视觉意象在功能上与视觉知觉相对等。\n证据支持：\n意象具有可操作性 定位实验 心理旋转、心理扫描实验 意象缩放实验 神经机能有重叠：脑成像脑损伤研究 【定位实验】 【心理旋转实验】180度时所需反应时最长；人的心理旋转速度约为180度/0.5s；\n【心理扫描实验】意象可以被扫描，扫描时间随距离而增加。\n【意象缩放】 评价主观意象较小的客体要难于较大的客体，这与知觉是相似的。 意象的功能：\n对学习记忆的促进作用：使用意义相近的名词进行成对的联想记忆学习。意象在字词识记中有中介作用，可以促进记忆学习。 对知觉的促进作用 对思维推理的促进作用 概念 认知心理学中概念研究的范畴：\n概念形成：也成为概念学习，是指个人掌握概念的过程，获得事物的概括表征 概念结构：概念的表征由哪些因素所构成，研究表征的内部组织 概念研究的早期阶段：\n刺激-反应原则：共同因素说（Hull，1920），共同中介说（Osgood，1953），强 调概念形成的被动性，忽略了人的主动性\n概念形成 假设-考验说：人在概念形成过程中，需要综合利用即时获得的、和已存贮的信息来主动提出一些可能的假设组成一个假设库，通过某种策略， 从记忆库中选取某种假设，并基于外界的反馈进行考验，直到形成某个正确的假设，形成概念。\n【人工概念的形成实验】\n被试的选择不是杂乱无章的，而是有着某种顺序；部分假设基于正实例的一个 属性建立未知概念的假设，而总体假设聚焦于正实例的所有属性\n策略选取 \n同时性扫描：同时进行多个概念 的假设和考验——记忆负担重  继时性扫描：一次只考验一个假 设——记忆负担轻但易重蹈覆辙  保守性聚焦：排除法，每次更换 一个焦点——优于上述两种策略  博弈性聚焦：一次更换两个以上 焦点——有可能快速发现概念 概念形成研究中的实验范式设计 渐进式还是阶跃式？ 【空白试验法】 概念结构 两种彼此对立的学说：特征表说（一类个体具有的共同重要特征来说明概念）；原型说（原型（最佳实例）表征出来的）\n特征表说 继承了层次网络模型，集理论模型、特征比较模型中对概念的语义特征表征方式。例如：鸟是动物与羽毛的合取。\n原型说 概念主要是以原型，即它的最佳实例表征的，人们能从最好说明一个概念的实例来理解该概念。\n最高等级的实例即为该概念的原型（最佳实例）\n原型的编码（很可能会考） Rosch 1975 匹配试验： 给被试同时呈现一对名词，要求被试尽快说出其范畴是否相同，记录反应时。 决策 贝叶斯推理和决策 人的推理方式是否遵循贝叶斯推理规则？Kahneman 和 Tversky（1972）却认为，人们的思维不符合概率理论，人们会忽略基础概率信息，而使用有偏差的启发式策略进行推理。\n决策框架 人们的决策会受到决策框架的影响 决策框架存在于每个人的头脑之中 问题表述 规范 习惯 个性 框架边界 必须始终明确决策的目标、必须突破老的边界的束缚。\n心理账户（理查德.塞勒） 制定理财计划 不同账户这一概念可以帮助制定理财计划。用于在心理上事先把这些钱一一归入了不同的账户，一般就不会产生挪用的念头\n政府制定政策 一个政府想通过减少税收的方法刺激消费，可有两种做法：\n减税，直接降低税收水平 退税，在一段时间后返还纳税人一部分税金 从金钱数额来看，减收5%的税和返还5%的税是一样的，但在刺激消费上的作用却大不一样 退还的税金对人们来说就如同一笔意外之财，刺激人们增加更多的消费。因此，对政府来说，退税政策比减税政策达到的效果要好得多。 参考点 在决策框架中参考点的作用就象一个坐标系中的原点。 \n参考点选择不同，同样一件事情该不该做，价值如何评价都会完全不同。\n框架标尺 在建立决策框架时，标尺选择不当，对决策的执行就可能失控。\n框架标尺的变化有时会对企业的发展起到导向的作用。\n不确定条件下的人类决策 丹尼尔·卡尼曼（Daniel Kahneman）： 他将认知心理学研究中得到的洞见整合进经济科学，尤其关注不确定条件下的人类判断与决策，阐明了人类决策如何系统地 偏离标准经济学的预测,奠定了一个新研究领域的基础。\n理查德· 塞勒（Richard Thaler）： 将心理上的现实假设纳入到经济决策分析中。通过探索有限理性，社会偏好和缺乏自我控制的后果，他展示了这些人格特质如何系统地影响个人决策以及市场成果。\n丹尼尔·卡尼曼前景理论的特色 与传统经济学理论的最大不同在于，前景理论在“有限理性”的基本假设上解释人类的决策行为。\n期望效用理论 在传统经济学中，冯·纽曼和摩根斯坦于1944年提出的期望效用理论（Expected Utility Theory，简称EU理论） 长期占据统治地位。  该理论认为，人类的决策行为总是期望使自己能够得到的效用为最大，因此，在做决策时，人们会使用自己的理性，根据自己掌握的所有信息做出最优的选择，即使在有风险的条件下依然如此——这就是“理性人”假设。  基于这个假设，期望效用理论认为，期望效用值最大的方案就是最佳决策方案。 有限理性和启发式 抛弃理性人假设，并不意味着人类没有理性，也不意味着人类不使用理性。 理性人假设的问题在于将人类理性的作用范围设定得非常大。 卡尼曼所依据的假设是“有限理性” 另一位诺贝尔经济学奖（1978年）的获得者赫尔伯特·西蒙（Herbert Simon）教授在1947年提出了“有限理性”这个概念。 【有限理性】\n任何动物的思维方式都有其认知局限性而且有赖于其生存的环境\n人的理性是有限的\n人们在做决策时，并不是去计算一个物品的真正价值，而是用某种比较容易评价的线索来判断\n满意原则 以最优为原则进行决策是理想人的专利。 真实人的决策无法坚持最优原则，而只能贯彻满意原则。 满意原则涉及四个基本问题： 有限目标 欲望水平 搜索方法：试探方法，随机方法，折衷方法 效益准则：在决策中尽可能以最少的代价获取满意的结果。 西蒙说：“效益准则指的是，在所用资源一定的情况下，选择能产生最大效益的备选方案。”\n经验和启发式 西蒙认为，由于人的信息加工能力是有限的，人不可能依据所能获得的全部信息做所谓完全“符合理性”的决策，而只能贯彻满意原则，即在决策中尽可能以最少的代价获取满意的结果，主要依靠的是经验和启发式（窍门）。\n著名的二八原则。\n启发式 几种常用的启发式：\n代表性启发式 指人们在决策中倾向于根据某种信息本身在一类别中的代表性，判断该信息属于 特定类别的概率。 易获得性启发式 一种认知捷径，指个体把他/她容易想象或回忆的事件视为与特定现象有关的实例，并基于此做决策。过去的经验误导决策。 锚定和调整策略（锚定-调整启发式） 指人们在获得新信息时，难以准确地修正他们对于事件的最初估计，其判断在很大程度上被“锚定”于事件的“初始值”。 前景理论 卡尼曼和特沃斯基还做了其他大量类似的认知心理学实验。他们的实验结果表明，在不确定条件下，人们所做的判断和决策系统地偏离了期望效用理论的预测，因此，人们并不是完全理性的决策者。\n前景理论的四个原理 大多数人在面临获得的时候是风险规避的 大多数人在面临损失的时候是风险偏爱的 人们对损失比对获得更敏感 参照依赖，多数人对得失的判断往往由参照点决定 【捐赠效应】\n生态理性 特沃斯基和卡尼曼的研究着重在理解人类思维能力本身的限制这个方面。\n当思维能力与环境合适地对应起来时，即使是有限的理性也会由于符合环境的要求而快速有效\n启发式的结构 启发式是由问题而决定的，用于解决不同的问题。\n共同的结构： 搜索规则（寻找环境中的信息和线索）\n停止规则（考虑到几条线索后停止搜索）\n决策规则（吃？跑？攻击？）\n四类借助直觉和常识的思维窍门 基于忽略的决策\n基于忽略的决策：忽略掉以前不曾遇到过的那个选项。 基于忽略的决策是最简单的决策方式，也最适用于限制条件极其严格的环境。 基于单原因的决策\n基于单原因的决策：做出选择的根据仅仅是一条信息。 因为要整合各种不同方面的信息就必须要将这些信息转换成一定数量的通货，然后才能比较这些信息的价值，并 且计算出行动结果的价值 基于多选项消除的决策\n有时没有任何一条评价标准适合于所有的选项。这时候人们就不能够仅用一条线索来衡量所有的选项。 在这样的情景下，多选项逐渐消除的决策方法，简单地说就是排除法，就可以发挥作用了。 基于满意原则的决策\n满意原则与前几类决策方式共同的一点是，它们都适用于同时遇到很多个选项的情况。 与它们不同的是，满意原则在各种选项按时间顺序依次出现时发挥作用。 心理捷径并不总是最好的选择\n一般来说，人们在有充足的时间时往往用复杂的推理 在紧迫情况下，人们用启发式 启发式在很广的范围内适用。\n关于窍门 在卡尼曼和特沃斯基看来，“窍门儿”是人类思维不够完善的标志，它们与人们常常会犯的偏误（Bias）联系在一起，因此他们用窍门儿来解释人们在推理中常常会发生与逻辑不一致的现象。\nGigerenzer 教授的研究显示出，对人类思维而言，窍门儿并不总是意味着偏误。尤其当我们考察发生在真实世界中的决策时，恰恰相反，窍门儿常常意味着用更少的时间，并且保证准确有效的思考。\n",
    
    "date": "2025-02-23 15:00:00",
    "updated": "2025-03-14 16:00:00"
  }
  
  , 
  {
    "objectID": "1737843480",
    "permalink": "/post/proxylab/",
    "title": "CMU Proxylab",
    
    "content": "本文的所有配置、指令均以 Ubuntu 环境为例，而且假设你不具有桌面环境，只有纯命令行环境。\nPre-start 在工作目录下解压proxylab - handout.tar：\ntar -xvf proxylab-handout.tar -x：表示提取文件，也就是解压操作。 -v：用于显示详细的解压过程，方便你了解解压的进度和具体文件。 -f：指定要处理的文件名，后面紧跟要解压的 .tar 文件的名称。 以下是简要介绍，本文的根工作空间是proxylab-handout：\nproxylab-handout ├── Makefile ├── README ├── csapp.c |—— cache.c //自行编写的cache |—— cache.h //自行编写的chche |—— proxy.h ├── csapp.h ├── driver.sh //简单自动评分程序。进行基本的合理性检查。 ├── free-port.sh ├── nop-server.py ├── port-for-user.pl //给出偶数端口号，以便和Tiny web server 进行 testing。 ├── proxy.c //打印出一个特定的 HTTP `User-Agent` 头部信息到标准输出。用于标识客户端软件的类型和版本，服务器可以根据这个信息来提供不同的服务或内容。 └── tiny //tiny服务器 环境配置 配置linux 版本的chrome 和 chrome driver 。两者版本需对应，还有自动化测试工具Selenium，参考[Arthals\u0026amp;rsquo;ink环境配置](更适合北大宝宝体质的 Proxy Lab 踩坑记 • Arthals\u0026amp;rsquo; ink)\nwget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb sudo dpkg -i google-chrome-stable_current_amd64.deb rm google-chrome-stable_current_amd64.deb wget https://edgedl.me.gvt1.com/edgedl/chrome/chrome-for-testing/\u0026amp;lt;your …",
    
    "date": "2025-01-25 15:00:00",
    "updated": "2025-02-16 16:00:00"
  }
  
  , 
  {
    "objectID": "1737670200",
    "permalink": "/post/%E5%A5%87%E6%80%AA%E5%B0%8F%E6%8A%80%E5%B7%A7/",
    "title": "一些奇怪小技巧",
    
    "content": " Shields.io徽章制作 在浏览 GitHub 时，你可能发现很多项目都有很漂亮的徽章。这些徽章可以用来显示项目版本、进度条、star 数量、fork 数量\u0026hellip;.，那么这些徽章是如何生成的呢？\n准确的说，这种 badges 是可以在任何地方使用的，但是一般来说还是在 Github 里面见到的会多一些，所以干脆就在描述中添加一个 Github 的前缀。\n其实这些徽章大多都出于一个网站 shields，里面不仅可以生成静态的徽章，也可以生成动态显示stars的徽章。\n在Shields.io 网站中，进去默认展开的是静态徽章Static Badge。 在右侧可以看到四个内容，分别是：\ntitle：badge 的文字描述。 color：badge 的背景色，使用 hex 编码表示（不包括 #）。 logoname：badge 的 logo 名称。 logocolor：logo 的颜色，使用 hex 编码表示（不包括 #）。 在下图中，logo需要严格按照simple icon中的名字规定，#FCC624规定了徽章的背景色。比如，我找到了微信的图标，只需在simple icon的“logo”栏输入“WeChat”，即可让微信的图标出现在徽章上。 在badgeContent中，一般的输入可以是label-(optional)message-color，即【第一段内容】-【第二段内容】-【颜色】 ，中间使用-隔离。在badgeContent要输入空格或者下划线等内容可以参考下面：\nURL input Badge output Underscore _ or %20 Space Double underscore __ Underscore _ Double dash -- Dash - 例如输入python-\u0026gt;=3.10.0-blue: 与此同时，Shields.io也会生成对应的markdown供你使用。 在这里建议将 logo 颜色设置为白色，然后背景色设置为网页中推荐的那个 logo 的配色，会比正常设置要有质感一些，比如说显示 vitepress，就可以使用：\n![](https://img.shields.io/badge/vitepress-5C73E7?style=for-the-badge\u0026amp;logo=vitepress\u0026amp;logoColor=FFFFFF) ",
    
    "date": "2025-01-23 15:00:00",
    "updated": "2025-02-14 16:00:00"
  }
  
  , 
  {
    "objectID": "1737331200",
    "permalink": "/post/bomblab/",
    "title": "CMU CSAPP bomblab phase1 ~ phase5 解答",
    
    "content": " 写在前面 贴一个下载链接CS:APP3e, Bryant and O\u0026rsquo;Hallaron (cmu.edu)，点击Self-Study Handout下载lab。\n/* Do all sorts of secret stuff that makes the bomb harder to defuse. */ initialize_bomb(); printf(\u0026#34;Welcome to my fiendish little bomb. You have 6 phases with\\n\u0026#34;); printf(\u0026#34;which to blow yourself up. Have a nice day!\\n\u0026#34;); /* Hmm... Six phases must be more secure than one phase! */ input = read_line(); /* Get input */ phase_1(input); /* Run the phase */ phase_defused(); /* Drat! They figured it out! 在进入到phase_1之前，对于input = read_line()函数，我们查看一下input变量的地址，使用gdb bomb命令进入gdb调试阶段，再通过查看反汇编代码确定input = read_line()函数return时的栈顶指针%rsp所指向的内容，先设置断点，为了方便，使用touch ~/.gdbinit命令创建一个默认配置，具体可以参考这个链接。\n在x86-64架构中，返回值会通过特定的寄存器传递。在此架构中，返回值通常存放在 RAX 寄存器中。因此，当你的函数执行到 ret 指令时，返回值会放入 RAX 寄存器，建议在phase_1之前输入p $rax查看寄存器rax的值。\n下图描述了进入explode_bomb()的gdb调试界面，代表这个炸弹即将爆炸： gdb调试命令 gdb //命令 step //步进 layout regs //寄存器变量视图 p/d $rdi //十进制查看变量%rdi的值 x/s $esi //以c风格查看%esi的字符串 x/2d $rsp //十进制查看$rsp开始的两个单位，栈指针 info registers //打印所有寄存器的值 info breakpoints // 打印所有断点的信息 // %rip 储存下一条指令的地址 调试命令示例： 可以看到，在返回read_line 函数后，%rax寄存器的值被保存到了%rdi中，%rdi的值是6305664，%rsp是栈顶指针。\nstring_length复现 if (rdi != 0) { rdx = rdi; rdx = rdx + 1; eax = rdx; rax = rdi if (rdx != 0) 则跳到 rdx = rdx + 1; } 接下来一起解答。\nPhase_1 mov $0x402500, %edi ; 假设这是第二个字符串的地址，放入 %edi call 401338 \u0026lt;strings_not_equal\u0026gt; ; 调用函数比较两个字符串 传入\u0026lt;strings_not_equal\u0026gt;的参数有两个%esi和%rdi\n%esi：通常用来传递第一个指针或地址类型的参数给函数。在字符串操作函数中，它经常被用来传递源字符串的地址。 %edi：通常用来传递第二个指针或地址类型的参数给函数。在字符串操作函数中，它经常被用来传递目标字符串的地址。 Linux遵循System V AMD64 ABI 调用约定，具体来说，函数传参的时候前六个整数或指针参数通常分别通过寄存器 RDI, RSI, RDX, RCX, R8, R9 传递。 也就是说，我们只需要查看%esi的值就行了，在0x400ee9设置断点，输入x/s $esi得到： 于是我们返回到psol.txt中写下这句话，注意不要漏了标点。 Phase_2 第一步，通读代码了解跳转结构，\u0026lt;read_six_numbers \u0026gt;函数告诉我们应该在psol.txt文件下写入6个数字。 接着，我们可以在0x400f0e、0x400f1e、0x400f3a处设置断点(主要是前面两个)，这三处都是跳转语句。对于(%rbx)，使用x/d $rbx或者x/2d $rbx查看十进制的值，对于%eax，可以使用p/d查看十进制的值。\u0026lt;read_six_numbers \u0026gt;的返回结果先存在于%rsp中，随后第一位数字被“吃掉”，剩下的数字放在了(%rbx)中。 接着： 接下来，当gdb每一次在0x400f1e处停下时，我们可以通过p/d $eax查看%eax的值，修改对应的%rbx的值就可以了，最后答案是1 2 4 8 16 32。\nphase_3 首先观察代码结构，凭借个人经验在je、ja、jmp处打上breakpoints，很明显phase_3的代码有switch关键字。 在sscanf函数之前添加断点，使用(gdb) x/s $esi可以看到两个%d %d，这提醒我们输入十进制的两个数字。在400f6a处提醒我们输入的第一个数字应当小于7，我这里输入的是7。在400fb9和400fbe可以看到第二个数字应该等于0x137,也就是327。\n解开答案，调试界面输出： phase_4 我们注意到了这一句话，结合上一题的经验，很有可能在提醒我们应该有两个输入。 于是我们在psol.txt中写下：999 666。 continue!\nphase_4 step1 我们在调试时发现： 这意味着输入的第一个数字应该小于等于14。\nphase_4 step2 在调试时，遇到了难点\u0026lt;func4\u0026gt;它是一个递归函数，我们需要让其返回值%rax的值等于0，这样才不会触发0x40104f的跳转： func4 这段代码类似于二分查找，发现其有极高的对称性。当输入的rdi(应该是rdi)为1时，func4函数返回值为0。\nphase_4 step3 0x401051启示我们输入的第二个参数为0。 因此答案：1 0 phase_5 先标好跳转结构： 看到函数string_length和cmp $0x6 %eax输入应该是长为6的字符串，于是我们在psol.txt中写下：\n\u0026#39;xjtu\u0026#39; 在0x4010bd处，我们发现： 'xjtu' -\u0026gt; snoies, snoies作为输入时，$rsp+0x10的值是就变成了snoies=\u0026gt;uylfeu。我们需要某六个数字，使得变换之后的结果是flyers。这究竟是什么样的映射呢？ 这个过程不可谓不离奇曲折，但是当我们知道了具体的过程之后，就可以很容易地得到答案了。\n首先，我们先去维基百科找来一张 ASCII 码表： 分析 在0x4010778处， xor %eax,%eax执行异或操作，将EAX寄存器与自身进行异或。由于任何数与自身进行异或的结果都是0，这条指令通常用于将EAX寄存器的值快速清零。\nmovzbl 指令是一个数据传送指令，从内存地址 %rdx + 0x4024b0 处读取一个字节（8位）的值，将这个字节值移动到EDX寄存器的最低位字节，之后将EDX寄存器的高位24位填充为零。\n在0x40108b到0x4010ac，我们可以看到一个循环，直到%rax的值满6方能离开，但是这个循环中的代码十分难懂。\n以输入'xjtu'为例，在循环中我们发现寄存器%rcx的变化，分别是115=》110=》111=》105=》101=》115，分别对应 snoies的acsii码，而读取'xjtu'的寄存器%rcx，值分别是39=\u0026gt;120=\u0026gt;106=\u0026gt;116=\u0026gt;117=\u0026gt;39，在下面语句设置断点发现%rdx的值就此变化：\n401099: 0f b6 92 b0 24 40 00 movzbl 0x4024b0(%rdx),%edx 4010a0: 88 54 04 10 mov %dl,0x10(%rsp,%rax,1) 我们尝试破解它，在循环任意一处打上断点后，我们对movzbl 0x4024b0(%rdx),%edx进行探索，它将0x4024b0作为地址偏移量，读取一个字符，将其转换为无符号32位整数值放入$edx，接着%edx的最低八位寄存器%dl将字符入栈。现在调整地址偏移量看看： 以'xjtu'的输入中的'为例子，在0x401099处： 以'xjtu'的输入中的x为例子，在0x401099处(%rdx未变化)： 以'xjtu'的输入中的j为例子，在0x401099处： 以'xjtu'的输入中的t为例子，在0x401099处： 以'xjtu'的输入中的u为例子，在0x401099处： 结合下面指令会发现取了%rcx的低位为%rdx寄存器的初始值。\n401096: 83 e2 0f and $0xf,%edx 于是会发现一个很奇怪的字符串aduiersnfotvbyl，第七个是s，第八个是n，与%rdx初值刚好相等。至此，在psol.txt中输入:ionefw即可，答案不唯一。 这代表我们 ：Success！\nphase_6 (已烂尾) 看来又是读入六个数字，0x401121及其附近告诉我们第一个数应该小于等于5。 %rbx寄存着读入数字的个数。\n未完待续……\n",
    
    "date": "2025-01-20 00:00:00",
    "updated": "2025-01-20 00:00:00"
  }
  
  , 
  {
    "objectID": "1737331200",
    "permalink": "/post/docker/",
    "title": "docker与dev container插件的使用",
    
    "content": " 本文侧重1.讲解docker的插件使用。2.视觉consimulation项目的跨环境迁移\n基础配置 安装vscode。 在vscode安装 Docker 插件与ms-vscode-remote.remote-containers插件。 Docker 学习 这里可以参考：阮一峰docker教程、菜鸟教程docker、雪雁docker\n容器container是镜像image的实例化。\n生成 dockerfile 一种途径是自行编写dockerfile，另一种途径是使用插件自动生成再进行修改。\ndockerfile的编写：知乎、CSDN\n无论是自行编写还是自动生成，需要知道的是，镜像image是由多个“层”组成的。每一层都是镜像构建过程中的一个步骤，每次 Docker 执行一个命令（例如 RUN、COPY、ADD 等）时，都会生成一个新的层。这些层共同构成了 Docker 镜像的内容。就使用dev container而言，dockerfile应该仅包含环境配置，不应该包含对应的项目功能代码包。\n自动生成示例：\n使用Docker扩展可以非常方便的从VisualStudio Code构建，管理和部署容器化应用程序，可以自动生成dockerfile、docker-compose.yml和.dockerignore文件（按F1并搜索Docker：将Docker文件添加到Workspace） Add Docker Files to Workspace用于生成一个单独的 Docker 配置文件（Dockerfile）和与之配套的基础配置文件。可能还会生成与应用环境相关的文件，例如 .dockerignore。 Add Docker Compose Files to Workspace 用于生成支持多服务编排的 Docker Compose 配置文件（docker-compose.yml）。如果你的项目需要多个服务（例如后端服务、数据库服务、缓存服务）共同运行，这是更适合的选项。 接着：根据项目选择基本配置，由于不同项目需要配置不同，跟着导引选择。 ASP.NET Core 是用于构建 Web 应用程序的跨平台框架，适用于构建现代化的 Web 服务和应用。它支持 HTTP 请求处理、Web API、WebSocket、以及其他网络相关的功能。 Console 应用是一个基于命令行界面的应用程序，通常用于执行后台任务、处理批量操作、定时任务等。 这些信息自行GPT即可。\nbuild 上面步骤完成之后，你的项目会有dockerfile和.dockerignore，或许会有docker-compose.debug.yml、docker-compose.yml。\n在资源管理器中选中dockerfile并且右键点击，找到build image..选项，接着输入\u0026lt;镜像名\u0026gt;:\u0026lt;标签\u0026gt; 这一步相当于:docker build -t \u0026lt;your-image-name\u0026gt;:\u0026lt;your-tag\u0026gt; .\n-t your-image-name:your-tag：这里你可以指定镜像的名称和标签。例如，your-image-name 是镜像的名称，your-tag 是标签（如 latest 或 v1.0）。 .：表示 Docker 构建上下文是当前目录，这意味着 Docker 会在当前目录下查找 Dockerfile。 接着等待结果。注意保持网络畅通无阻，在git clone into..这一步很容易Failed to connect to github.com port 443: Timed out 。 这样就算构建image成功了： 这时候你将在docker插件页面的左侧中见到刚刚 build 的 consimulation:2.0.0，如下图。registeries可以连接到dockerhub和github账号，不过本人dockerhub的状态一直是fetch failed。\n可以在终端输入docker images查看已经构建的images。docker container ps则可以查看目前正在运行的容器的CONTAINER ID、镜像名称、端口映射等等状态。 右键点击刚刚build的image，可以看到run和run interactive两个选项:\nRun 是直接启动容器并执行指定的命令。这通常用于容器启动后不需要用户干预的场景。容器在后台运行，不会直接打开交互式终端，适合用于以下情况： Run Interactive 则是以交互模式启动容器，并附加到容器的终端。这意味着你可以与容器内部进行交互，通常是进入容器的命令行（shell）进行操作。 此时也可以在终端输入docker run -it --rm \u0026lt;image_name\u0026gt;:\u0026lt;tag\u0026gt; /bin/zsh。这里的/bin/zsh是启动容器时执行的命令，也可以是/bin/bash等等，取决于dockerfile的配置。-it中 -i 表示以交互模式运行容器，-t 会为容器分配一个伪终端（terminal），这使得你能够与容器进行交互。--rm代表容器在退出后会被自动删除。这意味着容器停止后会被清除，不会留下任何痕迹。\n启动示例： 在vscode中下载dev container插件，ctrl+shift+p选择rebuild and reopen in container。\n接着会发现，我们的image实例化之后的容器虽然在build时没有包含代码功能包，但我们是可以发现存在于本地项目下的代码功能包却在dockercontainer开发容器中。这样就可以对已经构建的容器进行测试了。。\n.devcontainer文件 当你build好image之后，这时你的的image还在本地，本机可以作为宿主机。\nVisual Studio Code Dev Containers扩展允许您使用Docker 容器作为功能齐全的开发环境。项目中的文件告诉 VS Code 如何使用定义良好的工具和运行时堆栈devcontainer.json访问（或创建） Dev Containers 。该VS Code 的容器配置存储在devcontainer.json文件中。该文件类似于用于launch.json调试配置的文件，但用于启动（或附加到） Dev Containers 。\n这一部分可以参考：vscode 文档、一起学docker \u0026lt;=讲的挺好的\n使用docker插件自动生成: 按下F1，输入add development container configuration files... 选择：来自dockerfile。\n选择配置：\n编写流程：\n1、在 Command Palette 中，使用 Remote-Containers: Add Development Container Configuration Files 命令开始配置开发容器\n2、按需编辑 .devcontainer 文件夹的内容\n3、使用 Remote-Containers: Reopen in Container 来验证自己的配置是否可行\n4、如果看到错误，在弹出的对话框中选择 Open Folder Locally\n5、在窗口重新加载之后，控制台中会出现一份 build log （构建日志），以便查找问题点。再次按需编辑 .devcontainer 文件夹的内容。（如果你把构建日志关闭了以后，又想再看一下的话，可以使用 Remote-Containers: Open Log File 命令再次打开）\n6、运行 Remote-Containers: Rebuild and Reopen in Container 命令，如果需要，回到第 4 步。如此反复。\n如果你已经成功构建了容器，仍旧可以在连上容器以后，按需编辑 .devcontainer 文件夹里面的内容。之后在 Command Palette 中，选中 Remote-Containers: Rebuild Container 命令，让修改的内容生效。\n编写好.devcontainer/devcontainer.json文件之后，就能畅通无阻使用ctrl+shift+p在开发容器玩耍了。\ncon_simulation视觉代码 由于dockerhub难以连接上(蚌埠住了)，假设原镜像有n层，本人build的n+1层镜像无法push到dockerhub，因此使用母镜像，经过测试确实能够使用，只不过镜像并不是本人的：\ndocker pull lihanchen2004/pb_rm_simulation:1.0.0 接着在rcgogs代码仓库git clone consimulation代码，用vscode打开，ctrl+shift+p，输入并点击 Dev Containers:Rebuild and Reopen in Container。\n示例： 附上json文件：\n{ \u0026#34;name\u0026#34;: \u0026#34;con_simulation\u0026#34;, //本次的容器名称 \u0026#34;image\u0026#34;: \u0026#34;lihanchen2004/pb_rm_simulation:1.0.0\u0026#34;, // dev container 连接到的本地镜像名，可以用docker images命令找到对应的名字 \u0026#34;runArgs\u0026#34;: [ \u0026#34;--init\u0026#34;, \u0026#34;--gpus=all\u0026#34;, \u0026#34;--privileged\u0026#34;, \u0026#34;--env=NVIDIA_DRIVER_CAPABILITIES=all\u0026#34;, \u0026#34;--env=DISPLAY=${localEnv:DISPLAY}\u0026#34;, \u0026#34;--env=QT_X11_NO_MITSHM=1\u0026#34;, \u0026#34;--volume=/tmp/.X11-unix:/tmp/.X11-unix\u0026#34;, \u0026#34;--network=host\u0026#34; ], \u0026#34;customizations\u0026#34;: { \u0026#34;vscode\u0026#34;: { \u0026#34;extensions\u0026#34;: [ \u0026#34;llvm-vs-code-extensions.vscode-clangd\u0026#34;, \u0026#34;vadimcn.vscode-lldb\u0026#34;, \u0026#34;xaver.clang-format\u0026#34;, \u0026#34;ms-python.python\u0026#34;, \u0026#34;ms-iot.vscode-ros\u0026#34;, \u0026#34;ms-vscode.cmake-tools\u0026#34;, \u0026#34;usernamehw.errorlens\u0026#34; //拓展名，具体怎么来的可以参考上面的[一起学docker]链接。 ] } } } ",
    
    "date": "2025-01-20 00:00:00",
    "updated": "2025-01-20 00:00:00"
  }
  
  , 
  {
    "objectID": "1737072000",
    "permalink": "/post/%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E5%9F%BA%E7%A1%80/",
    "title": "存储系统基础",
    
    "content": "存储系统分为四类：\n单机存储 File-system Key-Value 单机数据库 关系型和非关系型 分布式存储 分布式文件系统GFS HDFS等 对象存储TOS 分布式数据库：关系型(MySQL Oracle)和非关系型数据库 分布式存储选型 在TOS中，所有的数据都存储在“桶”中。桶是容器，可以理解为用于组织存储对象的命名空间。每个桶都具有唯一的名字，并可以设置权限来控制谁可以访问。 存储对象使用 先在TOS上申请一个Bucket，里面可以存放很多objects。此外，TOS提供了丰富的RESTful API，可以实现文件的上传、下载、删除、查询等操作。\n对象存储对外提供的一般都是Restful风格的接口。\nrestful风格：[参考链接1](https://zhuanlan.zhihu.com/p/334809573)、[参考链接2](https://www.runoob.com/w3cnote/restful-architecture.html) 以资源为基础 ：资源可以是一个图片、音乐、一个XML格式、HTML格式或者JSON格式等网络上的一个实体，除了一些二进制的资源外普通的文本资源更多以JSON为载体、面向用户的一组数据(通常从数据库中查询而得到)。RESTful风格的API则要求在URL上都以名词的方式出现，从几种请求方式上就可以看出想要进行的操作，这点与非RESTful风格的API形成鲜明对比。 统一接口: 对资源的操作包括获取、创建、修改和删除，这些操作正好对应HTTP协议提供的GET、POST、PUT和DELETE方法。换言而知，使用RESTful风格的接口但从接口上你可能只能定位其资源，但是无法知晓它具体进行了什么操作，需要具体了解其发生了什么操作动作要从其HTTP请求方法类型上进行判断。具体的HTTP方法和方法含义如下： - GET（SELECT）：从服务器取出资源（一项或多项）。 - POST（CREATE）：在服务器新建一个资源。 - PUT（UPDATE）：在服务器更新资源（客户端提供完整资源数据）。 - PATCH（UPDATE）：在服务器更新资源（客户端提供需要修改的资源数据）。 - DELETE（DELETE）：从服务器删除资源。 @PutMapping(\u0026#34;/dogs/{id}\u0026#34;) //`@PutMapping(\u0026#34;/dogs/{id}\u0026#34;)`：这是Spring注解，它将HTTP请求（路径为`/dogs/{id}`的PUT请求）与 `updateDog()` 方法绑定。 public ResponseEntity\u0026lt;String\u0026gt; updateDog(@PathVariable int id, @RequestBody Dog dog) { dog.setId(id); // 设置ID boolean isSuccess = dogMapper.updateDog(dog); if (isSuccess) { return new ResponseEntity\u0026lt;\u0026gt;(\u0026#34;Dog updated successfully\u0026#34;, HttpStatus.OK); } return new ResponseEntity\u0026lt;\u0026gt;(\u0026#34;Failed to update dog\u0026#34;, HttpStatus.BAD_REQUEST); } MultiUpload 接口 对于GB数据大对象： Web应用：允许用户一次上传多个文件，如在照片库中上传多个图片文件。 云存储服务：例如AWS S3、Google Cloud Storage等支持批量上传文件。 实现 前端：通过HTML表单的\u0026lt;input type=\u0026quot;file\u0026quot; multiple\u0026gt;属性允许选择多个文件。\n\u0026lt;form action=\u0026#34;/upload\u0026#34; method=\u0026#34;POST\u0026#34; enctype=\u0026#34;multipart/form-data\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;files\u0026#34; multiple\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;Upload\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; 后端：\n@PostMapping(\u0026#34;/upload\u0026#34;) public ResponseEntity\u0026lt;String\u0026gt; handleMultiFileUpload(@RequestParam(\u0026#34;files\u0026#34;) MultipartFile[] files) { for (MultipartFile file : files) { System.out.println(\u0026#34;Uploading: \u0026#34; + file.getOriginalFilename()); } return ResponseEntity.ok(\u0026#34;Files uploaded successfully!\u0026#34;); } Listprefix接口 list-prefix（列出前缀）通常出现在云存储服务中，指的是根据特定前缀筛选文件或对象的功能。在大多数云存储服务中，文件或对象被组织在一个“桶”或“容器”中，而prefix可以帮助你只列出符合特定前缀的文件。 分页列举接口： 实现： 假设我们在AWS S3存储了多个文件，其中有一些文件的键以photos/开始，使用Prefix参数可以列出这些文件。\nAmazonS3 s3Client = AmazonS3Client.builder().build(); ListObjectsV2Request listObjectsRequest = new ListObjectsV2Request() .withBucketName(\u0026#34;my-bucket\u0026#34;) .withPrefix(\u0026#34;photos/\u0026#34;); ListObjectsV2Response response = s3Client.listObjectsV2(listObjectsRequest); for (S3ObjectSummary objectSummary : response.contents()) { System.out.println(objectSummary.getKey()); } ",
    
    "date": "2025-01-17 00:00:00",
    "updated": "2025-01-17 00:00:00"
  }
  
  , 
  {
    "objectID": "1736899200",
    "permalink": "/post/git%E7%9B%B8%E5%85%B3/",
    "title": "Git 相关",
    
    "content": "本文前半部分较为基础，后半部分对.git目录下进行了相关的解释。\n基本命令 cd : 改变目录 cd .. 退回到上级目录 cd (filename)进入文件夹 pwd 显示当前目录 clear 清屏 ls 显示当前目录下的所有文件 touch （文件名.后缀） 新建一个文件 rm （文件名.后缀） 删除一个文件 mkdir test 建立一个test目录 rm -r test 删除test mv index.txt test 移动index至test中 history 查看历史命令 help 帮助 exit 退出 git项目基础 cd /path/to/your/project # 进入项目目录 git init # 初始化 Git 仓库 git add . # 添加所有文件到暂存区 git commit -m \u0026#34;initial commit\u0026#34; # 提交文件 git remote add origin https://github.com/your_username/your_repository.git # 添加远程仓库 git branch -M main 将本地主分支设置为main git checkout -b new-branch # 创建并切换到新分支 git push -u origin new-branch # 推送到新分支 内容过于基础，不再赘述。 .git /config --global、--system、--local 存在于.git/config中。高级别的设置会覆盖低级别的设置\ninstead of 配置 : git config --global url.git@github.com:.insteadOf https://github.com/ git 别名配置 git config --global alias.cin \u0026quot;commit --amend --no-edit\u0026quot;用cin代替。git commit --amend --no-edit 命令可以修改上一次提交的变更内容。 git config -l 当前项目下的配置 git config --system --list 查看系统的配置 git config --global --list 查看用户的配置 名字 邮箱等等 就是c盘用户目录下的.gitconfig 文件 git config --global user.name 进行更改 cat .git/config输出 git/objects git cat-file -p \u0026lt;commit hash\u0026gt; 这里的\u0026lt;commit hash\u0026gt;是在.git目录下的object的hash码，在项目根目录下使用tree .git可以看到。commit/tree/blob统一称为objects。\nblob 存储文件的内容 Tree存储文件的目录信息 commit存储提交信息，一个commit可以对应唯一版本的代码。 串联起来 通过commit寻找到Tree信息，每个commit都会存储对应的Tree ID。输入git log查看版本历史提交。如下：\ncommit 440c02148f899929c2faa3cbf5ca42f3f8785296 Author: utopia-x \u0026lt;your-email@linboxi123@163.com\u0026gt; Date: Sat Jan 4 16:29:19 2025 +0800 接着， 通过Tree找到对应的目录树信息：\nxixiboliya@laptop-tex4-of-boxing MINGW64 /e/mywebsite/Bertsin\u0026#39;s web (main) $ git cat-file -p 440c02148f899929c2faa3cbf5ca42f3f8785296 tree 91af69bb0a1bb9c836d9c57177cddfe1cd7da56b author utopia-x \u0026lt;your-email@linboxi123@163.com\u0026gt; 1735979359 +0800 committer utopia-x \u0026lt;your-email@linboxi123@163.com\u0026gt; 1735979359 +0800 first commit 通过Tree中获得blob的ID，通过blob获取对应的文件内容。 输入$git cat-file -p 91af69bb0a1bb9c836d9c57177cddfe1cd7da56b有： .git/refs head 分支名字存储在rref/heads文件夹下面。\nxixiboliya@laptop-tex4-of-boxing MINGW64 /e/mywebsite/Bertsin\u0026#39;s web (main) $ cat .git/refs/heads/main 156836544ef549d2a6af0774c7304eda45266672 tag refs文件存储的内容就是对应的commit ID，因此把ref当作指针，指向对应的commit来表示当前ref对应的版本。\ngit tag v0.0.1 annotation tag git -a v0.0.2 -m \u0026#34;add feature 1\u0026#34; cat .git/refs/tags/v0.0.2`输出object的hash值 git cat-file -p [hash] 输出相关信息 其中就有annotation tag。\n回溯历史版本代码 通过ref指向的commit可以获取唯一的代码版本。\ncommit --amend修改最近的一次commit信息，修改之后commit id 会变化。 rebase通过git rebase -i HEAD~3可以实现对最近三个commit的修改。\n合并commit 修改具体的commit message 删除某一个commit git gc 可以删除一些不需要的object以及会对object进行一些打包也锁来减少仓库的体积。\ngit gc --prune=now指定修剪多久之前的对象，默认是两周前。\nreflog reflog是用于记录操作日志，防止误操作后数据丢失。通过reflog来找到丢失的数据，手动将日志设置为过期。\ngit reflog expire --expire=\u0026#34;2.weeks.ago\u0026#34; --all clone与fetch git fetch将远端某些分支最新代码拉取到本地，不会进行merge操作。会修改refs/remote内的分支信息，如果需要和本地代码合并需要手动操作。\npull等于上述clone 和fetch的综合。不知道远端的修改建议先fetch在进行rebase。\n",
    
    "date": "2025-01-15 00:00:00",
    "updated": "2025-01-15 00:00:00"
  }
  
  , 
  {
    "objectID": "1735510200",
    "permalink": "/post/%E6%88%91%E7%9A%842024%E6%80%BB%E7%BB%93/",
    "title": "my 2024 summary",
    
    "content": " 我的2024总结 当敲下‘my 2024 summary’这行标题开始本文的写作时，我正身处z128号列车归乡途中。z128是连接东西的大动脉之一，从西北到东南，从古都到蛮夷之地，从兰州、西安到福建，缓缓东迁、南开。今天没有下雨，车窗漏过的阳光着实令人欣慰，这在西安并不常见，当然也可能是北方都不常见，西安碑林区冬天的阳光几乎令人感觉不到温度。\n尽管是临近除夕，确切而言，西安的年味并不浓厚。尽管政府在西安城墙、交大兴庆宫等古迹处加上了各种璀璨且卷出新高度的花灯，但明显体感的人口返乡外流、每晚零下凛然的室外寒风着实令人感到荒芜与漂泊。常常感到自己的抉择一定意义上都落向了漂泊，就像波函数向的某种定态的坍缩一般，只不过在十多年前是北漂，如今之后可能是南漂。\n2024年年初还残留着一些博览古今的幻想。一年前的这段时间，借着复旦的一个全国性活动的名义，我正在研读跟专业毫不搭噶的斯多葛学派的哲学著作，寒假在家里面坐牢一点一点地憋了快20天才磨出来一篇巨型学术缝合作品《具身治疗》。这意义不大，但当初为什么会这样做很大程度上是因为笔者才大一，可以允许自己盲目探索一会儿。最大的收获是加了一位2021级pku学长的微信——这是一位个人感觉人格张力拉满的同学：学的是协和八年制临床，但在朋友圈表达过不想做研究型的学者，与此同时是pku学生合唱团成员，不仅有指挥经历，还有与中央多名艺术家同台或者受指导的经历。那位同学同时是一个e人，尽管他平时经常抽烟。笔者文笔功底有限，只能用有趣来形容这样的同学。上图中有fdu的星空咖啡馆、子彬院的会议厅照片。在答辩完之后笔者认识到fdu那些学问建树颇为丰硕的学者也不过是某一细分领域的学者专家，因为一个人的精力实在无法广博通闻诸多领域的诸多事。但话说回来，放在人生的维度上，笔者还是希望自己能够有趣一些。 是的，能够在个人擅长的技能上探索是一件有趣的事。但何谓擅长，你会发现大多人一生都不知所云，大多者只是浑噩地从事一份工作罢了。正如笔者在县城的时候辅导过课业的几位学生。成绩确实不够好，但一天天的披星戴月，不挑餐食又照顾妹妹关心家长，平时老实不去花里胡哨地玩，家长一想确实找不到理由训斥他。只是说不擅长读书罢了，不太能够实现阶级跃迁罢了，但这又如何能言呢？在其他方面笔者确实自愧不如。对于有趣而言，笔者曾认为自己在讲话方面挺擅长的，于是在4月份5月份背宣讲稿子希望加入西迁博物馆宣讲团。那时二十页A4纸左右的讲稿，笔者自己吸收内化，磕磕绊绊地背了将近一学期，但最后试讲的结果并没有很好，宣讲的语言过于平白。或许笔者擅长的只是像讲课那样侃侃而谈无所拘束的讲话，背讲稿、背台词的工作一直是笔者吃力的领域，于是这方面的时间和精力投入便变成了沉没成本。这是笔者所做出的探索。\n自2月的年初开始，笔者对从事硬件控制的幻想逐步被戳破。那时找了北极熊学姐加入了robocup的一个组，做的是工程竞技项目，说白了是一个很无聊的工作——在一个迭代成熟的项目下教会机器人走路。现在以浅薄的分析，似乎可以手调RL，但对于本科生而言难度疑似略大。这个项目采用的自制板和舵机经常是出现了问题难以排查。这里接触不良，那里电压不够……可能是笔者较菜，硬件的debug、PCB板与黑商的交涉总是让人头疼。于是在五月份六月份已然属于灰心的状态，当时遇上考试周，这令笔者感到些许压抑。直到期末考之后才已然发现做这个项目的大部分的时间效果甚微。是这样的，比赛是这样的，我所能作的是这样的。到六月份那时，这个项目逐渐被笔者不看好因而处于淡淡然然的状态。七月份参加了robocup的省赛是省二，但已经看到了机械结构的不足，接着是10月份的国赛，成绩并不好。或许吧，是这样的。\n笔者作为南方人第一次摸爬滚打地尝试了滑雪、为了满足占有欲用暑假辅导的收入购置了一个运动相机、勇闯了西安银泰社交coser拍照、不定时打卡了的家乡风味、摸摸碰碰跑通了RC livox lidar的代码、一刷与带mesome二刷了的华山之旅，还有糖蒜铺子的脱口秀experience（或许笔者更擅长这个？但是笔者实在不会叙述故事）、因为失落没人陪独自到青龙寺用周易算了命结果是上签而一时怀疑算命先生作祟、接任了唐仲英爱心社的某个小部长的职位、去了一次再也不会去的兵马俑骊山、参加了令人失落的发展对象答辩、下学期拿到了（？混进了）XJTU RC队伍 、回家再次品尝许久未吃的永安粿条和沙县小吃、元宵错失了家乡刚申请非物质文化遗产板凳龙的大型巡演……某种意义上是这样的，笔者与自己在某种意义上达到了和解——摆摆烂烂的，尽管许多时候感到无力与尽力、压抑与不知所措。 相当一部分繁忙事务的原因是自己在给自己层层加码，但转念一想繁忙某种意义上是精神世界的反衬。\n有人思来想去扪心自问却仍未选择，有人稀里糊涂不知不觉却已经在路上。\n编辑此行时正值2025春节元宵，笔者正在东航MU从福州长乐机场飞往西安咸阳的客机上。年味即将散去，往往令人沮丧，但新的一年希望保持心情、希望有所取舍、希望认识更多的人、希望有所进取与收获。笔者与正在阅读此文的你，共勉。\n我还是很喜欢家乡味道的。\n",
    
    "date": "2024-12-29 15:00:00",
    "updated": "2024-12-29 16:00:00"
  }
  
  , 
  {
    "objectID": "1735063200",
    "permalink": "/post/doxygencommit/",
    "title": "Doxygen 与 commit规范",
    
    "content": " 开始之前 首先推荐大家在vscode中下载插件==通灵译码==或者==GitHub complie==，能极大偷懒提升效率。 示例： 什么是Doxygen Doxygen 是一种文档生成工具，常用于整个项目的Doxyfile的生成，主要用于从源代码中提取注释，并生成技术文档。它广泛用于 C++、C、Java、Python 等多种编程语言中，帮助开发者自动生成文档，从而提高代码的可读性和维护性。\n具体功能： 从代码注释中生成文档：Doxygen 通过解析源代码中的特殊注释格式，将其转换成 HTML、LaTeX、XML 等多种格式的文档。\n支持多种编程语言：除了 C 和 C++，Doxygen 还支持 Java、Python、PHP 等许多其他语言。\n交叉引用代码和文档：Doxygen 可以生成类结构、函数调用图等内容，使得文档与代码紧密结合，便于开发者理解代码的架构。\n可生成不同格式的输出：例如 HTML 文档可以方便地作为在线帮助系统，LaTeX 格式可以用于打印高质量的 PDF 文档。\n下载与使用 vscode插件 在扩展商店里搜索并安装如下扩展\nDoxygen Documentation Generator 接着按下ctrl+shift+p，输入settings.json，打开工作区设置，可以设置快捷键和默认样式\n{ // 触发快捷键 \u0026#34;doxdocgen.c.triggerSequence\u0026#34;: \u0026#34;///\u0026#34; //在函数名前插入 `///`+回车，触发函数注释 } 进一步也可以：\n{ // 起始行样式 \u0026#34;doxdocgen.c.firstLine\u0026#34;: \u0026#34;/*!\u0026#34;, // 模版文件样式 \u0026#34;doxdocgen.cpp.tparamTemplate\u0026#34;: \u0026#34;@tparam{indent:15}{param}\u0026#34;, // 文件头注释样式 \u0026#34;doxdocgen.file.fileTemplate\u0026#34;: \u0026#34;@file{indent:15}{name}\u0026#34;, // 函数注释样式 \u0026#34;doxdocgen.generic.useGitUserName\u0026#34;: true, \u0026#34;doxdocgen.generic.authorTag\u0026#34;: \u0026#34;@author{indent:15}{author}\u0026#34;, \u0026#34;doxdocgen.generic.briefTemplate\u0026#34;: \u0026#34;@brief{indent:15}{text}\u0026#34;, \u0026#34;doxdocgen.generic.dateTemplate\u0026#34;: \u0026#34;@date{indent:15}{date}\u0026#34;, \u0026#34;doxdocgen.generic.paramTemplate\u0026#34;: \u0026#34;@param{indent:15}{param}\u0026#34;, \u0026#34;doxdocgen.generic.returnTemplate\u0026#34;: \u0026#34;@return{indent:15}{type}\u0026#34;, // 自定义标签、顺序 \u0026#34;doxdocgen.file.fileOrder\u0026#34;: [\u0026#34;file\u0026#34;, \u0026#34;author\u0026#34;, \u0026#34;date\u0026#34;], \u0026#34;doxdocgen.generic.customTags\u0026#34;: [\u0026#34;@attention\u0026#34;] } Windows下载doxygen 打开开始菜单，查找“Doxygen”。如果未找到，说明你需要下载并安装 Doxygen。 访问 Doxygen 官方下载页面，下载适用于 Windows 的 Doxygen 安装包。 安装完成后，重新打开 VSCode 尝试运行 doxygen。 Ubuntu / Linux sudo apt-get install doxygen 打开终端，编辑 .bashrc 文件:\nvim ~/.bashrc # 对于 Bash Shell 添加以下内容：\nexport PATH=\u0026#34;/usr/local/bin:$PATH\u0026#34; 保存文件并刷新终端配置：\nsource ~/.bashrc # 使用 Bash 使用 文件头 这部分包括license、版权声明注释、文件描述注释。 函数 接着在函数名前、#include前输入/***/或者///并且分行，便可以使用Doxygen。 将鼠标hover在函数上会出现如下信息： 生成Doxyfile 打开当前工作目录，在终端中输入:\ndoxygen -g // g是generate，用于生成默认的 `Doxyfile` 配置文件。 此时你的项目下会多一个Doxyfile。 如果你想进一步，可以：\ndoxygen 你的项目下会生成html和latex文件夹。\n语法 文件 @file： 文件名 @brief：文件一句话介绍 @author：文件作者 @date：修改日期 @see：额外的一些参考信息，比如有用过的链接 @addtogroup ：创建函数分组 ，@{ 和 @} 表示分组的开始和结束 /** @addtogroup DOXYGEN_API * @brief Doxygen api example. * * Detailed api description. * * @{ */ /** * @brief A sample function in the API group. * * This function demonstrates a typical API function. * * @param a Input parameter. * @return Result of some computation. */ int sample_function(int a) { return a * 2; } /** @} */ 结果在doxygen Doxyfile中：\nAPI Groups: - DOXYGEN_API - sample_function (A sample function in the API group) 变量前的注释 /** * @brief Use brief, otherwise the index won\u0026#39;t have a brief explanation. * Detailed explanation. */ typedef struct BoxStruct { int a; /**\u0026lt; Some documentation for the member BoxStruct#a. */ int b; /**\u0026lt; Some documentation for the member BoxStruct#b. */ double c; /**\u0026lt; Etc. */ } tBoxStruct; API 函数注释样例 /* GLOBAL FUNCTIONS */ /** * @brief Example showing how to document a function with Doxygen. * * Description of what the function does. This part may refer to the parameters * of the function, like @p param1 or @p param2. A word of code can also be * inserted like @c this which is equivalent to \u0026lt;tt\u0026gt;this\u0026lt;/tt\u0026gt; and can be useful * to say that the function returns a @c void or an @c int. If you want to have * more than one word in typewriter font, then just use @\u0026lt;tt@\u0026gt;. * @param [in] param1 Description of the first parameter of the function. * @param [out] param2 The second one, which follows @p param1, and represents output. //变量 * * @return Describe what the function returns. * @retval XXX_OK if successful. * @see doxygen_theSecondFunction * @see Box_The_Last_One * @see \u0026lt;http://website/\u0026gt; * @note Something to note. * @warning Warning. */ int doxygen_theFirstFunction(int param1, int param2); @param：标记变量 [in] [out]表示输入输出方向 @return：返回值描述 @retval：具体返回值及其含义 @see：link信息 @note：备注信息 @warning：需要函数使用者注意的信息，比如：功能未经完全验证 commit规范 1.示例 2. 提交标题（Subject Line） 动词时态：使用 祈使句（动词原型），描述这次提交所做的工作。比如：\nAdd login feature（添加登录功能） Fix button alignment issue（修复按钮对齐问题） Update README for installation instructions（更新 README，添加安装说明） 3. 常见的提交类型 为了规范化提交标题中的描述，项目或团队会使用特定的前缀来标记提交的类型。这些前缀可以帮助人们快速了解提交的目的。例如：\nfeat：引入新功能（feature）。 feat: add user login functionality fix：修复 bug。 fix: resolve password hashing issue docs：仅更新文档。 docs: update API documentation style：代码风格的调整（不涉及功能或逻辑变化），如格式化、空格调整等。 style: reformat code with prettier refactor：重构代码，通常是改善代码结构，但没有新功能或 bug 修复。 refactor: optimize login function test：添加或修改测试。 test: add tests for user authentication chore：不影响源代码的其他更改，如构建过程、依赖管理等。 chore: update npm dependencies perf：性能优化。 perf: improve database query performance 4.参考资料 具体可以参考这篇文档 如何规范你的Git commit？ - 知乎 (zhihu.com)\n",
    
    "date": "2024-12-24 11:00:00",
    "updated": "2024-12-24 11:00:00"
  }
  
  , 
  {
    "objectID": "1734991800",
    "permalink": "/post/%E7%BD%AE%E8%BA%AB%E4%BA%8B%E5%86%85/",
    "title": "《置身事内》读后记",
    
    "content": " 《置身事内》 本文作为全书内容的大体回顾会更好一些。\n这是一本关于中国政府与经济发展的书，政府不仅参与公共服务，也深刻影响着资源与分配。 先姑且描述一下各个章节的内容：\n第一章讨论的事权划分的三种理论：公共服务的规模经济与边界、信息复杂性、激励相容。 第二章通过对改开初期以来的分税制改革和土地财政的招商税收，初步概述了土地作为杠杆撬动信贷和各类资金的作用，也为政府债务、融投资埋下伏笔。 第三章重点讲述政府投融资与债务，加快的城镇化建设催生城投债与城投公司的兴起，当然土地投资有成功也有失败，引申出地方债的治理与改革。至于为何投资，涉及到官员激励与腐败的方面。本章使用金融财政学的术语较多，阅读起来需要一些耐心。 第四章讲述政府在工业化进程中的角色，书中举了京东方光电显示产业链和光伏发电从成本高用量少的研发阶段到平价市场化的过程来阐释。并介绍了居住土地和工业用地的定价逻辑以及政府引导基金建立的动机历程。 第五章阐述城市化进程中居民贫富差距的不平衡问题。房价房债、按揭贷款、土地流转以及户籍改革在本章被探讨，重视工业生产将转向重居民重民生，这是作者对服务型转向的一些看法。 对“防范化解重大风险”的讨论，第六章探讨中国政府的债务与风险，从四万亿计划到货币化“棚改”等等，本章聚焦于地方政府融资平台和国企、债主银行的债务。债务根源于我国经济发展的模式与结构，在降债务的过程中必然伴随着一系列深层次结构性改革。 我国经济结构最失衡的特点是消费不足。地方政府重生产重投资导致10年初我国制造业的巨大产能对外输出，进而引发贸易冲突。我国居民拥有高储蓄率但收入占比过低，重扩张的优点是能快速扩大投资和对外贸易，利用全球化的契机拉动经济快速增长，尽管缺点是经济结构上失衡。 本书一共讲述了七章，第五章开始讲述了宏观的经济现象。第八章则是对前述的总结，纵横捭阖颇为精彩。采用市场经济的理论研究中国经济，此二者之间的张力为研究分配制度、改革措施以及发展历程提供了良好的入口。不同“假想”、不同“标准”对于完善市场经济各有判断标准，换一套标准的政策制定可能完全不同。哈佛大学经济学家申克龙的话：“一套严格的概念框架无疑有助于理清问题，但也经常让人错把问题当成答案。社会科学总渴望发现一套‘放之四海而皆准’的方法和规律，这种心态需要成熟起来。不要低估经济现实的复杂性，也不要高估科学工具的质量。”\n这里还有一段精彩的论述：\n经济落后的国家之所以落后，正是因为它缺乏发达国家的很多硬件或软件资源，缺乏完善的市场竞争机制。在推进现代化的进程中， 落后国家所采用的组织和动员资源的方式，注定与发达国家不同。落后国家能否赶超，关键在于能否找到一套适合国情的组织和动 用资源的方式，持续不断地推动经济发展。所谓“市场在资源配置中起到决定性作用”，站在今天的角度上看是未来的趋势之一，但 往后看市场的经济状况也是几十年来经济、政府、社会协同发展和建设的结果。 我国曾在二十世纪六七十年代进行过工业体系的分散化，当时是叫做“三线建设”的开展。以一个全国整合工业资源的角度看确实不妥。这种先分散后整合的方式被解释为能够带动地方农民向工人阶级的转变，为二十一世纪工业加速提供了愿意外出闯荡的大量劳动力，也为地方政府“官场+市场”的竞争和属地管理提供了地区经济的推动力。\n常谈道发展中国家各自的发展模式不尽相同，我国发展中各个省的发展路径和发展方式也不尽相同。社会现实决定了经济发展的政策边界。例如工业化城市化的进程，微观而言则是农民到工人的演变问题，落到个人身上是观念的剧变。作者提到我国可行的政策空间和演变路径受三大制度约束：农村集体所有制、城市土地公有制、户籍制度。因而中国的工业化才离不开乡镇企业的发展，离不开“土地财政”和“土地金融”。政策的制定伴随着利益的约束，研究发展过程的经济学还讨论了发展顺序和发展节奏，政策的路径和步骤、激进与否都有利益冲突，这种必然指引着一种“渐进式改革”的兴起：允许拖低效率的资源错配，建立缓冲机制，因为人需要花时间去适应。\n作者认为，经济学的主要作用仍是发现和提出问题，解决问题仍然只能在摸索中产生——这需要权衡取舍、调整改进、需要魄力。发现和提出好的问题是解决问题的第一步，“提问”本身也是一门艺术，切中要害的问题一定是对于现实具有深刻的理解。“具体问题具体分析”的道理是不会过时的精神。\n推荐书目 冯军旗 《中县干部》 周黎安 《转型中的地方政府：官员激励与治理》\n耶鲁大学哥顿《银行的秘密：现代金融生存启示录》\n保尔森《与中国打交道：亲历一个新经济大国的崛起》\n潘功胜《大行蝶变：中国大型商业银行复兴之路》\n哈佛大学 傅高义 《邓小平时代》\n复旦大学历史地理学家葛剑雄《统一与分裂：中国历史的启示》\n复旦大学陈明明、中山大学肖滨《当代中国政府与政治》\n",
    
    "date": "2024-12-23 15:00:00",
    "updated": "2024-12-23 16:00:00"
  }
  
  , 
  {
    "objectID": "1732298400",
    "permalink": "/post/datalab/",
    "title": "Datalab",
    
    "content": " 没得满分是因为在isAsciiDigit中使用了\u0026gt;\u0026gt;违规符号。没有用\u0026gt;\u0026gt;感觉不会写……请求各位大佬对此出谋划策，感谢！\n写在前面 这部分内容参考Arthals\u0026rsquo; ink。 btest：用于测试你的函数是否正确。仅在一个小的测试集上进行测试，不能完全保证你的函数是正确的。\n# 编译并运行 make \u0026amp;\u0026amp; ./btest # 对某个函数进行单元测试 make \u0026amp;\u0026amp; ./btest -f bitXnor # 对某个函数进行单元测试，且指定测试用例，以 -1 指定第一个参数，依次类推 make \u0026amp;\u0026amp; ./btest -f bitXnor -1 7 -2 0xf dlc：用于检查你的代码是否符合规范。\n# 检查是否符合编码规范 ./dlc bits.c driver.pl：用于评分，检查你的函数是否符合规范且正确。\n./driver.pl BitXor int temp = ~(x \u0026amp; y)这一步计算的是 x 和 y 各位同时为1的位置的反，即 temp 中的每个位都代表 x 和 y 对应位不同时为1。换句话说，它标记了 x 和 y 中至少有一个位为0的位置。 int a = ~(x \u0026amp; temp)这里使用 x \u0026amp; temp 获取 x 中与 temp 相应位都为1的位。由于 temp 已经标记了 x 和 y 中不同时为1的位置，x \u0026amp; temp 表示 x 是1且 y 是0的位置。~(x \u0026amp; temp) 则将这些位置置为0，其他位置置为1。 int b = ~(y \u0026amp; temp)类似于上面的 a，这里计算的是 y 中与 temp 相应位都为1的位，即 y 是1而 x 是0的位置。~(y \u0026amp; temp) 将这些位置置为0，其他位置置为1。 return ~(a \u0026amp; b);此步骤中，a \u0026amp; b 会在 x 和 y 中同时为0或同时为1的位上返回1（因为只有这两种情况下，a 和 b 的对应位同时为0，取反后为1）。因此，~(a \u0026amp; b) 将这些位置反转，从而得到 x 和 y 的按位异或结果，即只有当 x 和 y 的某位不同时，该位才为1。 int bitXor(int x, int y) { int temp = ~(x\u0026amp;y); int a = ~(x\u0026amp;temp); int b = ~(y\u0026amp;temp); return ~(a\u0026amp;b); } allOddBits int allOddBits(int x) { int mask0 = 0xAA; int mask1 = mask0 \u0026lt;\u0026lt; 8; int mask2 = mask0 \u0026lt;\u0026lt; 16; int mask3 = mask0 \u0026lt;\u0026lt; 24; int mask = mask0 | mask1 | mask2 | mask3; return !((x\u0026amp;mask)^mask); // ((x|mask)^mask)结果为零的话则说明所有的偶数位均为0 } Tmax answer1 int isTmax(int x) { return !((x+1)^(~x) \u0026amp; ((x+1)\u0026gt;\u0026gt;31)) ; } answer2 当 x 是 Tmax (0x7FFFFFFF):x + 1 会变成 Tmin (0x80000000)，并且 y ^ (~x) 会是0，!!y 会是1，因此返回1。 当 x 不是 Tmax: 如果 x 是其他数，y ^ (~x) 会是非零值，或者 y 为0（针对 x = -1 的情况），结果返回0。\nint isTmax(int x) { //return ( (!((x+1)^(~x))) \u0026amp; ((x+1)\u0026gt;\u0026gt;31) ); int y = x + 1; return !(y ^ (~x)) \u0026amp; !!y; } isMax 我有些违规。。\nint isTmax(int x) { return ( (!((x+1)^(~x))) \u0026amp; ((x+1)\u0026gt;\u0026gt;31) ); //int isTmax(int x) { //int y = x + 1; //return !(y ^ (~x)) \u0026amp; !!y; } } Tmin int tmin(void) { return 1\u0026lt;\u0026lt;31; } negate 返回 -x。这个运用书上的结论就好。。\nint negate(int x) { return ~x+1; } isAsciiDigit 0x30 是 0011 0000，0x39是0011 1001。也就是满足第五位和第六位都是1的前提下，第四位如果是零，则剩下三位怎么取都可以。第四位如果是1，剩下的2、3位只能是0，第1位随意。others是用来检测剩下其它位到底是不是1，因为在make \u0026amp;\u0026amp; ./btest时，对于-1853013669[0x918d415b]出错了。\nint isAsciiDigit(int x) { int others = !(x \u0026gt;\u0026gt; 6); int x6 = (x \u0026amp; 0x30)\u0026gt;\u0026gt;5; int x5 = (x \u0026amp; 0x10)\u0026gt;\u0026gt;4; int x4 = (x \u0026amp; 0x08)\u0026gt;\u0026gt;3; int x23 = !(x \u0026amp; 0x06); //x is \u0026#39;~00~\u0026#39;, then x23 is 1;it\u0026#39;s good. return others \u0026amp; x6 \u0026amp; x5 \u0026amp; ((x4 \u0026amp; x23) | !x4); // 0011 1010 } conditional 本题要求实现same as x ? y : z . Example: conditional(2,4,5) ，使用!!将数映射到{0,1}，如果~x+1的结果全为1的话，使用 \u0026amp;可以保留y的性征，同理z。\nint conditional(int x, int y, int z) { x = !!x; x = ~x+1; return (x \u0026amp; y) | (~x \u0026amp; z) ; } logicalNeg 只有0与它的补码（它自己）的|的最高位为0。\nint logicalNeg(int x) { return !((x | (~x+1)) \u0026gt;\u0026gt; 31); } Floatscale2 通过按位与操作提取符号位、指数位和尾数位：\ns：最高位（第31位）为符号位，决定浮点数是正数还是负数。 exp：指数位（第23到30位），决定浮点数的数量级。 frac：尾数位（第0到22位），决定浮点数的小数部分。 处理非归一化数（exp == 0 的情况） 如果尾数的最高有效位（第22位）为 1，则此时需要将指数加 1，表示进入归一化数状态，同时将尾数左移一位。否则，直接将尾数左移一位，表示乘以 2。 处理归一化数（exp != 0 且 exp != 0x7F800000 的情况）： 正常情况下，指数加 1，表示乘以 2。如果指数加 1 后变为全 1，则表示结果为无穷大，尾数置为 0。 最后没想到是要写!(exp ^ 0x7F800000)，写成!(~(exp \u0026amp; 0x7F800000 ))不行！？ unsigned floatScale2(unsigned uf) { int s = uf \u0026amp; 0x80000000; int exp = uf \u0026amp; 0x7F800000; int frac = uf \u0026amp; 0x007FFFFF; if (exp == 0) { if (frac \u0026amp; 0x00400000) { exp += 0x00800000; frac = (frac\u0026lt;\u0026lt;1) \u0026amp; 0x007FFFFF; } else { frac = frac \u0026lt;\u0026lt;1; } } else if (!(exp ^ 0x7F800000)){ // wu qiong return uf; } else { exp += 0x00800000; //如果 `exp == 0x7F800000`，即指数全为 1，表示无穷大或 NaN，直接返回原数值。 if (exp==0x7F800000){ frac = 0; } return s | exp | frac; // 最后将符号位、指数位、尾数位重新组合为一个无符号整数返回 } floatPower2 unsigned floatPower2(int x) { int exp = x \u0026amp; 0x7F800000; int ret; exp = exp \u0026gt;\u0026gt; 23; if (x\u0026gt;127) return (0xFF\u0026lt;\u0026lt;23); if (x\u0026lt;-149) return 0; if(x \u0026lt; -126) return 0x1 \u0026lt;\u0026lt; (x + 149); exp = x + 127; ret = exp \u0026lt;\u0026lt; 23; return ret; } howMantBits 最具有难度的一个。 (b16 + b8 + b4 + b2 + b1 + x + 1) 正负数都是因为x -\u0026gt; |x| -1 才要补上1的。\nint howManyBits(int x) { int s = x\u0026gt;\u0026gt;31; int b16,b8,b4,b2,b1; x = x ^ s; //calculate right shift 这里无形中是算术右移，s=0xFFFFFFFF //result is x -\u0026gt; |x| -1 b16 = !!(x\u0026gt;\u0026gt;16) \u0026lt;\u0026lt;4;/* 0000 0000 0000 1000 0000 0000 0000 0000 */ x = x \u0026gt;\u0026gt; b16; b8 = !!(x\u0026gt;\u0026gt;8) \u0026lt;\u0026lt; 3; x = x \u0026gt;\u0026gt; b8; b4 = !!(x \u0026gt;\u0026gt; 4) \u0026lt;\u0026lt; 2; x = x \u0026gt;\u0026gt; b4; b2 = !!(x \u0026gt;\u0026gt; 2) \u0026lt;\u0026lt; 1; x = x \u0026gt;\u0026gt; b2; b1 = !!(x \u0026gt;\u0026gt; 1) \u0026lt;\u0026lt; 0; x = x \u0026gt;\u0026gt; b1; return (b16 + b8 + b4 + b2 + b1 + x + 1); } 至此，完成。\n",
    
    "date": "2024-11-22 11:00:00",
    "updated": "2024-12-20 11:00:00"
  }
  
  , 
  {
    "objectID": "1731542400",
    "permalink": "/post/vpn%E6%95%99%E7%A8%8B/",
    "title": "Linux/ubuntu VPN教程",
    
    "content": " Ubuntu 22.04 VPN配置教程 ubuntu版本不同其实差别不是很大。\n步骤一：建立clash文件夹并导入安装包 mkdir clash cd clash 之后在本仓库下载clashpremium-release-linux-amd64.s1lSU-Ho.tar.gz导入到~/clash/路径下，换言之，就是将安装包放置在clash文件夹里面，之后解压该文件，并修改命名为clash\nbash tar -xzvf clashpremium-release-linux-amd64.s1lSU-Ho.tar.gz.tar.gz 步骤二：配置VPN参数文件 wget -O config.yaml \u0026#34;https://cqd4w.no-mad-world.club/link/JMdr9H6ofZOHDvJO?clash=3\u0026#34; 步骤三：执行配置命令实现启动clash和VPN代理 chmod +x clash ./clash -d . 执行效果图如下所示： 步骤四：购买机场提供的稳定VPN,并修改设置网络参数 机场链接IKUUU VPN\n在这个机场里面选择VPN网络包,效果如下图所示 以 Ubuntu 20.04 为例，打开系统设置，选择网络，点击网络代理右边的设置按钮，选择手动，填写 HTTP 和 HTTPS 代理为 127.0.0.1:7890，填写 Socks 主机为 127.0.0.1:7891，即可启用系统代理\n修改图如下所示\n之后点击clash链接clash board\nclash界面如下图所示\n点击确定，之后便可享用VPN了\n最终clash效果图如下所示：\n外网游行\u0026ndash;Youtube展示:\n平日开启VPN的方法 在终端中cd到clash的文件夹下，输入./clash -d .启动clash，启动完之后一般不要使用ctrl+c或ctrl+z打断运行，否则再次输入./clash -d .运行会出现端口占用，如果打断了就只能：\npa aux | grep clash kill -9 [端口号] 在浏览器中打开ikuuu的dashboard，里面可以配置代理和节点。\n",
    
    "date": "2024-11-14 00:00:00",
    "updated": "2024-11-14 00:00:00"
  }
  
  , 
  {
    "objectID": "1725667200",
    "permalink": "/post/sshremotessh/",
    "title": "ssh与remote ssh的使用",
    
    "content": " ssh简介 ssh是一个多义词。\nSSH（Secure Shell，安全外壳）是一种网络安全协议。SSH协议通过对网络数据进行加密和验证，在不安全的网络环境中提供了安全的网络服务。作为Telnet和其他不安全远程shell协议的安全替代方案，目前SSH协议已经被全世界广泛使用，大多数设备都支持SSH功能。关于ssh协议的更多内容\nssh是通过SSH协议提供远程终端(壳shell)访问（远程命令行登入）的计算机服务。其分为客户端与服务端，其中客户端预装在几乎每一台windows与linux上，而服务端需要手动安装，以防止被攻击破解。在客户端登录服务端后，默认情况下，客户端的命令行指令会被发送到服务端，服务端的指令执行结果也会发回客户端，其效果如同直接使用服务端的命令行一样（即远程终端）；通过重定向程序的输入输出流到ssh服务，也可以达到为明文流量加密的作用;ssh的其他应用还包括端口转发，代理等，堪称万能的网络工具。\nJava三大框架。（显然不是这个）\nssh使用入门 在服务器安装ssh服务端 ssh服务由多个软件提供，其中Linux上openSSH是开源免费的，可以通过下列命令直接安装\nsudo apt update sudo apt install openssh-server 上述命令的显示样式在markdown中被称为\u0026quot;代码块\u0026quot;，代码块中的代码会根据注释中指明的计算机语言被高亮与上色。不作说明的情况下，其中的shell命令都需要被执行。\n在官方文档中，每行shell命令的开头往往会加上$，从而将多个命令与对应的输出之间做区分。但是为了方便读者观看与直接复制使用命令，本文档约定命令的输出应当尽量以图片的形式进行展示，因循此例。\n获取服务器ip地址 sudo apt install net-tools ifconfig 观察输出，其中第一项eth0是一个以太网网关，本机地址为172.22.44.10(wsl2的默认地址)，第二项lo是本地环回地址(localhost 127.0.0.1)。通过同样的方法，在其他网络中也可以分辨出你想通过哪一个网络访问该服务器，以及该服务器在网络中的ip地址是什么。\n登入 ssh支持两种最常见的登录方法，一是密码验证，另一种是利用数字签名算法进行身份验证。\n密码验证 在终端(Bash或powershell)输入以下命令\nssh ${UserName}@${IPaddress} ${UserName}与${IPaddress}是Bash中引用变量的方式，在此处分别指代：服务器上想要登录的账户的用户名，服务器地址。比如你需要访问的服务器的ip是172.22.44.10，用户名是rc，那么应该输入ssh rc@172.22.44.10 实际上${IPaddress}的位置还可以填写主机名 如果是第一次登录，成功进入登录验证阶段\n此时输入yes（注意不能是缩写y,Y,(Enter)），会提示输入密码，正确与不正确均有反馈，遵循提示即可\n如果未成功进入登录验证阶段\nip地址/主机名输错，超时\n登录的主机ip地址与之前登录过的不同主机的ip地址恰好相同\n参考解决方案：问题解决——SSH时出现WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!\n秘钥验证 首先生成非对称加密算法的密钥对 ssh-keygen Ubuntu上的输出结果 Windows上的输出结果 接下来会弹出一堆选项，要求你确认一堆东西或者设置密码之类的，为了方便，一直按Enter直到完成设置。\n生成的密钥对会保存为${HOME}/.ssh/${KeyType}（私钥）与${HOME}/.ssh/${KeyType}.pub（公钥），其中公钥用于在分发到别的计算机上，私钥则需要妥善保存。\nUbuntu上的${HOME}是/home/${UserName}，Windows上的${HOME}是C:\\Users\\${UserName},打开相应的文件夹可以看到生成的文件。\n服务端设置 先复制当前电脑的公钥文件${HOME}/.ssh/${KeyType}.pub的内容到剪切板，利用文件资源管理器打开文件夹，然后右键选择以记事本打开。\n然后通过ssh密码登录方式连接上服务端\n创建文件${HOME}/.ssh/authorized_keys，并且将剪切板的内容复制到文件的第一行\n以下命令中的${PubKey}的内容是剪切板上粘贴下来的公钥内容。\n注意，你不能直接使用代码，而是应当将${PubKey}的内容改为自己剪切板上的公钥，然后再使用这一行代码\nmkdir ${HOME}/.ssh PubKey=\u0026#34;ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDWI1RPA1wttlKyW+RhVBv+2rpOy5EnvZOhalihTFuXdwlMujzNyyjDVH9RUm7Ya3fzUFNADgCK3sJhYsEfVBzQqFTmNyklD8AefJaSEFlCpy/u1JWdnSsPClYw7lkzcPTaOFxzYQH1UhKrkC9CCuqZdODRSJKTkVb9WSxdKcfn9Sawbs0dvscvbj7iIkmoNKJZV6XR7yDuJDBDK6EJnnEjmAOwj/n7VF8+hXkGtealmheWfrJDHtliQLgxRBqu4gd3iltVNx8bJkMMI5niziaCmeqpf1JWblXlvAv2gqXzPJezYPuYPpXhP9SNk84fKby6zYbI6AMTniW7T0u0WZTWQn7Ky6iX+AnkAiVAr9E3e90iz6XaVYfLzQ0AMSJbLysK4Cu6KnBFazHXk0bZ5Txy2CdnYSbA3tRCGcyDXuoo+9KaqGcCaUB7yg1wi7m0uHHHNE9fgmvknSS0Is6GzG9f0DSgZjgwUPSutujV6pCgc0Eb9qdKx5H+4PY6H36E9w8= pyh@LAPTOP-FKJURK83\u0026#34; echo $PubKey\u0026gt; ${HOME}/.ssh/authorized_keys 之后每一次登录都无需密码\nVSCode 插件 Remote ssh的使用 安装vscode后，在扩展商店中输入remote development，进行安装\n安装完成后，侧边会出现远程连接的扩展菜单，点击进入扩展后，将其上方的框中选中远程(隧道/ssh)，可以展开所有配置好的远程ssh选项，如图所示。但是由于还没有配置过，所以应该是空的。\n将光标放置在SSH一栏上，会出现符号，如图\n点击设置符号，更改配置文件，选择第一个文件\n文件中的一个配置项的简单示例如下，可以隔一行增加另一个配置项\nHost RC_xjtu HostName 115.154.175.254 User rc Host WSL HostName 172.22.44.10 User pyh 必要字段 解释 Host 指的是会在远程连接菜单中显示的名称（自己取的），比如第一个配置项会生成 HostName 指地址或者是主机名，上文ssh命令中的${HostName} User 指远程连接中的用户名，上文ssh命令中的${UserName} 其他字段可以在ssh配置文件手册中找到具体的含义\n配置完成后，即可通过进行远程连接。\nTips:\n注意，这一步需要命令行ssh能够正常连接的情况下才能成功，如果没有配置公钥，则要求输入密码，弹出来的提示框比较小，并且在连接过程中会弹出多次，注意别看漏了。 如果不小心点到其他地方让输入框消失了，会被认为进行了取消了输入密码的操作，导致远程连接失败，需要再发起一次连接或者点击retry\n远程连接后得到的窗口是一个空的，没有打开任何文件夹的窗口，查看状态栏（VSCode最下面那一条）的最左边标识会显示出当前窗口是一个远程连接窗口。\n在窗口左上角 文件-\u0026gt;打开文件夹，可以选择对应的文件夹进行开发工作。\n\u0026mdash; 这里是结束的分割线 \u0026mdash;\n",
    
    "date": "2024-09-07 00:00:00",
    "updated": "2024-09-07 00:00:00"
  }
  
  , 
  {
    "objectID": "1719180600",
    "permalink": "/post/%E6%96%AF%E5%A4%9A%E8%91%9B%E7%9A%84%E5%85%B7%E8%BA%AB%E6%B2%BB%E7%96%97/",
    "title": "具身治疗：斯多葛派“印象”训练",
    
    "content": " 【摘要】 斯多葛是古希腊思潮中影响深远的流派，其偏重于建立一种唯理基础的伦理学，对个体因“印象”而产生的“激情”采用内心改观，通过哲学训练参与检视“印象”的恰当性，进而达到“不动心”的稳定状态。具体而言，一是通过理性的“赞同”将“印象”隶属于“不动心”范畴中，二是通过冥想、预演对“印象”运用加以归化，然而大多人预演死亡会产生恐惧与焦虑。尽管斯多葛派的修身哲学点明了上达自然的完满状态，但消除激情、上达自然并非仅仅是理想描摹，换言之，斯多葛派略去了具体印象训练的可行性。于此结合“双脑决策”与“恐惧管理理论”对斯多葛“印象”训练可行性进行的尝试与补充，最终为“印象”克制“激情”指明了认知和践履的两条进路。\n【关键词】印象；训练；斯多葛派；具身治疗\n【正文】 一、引言 斯多葛学派是古希腊晚期哲学最著名的哲学派系之一，因其学说与当时社会历史的发展高度契合而得以广泛传播，从御座上威风凛凛的皇帝到作为阶下囚的内敛谦卑的奴隶都是斯多葛学派的拥趸。芝诺、奥勒留、塞涅卡以及爱比克泰德都是斯多葛学派的典型代表。芝诺主张要过一种合乎自然的生活，合乎自然的生活就是一种德性的生活，德性是自然引导我们所趋向的目标。塞涅卡则认为，哲学的目的在于把人引向德性，而德性就是要尊重自然，顺从神意，要按照自然的规范进行生活才能获得真正的幸福。罗马皇帝奥勒留被称为“御座上的哲学家”，在他看来，宇宙万物是一个由神决定其内在秩序的整体，人也是这一整体所统治的一部分，只有顺应这一整体的生活才是值得一过的。爱比克泰德本来是奴隶后来获得自由，他主张一切东西都是神创造的，神就是善，人应该尊从神意、顺从命运不要做与自然不相符合的无谓的挣扎。纵观斯多葛学派的理论，我们不难发现他们都主张存在着一个不为人的主观意志所转移的自然法，这一自然法或自然规则是社会历史发展的决定性力量，个人面对命运的决定性时所作的挣扎都是无用的，唯有“不动心”才能获得真正的幸福，“不动心”才是真正的德性。\n在斯多葛学派的理论中，“理性”和“自然”等概念被多次提及，斯多葛派作将其解释为“逻各斯（logos）”，所谓“逻各斯”就是“主观内化为理性，外在客观为规则，它是神的法律，是自然和人类所共有的法则，具有普遍性和永恒性”，或多或少基于个体命运和动荡的背景因素，斯多葛派将哲学矢的更多放置于哲学实践，通过哲学实践减少个体情绪对理性的冲击进而达到不动心的境界。在斯多葛派的伦理实践中，其强调对灵魂自我修身的哲学训练，具体而言则是聚焦于治疗灵魂冲动的疾病：激情，以保持“不动心”内心境界。在斯多葛学派的哲学实践中对“印象”进行了系统的探讨，他们希望通过“印象”训练达到态度改观并且着重于减少因印象而引发的“激情”冲动，从而获得完满、宁静而愉悦的内心根性。\n至于如何进行“印象”训练，斯多葛学派不同的代表人物提出的看法不尽相同。芝诺主张以理性为本性之人必须克服非理性的激情的观点，克里西普斯道出了更为详细的解释：“灵魂的一种长期疾病是个性的一种稳定状况，这种状况就在于接受一个价值判断，而只要有了这样一个判断，一个人就很容易受到激情的影响。”这里“价值判断”并非认知事物最初的表象呈现，而是带有自我意志的“印象”彰显。进而言之，克里西普斯试图以印象改观的维度入手哲学训练，即通过“注意”并加以理性规范，从而塑造、变动隶属于个体自我的观念。自我观念在斯多葛中的凸显使真正的个体性在自在选择中成为人趋向德性的进路。通过运用这种修身技艺，能够以极大限度的定夺“印象”的范围或者规训“印象”，从而减少激情。例如盗窃外卖行为固然可耻，然而以慨叹其人生活之难处视之，如此何尝不是原先“印象”的温和改观。激情极大关联于“印象”处理，而如此亦是“自我技艺”的训练。斯多葛学派遵循自然理性，试图驾驭激情与冲动的“自我技艺”训练，始于“印象再造”。\n二、印象再造 印象包括各种流变与当下的情感、臆想以及所有回忆，它们都来源于知觉体验。斯多葛学派最著名的代表爱比克泰德对印象认知的瞬间性与自在属性进行了阐释：“人的意识在事物第一次出现时就立即被它所影响，这种表象是不服从人的意志的，也不受人的控制，而只是通过它们自身的力量把自身映入到人们的注意力上。”在爱比克泰德看来，此瞬间发生在主客体相关领域的认识活动，无论是否抛去先天认知形式条件，直观印象均无法为个体控制，因为印象完全来自于物体的“自在精神”，正如康德在《纯粹理性批判》提到的“通过感性一个对象被给予”而为印象，所给予仅仅是经验对象，是未凭借知性范畴的感官直观，仍无法形成知识理念，需要通过“知性对象被思维”，换言之是知性所为“印象再造”。因而流变直观的印象并非属于“由己性”的范畴，是认知主体所无法控制的，而在此时与心灵本性相抵触下产生的感性冲动的消解也绝非易事。\n但在爱比克泰德看来，尽管印象初次出现独立于个体理性的统治部分，但可经内在理性的归化使印象融合于自在意志而具有“由己性”。而以一种易于理解地方式概括爱比克泰德的思想，可称为“印象加工”。个体凭借自身的“赞同”占有了原来之印象，此时印象便服从于人的意志，进而具有了“由己性”，成为克制激情的有效工具。然而“赞同”能力具有两相性，斯多葛认为值得追求的愿景是将印象隶属于“不动心”之下而不是“激情”之下，“不动心”部分的印象是德性对具体技艺要求的应有之义。更进一步，二者限界范畴的框定有赖于宇宙整体的自然法的定夺，即合乎宇宙整体利益的赞同应被纳入“不动心”之下，具体而言则是个体控制范围的定夺：对能控制之物则顺应本性，反之对不可控制之物则依凭自然整体的理性，进而人更应该凭依本性“注意”的是可控制之物的印象。然而理性进行如此驳杂的区分并不容易，无疑是对内在本性向自然理性的上达认知提出了更高要求。\n爱比克泰德认为对于首次出现的表象的“赞同”恰当与否有赖于“把握性概念”的运用程度。类似于伊壁鸠鲁率先提出的“前识概念和感情”，似乎可以解释为先天印象与共有本性的结合，无论是源于理性还是感性。也可借助康德的解释：“一般而言的对象的概念就作为先天条件成为所有经验知识的基础。”因此“先在性”概念能够为认知确立一个明晰的起点。可尽管如此，意识并运用“把握性概念”并不容易，可行的维度是基于自然整体而为的“赞同”训练，凭借来源于理性思考的知识并对此加以演绎推理，排除感性冲动对理性的影响，进而使理性居于支配地位，减少不当的印象，其归根结底便是斯多葛学派在动乱中治疗内心的生存哲学，是退守内心的韧性与忍耐。\n三.印象运用 克利西波斯用一个巧妙的奔跑者比喻解释了“冲动过度”（excess of impluse）：一旦开始阔步前进，便很难停下来。当理性生命在认知刺激下形成印象，那么印象将会推动事物运动。因而首先是持续发挥作用的印象，其次是赞同和思想，再者是决策与运用。一部分事物印象随个体认知活动的进行和接收相近反馈的增加而逐步稳定，另一部分因个体接收的反馈与先前印象拒斥而亟待理性重新“赞同”。印象是完全属于个体的唯一的印象，认知活动是由个体之印象真实地表述的，但是个体未再经思考的、习以为常的印象运用未必合乎哲学训练的要求。爱比克泰德对此巧妙地解释到：尽管包括阿伽门农(Agamemnon)和阿基里斯(Achilles)在内的所有人都对圣洁(holiness)有着相同的“把握性概念”，但他们仍然对“应不应该将克里西斯(Chryseis)送还给她父亲”存在分歧。例如即使他者并没有夺走什么，我们听到医生“身体的有点抱恙”的话语时仍然有些许担心和忧虑。因而印象是个体的把握性印象，治疗印象并非因为印象错误，而是运用途径不得当。如此“印象”扰乱了灵魂的宁静，那么如何让灵魂重归宁静？基于此维度，“自我技艺”的哲学训练便落脚于对印象运用是否得当或正确。\n斯多葛学派认为印象正确运用的可行之路有依赖于后置沉思的有意识调整。他们的理论和现代心理学家与决策理论家丹尼尔·卡内曼（Daniel Kahneman)提出大脑有两个系统的假设相契合：当我们清醒之时，两个系统都处于活跃状态。系统1自主运行，做出几乎不包含自主性的控制决策，依赖情感、经验和感觉直观迅速应激判断，不断为系统2提供印象、直觉和感觉等信息；而系统2通常处于放松状态，运行时只有部分参与，其思考需要调动专注力和理性，因此在重要场合机遇的决策当中，它将耗费更多功夫。正如丹尼尔·卡内曼所言，我们“思考时快时慢”。基于快速思考而使本能性反应支配认知行动，归根到底是直觉感受的当下之物契合了原先存在的已经经过一次或多次“赞同”的“印象”的结果，并且随无意识的“赞同”次数积累，快速思考调用印象愈发得不假思索。爱比克泰德曾在《哲学谈话录》中指出了类似的观点：“习惯是一种强大的力量，我们自己习惯于将我们的欲求和回避指向外部事物时……我们就必须在哪里把我们的训练当成是一种抵消它的力量。”如此看来，对于如何克服习惯自身对思考的偏置，爱比克泰德的确在尽力地运用系统2进行自我“印象”的规训。当然，基于经验直观的快速思考并非应当弃置，正确的印象运用更重要的是适当运用直观与决定的间隔，尤其是自在理性意识到印象正在或将要编织出一幅错误的认知图景之时。反之不恰当地运用印象以及迅速思考让我们受身于不理智的恐惧之中，未再思省的思维活动因冲动而难以克制，继而需要个体不断调动内在理性对已然或未然进行思省与扬弃。\n四.印象训练 （一）冥想沉思 冥想沉思注重于对已然反应的反省，某种意义上斯多葛派确实在尽力进行自我反对。塞涅卡在给卢西留斯的《道德书简》提出：“认识错误是拯救自己的第一步……你要首先当原告，然后作法官，最后才作辩护律师。有时候必须对自己严厉些”，借法庭审判为喻道出沉思并审视记忆中印象的流程范式。尽管斯多葛对于宇宙流变的解释聚焦于“只有把握当下”，但其仍承认记忆的稳定性，因而内心得以审视记忆，进行自我剖析，基于此维度思考特定行为是否是基于快速判断的应激反应（印象运用得当与否）、是否合乎自然整体的利益（自然法的规定）、是否可以上达整体而降低激情的纷扰。尽管生活应当是没有一刻“注意力不存在于其上”的生活，但不久后当激情被理性一旦捕捉时，个体会发现自己正处于怠惰、松懈并且越陷越深——毕竟大多数凭借迅速判断而做出的决策的反馈因为符合自身因先前印象的预演结果而极易被忽视。“各方面都不犯错可能吗？不，在实践上不可能。”但如果可以因此而免去一些错误判断，“我们也会有理由感到满足了。”\n沉思为了更好察觉运用的印象，严格的审视自身必须承载着一种对心灵习惯的“认知”和“注意”，并注重“抽离”表象和审判“印象”的“自我技艺”，最终服从于以德性为最高善好的修身训练。塞涅卡在睡前冥想回顾当天活动，深夜召唤心灵“对自身作交代”，“不对自己隐瞒任何东西，也不忽视任何东西”，并考虑如何在未来做得更好。这样践行冥想有强烈的认知性，包含着恪守与进取，并且要求心灵忙碌地工作。师从爱比克泰德的马可奥勒留每日傍晚在日耳曼战争中的军帐下写下“让你的灵魂中那一指导和支配的部分不受肉体活动的纷扰吧……而是让它限定它自己”。正如马克奥勒留通过冥想总结强化印象浮现的正确与否，斯多葛派承认自我意志能够思考其自身，从而理性将限定理性自身的决策使其逐渐定向化，基于反思的审视约束，通过理性对印象进行训练、规训，以期减少激情的纷扰达到灵魂的宁静，进而达到“不动心”的伦理境界。\n虽然斯多葛与东方宗教都注重内心摆脱焦虑的宁静无忧之自由，但不同于东方式冥想，例如佛教的解脱超度冥想，斯多葛不寻求超脱自我意识而清心寡欲，寻求的是自我审判，是内心深邃罅隙中的和解。塞涅卡主张“养成习惯与持久的注视”，屡次从客观性和整体性解释自身哲学实践是否恰当，如此减少那些近乎自动的反应。斯多葛派的冥想要求全神贯注投入精力而专注，与理性交涉，因此内心将忙碌于上达德性的自我剖析。至于激情的治疗则有关于理性运用，辩证的冥想朝向自我印象的改观，对于你接收了什么，注重或忽略了什么，“先在性”概念对印象的影响程度怎样诸如此类反思，哪怕极细微的改观，只要出更恰当印象的见解，那么对于印象运用便是有了新范式的参照。毕竟斯多葛派的圣哲们作为“进步者”也仍在趋向至上德性的路上。“别要求我应该是最好的，只要求我比最坏的好。如果我每天能减少自己恶行的数量，并且纠正我的错误，这对我来说就足够了。”\n（二）死亡预演 死亡对人类而言是一个永恒的话题，柏拉图在《斐多篇》中曾明确指出“哲学的本质在于训练死亡”。斯多葛派哲学训练落脚于此的逻辑可以归纳为预演：提前想象惧怕之事发生，那么如此已然发生之后又有什么最坏情况将发生。无论个体如何下意识地跳脱，在经过如此反复发问之后，问题都将微妙地围绕于死亡而归结，因而如何预演死亡使“印象”复属于“不动心”之下便是其哲学思想的落脚点之一。\n预演未来可能逆境的训练方法是斯多葛派广为人知的训练方式，通过对未来困境情况进行极不幸的预想，倘若不幸发生则能降低突如其来苦楚的激情纷扰，反之未发生则感谢自然整体分配事件时的眷顾。颇有宿命论意味的是，对于必然到来的死亡，尽管斯多葛派以自然流变的维度叙述了预演结果，即将个体死亡看作对自然整体规律的皈依，符合本性地生活，但在可行性上模糊了进行死亡预演哲学训练的实践维度与普遍意义下关于死亡的“意见”。事实上，倘若将预演注意力集中于负面的认知角度，未然的悲痛定然会以当下的悲痛分摊为代价，正如我们反复琢磨死去时孤单与虚无，却不知内心已被不幸与损失的“激情”牢牢占据。塞涅卡在《致玛姬娅的劝慰书》中承认即使是最决绝的圣人也会深感一阵哀伤，并给予“自然”的悲伤以理解，因为理性动物本能未经赞同的前印象便是苦楚的“痉挛”。\n斯多葛派通过死亡预演而对印象进行的训练类似于现代社会心理学中的“恐惧管理理论”。作为其基本观点基于每个个体对死亡的恐惧而共同创立了文化世界观而进行心理防御，赋予其秩序、价值理念和意义。进而于此的文化价值感赋予人象征性超越死亡的方式与意义，即人的意志主观依附于体系价值的继存一定程度消解了对死亡的恐惧。换言之，个体对主观价值体系下的意义认同分配“管理”了注意力的恐惧认知，即当死亡充斥个体意识时，恐惧使其不自觉抑制如此想法，转而分散注意力。而对于“使人们变得聪明而忧伤”的死亡，与恐惧管理理论相契合，博尔赫斯在《永生》也希望表达一种精神依旧长存于荒诞的毅力。无独有偶，合乎自然整体的精神力量在意识或无意识的斯多葛式预演死亡下也被“注意”，因其能够赋予合乎个体主观追求的价值依存而被斯多葛派珍重，具体体现为其热爱自然、热爱人类、趋向至善的入世哲学思想，这为淡化死亡印象提供了德性引导的可行途径。有着属于自然的共同本性的每个人渺小地属于宇宙整体，生前死后均是组成自然的原子，应当珍视自身存在依德性而择善而行，更需要履行社会联结的公共义务，包括联系邻里、开导他人，更加充分发挥本性的博爱。\n如此斯多葛对死亡印象的预想消解的范式可从注意力分配的价值体系得到解释，在这里“注意力分配”被解释为接收印象的范式，通过主张接收更高层次的价值模式作为意识的依存空间，来克制对威胁印象的不合适接收。对于斯多葛将死亡列入中性之物的价值判断的原因，更确切而言是向宇宙并非个体给予注意，偏重自然整体之价值而哲学训练的结果。而对于判定何者对于“注意”分配合适或不合适、以及何者为中性的原因，斯多葛派“价值三分法”指明了很好的方向，即通过判断该事物是否处于自由意志领域之内以划分是否是中性，进而对于自由意志之内的事物判断善好与败坏。爱比克泰德对此举例道，无论是一个温雅的女人、执政官的职位还是一个孩子的死亡，运用你的准则，其均是自由意志之外、经不起检验的中性之物。尽管斯多葛关于善好理念的价值模式与当下大致相契合，确切而言应当归属于一种“无需理性的纯粹机制”，是一 种没有“理性外衣”的本能呈现，但对我们在情境中所专注的事物之印象预演和暴露训练，从而减少激情是有先见之明的。\n五、总结 上述对激情根源以及如何修正的讨论指明出两条进路：一是对于印象赞同的不恰当，对应“先在性”应作为一切经验知识的前提条件，具有调和经验论与唯理论的色彩；二则是印象使用不妥当而催生激情，对应训练冥想和预演对其纠正以维持心灵宁静自然，进而感知“激情”并在接收直觉与“冲动”预发之间预留后置判断的空间。尽管前者倾向认知论与先验主义，后者更着重自身践履的训练维度，但从时序逻辑观点出发，二者的关联能具有很好的统一性：即外物于人瞬间的“表象”是个体直观在认知领域内受物体“自在精神”的不可控“印象”，唯契合于“不动心”的恰当赞同将印象具化为合乎个体本性的印象，同时自我意识中的印象亦不可冲动地显露，否则激情纷扰灵魂趋向德性的进路。现代心理学理论为依据，如此般的归纳论证了斯多葛学派关于“印象”从感知到赞同进而通过冥想、死亡预演而训练的合理性。当然，斯多葛派的冥想、预演的哲学训练并非怀疑主义对表象“悬置判断”而有意避之，其修身哲学聚焦于内心改观的“自我技艺”，对激情的治疗进行了十分深远的探索与尝试。\n哲学训练作为一种旷日持久的精神操习，被斯多葛派哲学家重视为改变并提升自己的手段。无论是苏格拉底式的辩证法、柏拉图式的文学操练，还是马可·奥勒留在多瑙河畔黄昏的帐下独思，指向的是自我以及存在的提升，一种对具身以及其外延物的恰当处理，从崇高德性出发，面向身体而“修身”，提升到“获致自我意识洞观世界内在平和以及自由的本真‘状态’”斯多葛派之哲学训练在外路与内在中选择了后者，确切而言是内心的印象改观对个体践履的驱动。无论是切换态度以治疗焦虑的方法还是顺应自然的宁静，抑或是与他人和谐联系并以善待，斯多葛伦理学与当代价值体系的社会认同相契合，其以本性体悟整体理性法则的意旨，以整体与部分内在利益一致的驱动中进行的认知改观，为个体从容处世的看法提供凭依；而聚焦内心则是根除激情的“印象”运用，无论是已然冥想或未然预演，斯多葛派的治疗哲学不啻为“逻辑解药”，更是带有逆遇色彩而聚焦于内心完满的温和改观。\n【参考文献】 [1]马克·奥勒留:沉思录[M].北京时代华文书局,2017.\n[2]于江霞:技艺与身体:斯多亚派修身哲学研究，北京：北京大学出版社，2021年.7-15,152,256-263\n[3]（阿）豪·路·博尔赫斯:博尔赫斯小说集[M].王永年、陈泉译.浙江：浙江文艺出版社，2005.p.123\n[4]（美）大卫·菲德勒作；与塞涅卡共进早餐-斯多葛哲学的人生艺术[M].谭新木，王蕾译.上海:上海社会科学院出版社,2022\n[5]（美）丹尼尔·卡尼曼著；思考，快与慢[M].胡晓姣，李爱民，何梦莹译.中信出版集团,2021,8-9\n[6] 章雪富.斯多亚主义的治疗性哲学和自我的观念[J].现代哲学杂志,2009,(2): 85-90，38\n[7]陈群志.阿道与福柯的修身哲学之争[J].世界哲学,2015,(6): 85-92\n[8] 张志伟.康德哲学视野下的心灵与世界 ——兼论《纯粹理性批判》中的经验概念[J].现代哲学,2023,(1): 62-68\n[9] FOUCAUIT M. L’Herméneutique du sujet: Cours au Collège de France (1981 — 1982) [M]. Paris: Seuil/Gallimard, 2001\n[10]奥利金:《论首要原理》(石敏敏译),第三卷第l至2章，道风书社.2002年\n[11]吴欲波，曹欢荣.爱比克泰德论治疗对象与哲学治疗[J].湖北社会科学,2010,(5): 103-106\n[12]（意）马西莫·匹格里奇：哲学的指引：斯多葛哲学的生活知道,崔知名译，北京,北京联合出版公司，2023\n[13] （古罗马）塞涅卡著.哲学的治疗 塞涅卡伦理文选之二[M].吴欲波译，包利民校，北京：中国社会科学出版社,2007\n[14]（古希腊）爱比克泰德著.爱比克泰德论说集[M].北京：商务印书馆,2009\n[15]（古希腊）柏拉图等编；（美）查尔斯·艾略特主编；张春，朱亚兰译.哈佛百年经典：柏拉图对话录：申辩篇、支利同篇、斐多篇爱比克泰德金言录 22卷[M].北京：北京理工大学出版社,2014,67-69\n",
    
    "date": "2024-06-23 15:00:00",
    "updated": "2024-06-25 16:00:00"
  }
  
  , 
  {
    "objectID": "1716502200",
    "permalink": "/post/%E5%81%A5%E5%BA%B7%E7%9A%84%E6%96%AF%E5%A4%9A%E8%91%9B%E4%B8%BB%E4%B9%89/",
    "title": "一种健康的现代斯多葛主义",
    
    "content": " 一次最意外的考验 “骑行者vs.小鹿”——这是护士递给我的医学报告的标题。在我正为这本书写结尾时，我迎来了一场最终的考验，而这恰是我未曾预演的事情。我先生马歇尔那时正在离家不远的岩溪公园（Rock Greek Park）骑车，他碰到了一只拿不定主意该如何过马路的鹿。它起初选择了一个方向，已经快要到达马路的另一边了，但是看到一辆车开过来，它立即转身返回，然后又再次尝试过马路。我先生和那只鹿发生了碰撞。那只鹿毫发无伤地逃走了，而留给我先生的是：七根断了的肋骨、肺萎陷和肩膀脱臼。急诊室医生告诉我，他“遭遇了惨烈的撞击”，我听到这个消息之后一度昏厥。“我们将不得不把他送到华盛顿特区的一家创伤中心。”医生说。\n新型冠状病毒正在我们的城市肆虐。我和先生已经采取了全部的防护措施并且基本上在封锁中度过了5个月的时间，而现在我们要去一家大的城市医院。\n作为一个斯多葛主义者，我此时应该如何思考问题？爱比克泰德在我耳边轻语道：“那只是他的躯体而已。”\n你一定是在开玩笑，我想。他的大脑就在他的躯体中。我有些朋友是当医生的，他们帮我理解了“连枷胸”（flailed chests）、肺炎、肺部功能、神经学问题以及应当在认知的层面上注意什么。他们让我做到的事情是否有认知上的谬误呢？“那真的只是他的躯体吗？”斯托克代尔曾是一名海军飞行员，他在战争中被击落，落入敌军手中，他的腿可能就是在此期间被打伤的，后来成为战俘的他又被敌军折磨了超过7年的时间。他在爱比克泰德那里找到了救命稻草。爱比克泰德是一个曾遭奴役的斯多葛思想家，同样是个瘸子。然而我的先生却不是战俘。最近一直让我忧虑的敌人是一种恶性病毒，我们正在尽最大努力巧妙地跟它斗争。但我没想过他会被一头犹豫不决的鹿撞到。\n“惨烈的撞击”在我脑中反复盘旋。我已经花了整整一周的时间来专门思考罗马奴隶们遭受的残酷殴打和斯多葛式的评论。斯多葛学派看轻身体上的痛苦，这一点众所周知。但因运气不好而遭受的苦难与因他人的非正义行为所遭受的苦难之间的界线也被他们磨平了。如果你是个谨慎并且负责的骑行者，那么被鹿撞到是源于运气不好，然而被当成奴隶严刑拷打就是源于非正义的行为。\n塞内卡抨击了施加在罗马奴隶身上的残酷行为。但是这更多的是一种利己性的考量而不是为人性所做的辩护：被奴役者可能背叛奴役他的人；让奴隶们感到感激总比让他们感到害怕要好；对他们施以恩惠，他们也许会以恩惠回报，比如代你赴死：“假设我告诉你，有人不顾自己的安危也要保护主人，伤痕累累，抛头颅洒热血，以自己的生命为代价为他的主人争取逃脱的时间。”\n这里所说的道德上的教益在于，被奴役之人也能表达仁慈。而这一点在政治上为塞内卡的目标受众（即精英阶层）带来的教益则在于，当你想鞭打仆人时，对你盛怒的情绪加以控制是有好处的。而肉体、肉体的完整性和肉体痛苦，还有人以及他因其人性而应得的尊重，都不在这些道德和政治上的教益范围中。\n斯多葛学派教导我们，我们都为外在的权力所奴役。但他们也教导我们，我们中的有些人却比别人拥有更多的世俗权力。道德是一回事，而合法性和社会现实则是另外一回事。斯多葛学派从来都不挑战奴役制度。\n这也就为我们将要做出的最后思考奠定了基础。我们要如何在古希腊和古罗马文化的基础上建立起一种健康的现代斯多葛主义呢？在当下的“取消主义文化”盛行以及对前代典范全盘推翻的背景下，为什么还要与那些不仅纵容奴隶制，而且还将内在自由赞美为最神圣的解放的古代哲学家为伍呢？\n犬儒者第欧根尼是斯多葛主义极具代表性的人物，他穿着异性的服装，在公众面前炫耀自己的身体部位，他还排斥婚姻，认为这只是一种习俗，但不论他在多大程度上与传统习俗相背离，他都没有反对过奴役的传统，即使他自己就是个奴隶。他在追求一种别样的自由与掌控。因此，他在拍卖台上指着人群中的一个科林斯人厚着脸皮打趣道：“快把我卖给这个人吧，他需要一个主人。”\n内在的主宰才是真正的解放。最负盛名的被奴役的斯多葛思想家爱比克泰德成了一位受过良好教育的老师，他的追随者不计其数，其中还包括一位君主。但他从来没有抨击过奴隶制度。如果说鞭打被奴役者会在道德上遭到反对，那么罪恶在于当权者的堕落，而不在于遭鞭打之人的堕落 。同样地，他的老师穆索尼乌斯·鲁弗斯教导道，奸夫与女性奴隶通奸，他真正的罪恶在于意志薄弱，而不在于任何对待女性的不正义行为。 奴隶的真正力量在于其面对命运和苦难时所具有的精神独立性。不对欲望进行强有力的控制是一种罪恶，不论我们谈及的是男性与被奴役的女性厮混，还是女性与被奴役的男性厮混。这里当然存在性别平等的观念，但真正的罪恶，即那种意志上的薄弱，在男人那里更为严重。\n奴役是普遍存在的：我们都被命运和身体的欲望紧紧掌控。自由同样是普遍存在的：我们都享有人性和理性。与亚里士多德的看法相反，斯多葛学派认为，奴役没有任何自然基础，这样的观点简直已是老生常谈了 。我们身处一个拥有共同来源和共同命运的共同体中。\n事情可能确实如此。但是精神上的平等并不意味着日复一日的社会现实境遇上的平等 。塞内卡一生中的大多数时间都生活在富足中。他家中的佣人、随从的数量简直让唐顿庄园都逊色几分。斯多葛学派把获得力量的希望寄托在共同体和对他人的信赖上。但在实践中，这种信赖并不总是可靠的。爱比克泰德训诫道，你的身体“就像一头因背着它自己的驮鞍和缰绳而负载过重的可怜驴子” 。身体是一具会“被迫投入公共服务中”的工具。“不要反抗或者抱怨，否则你就输了。”这就是这场交易在被奴役者身上的体现。\n既然我们在这一课中要为之前的课程作结，我之前还没有表明立场，那么我在此阐述。我的教学和写作都与古典及现代伦理学相关。我对那些文本充满喜爱，我仔细研读它们，与它们辩论，我还要求我的学生对其进行认真的阅读并且努力与它们辩论。我并不是一个严格的斯多葛主义者（不论它对现代人而言意味着什么），也不是一个斯多葛文本的阐释者。我把自己摆在一个好奇又好学的新斯多葛派立场上，捕捉古代斯多葛主义中的精华和现代斯多葛主义中有价值的教益。\n关于构建一种健康的现代斯多葛主义，我已含蓄地采用了一些原则作为背景性的指引：\n1.心理层面的掌控不能以牺牲人类的脆弱性为代价。\n2.对他人的依赖有赖于互相合作、彼此尊重、互相支持的共同体的建立。\n3.否定身体或心灵的痛苦，并不是面对磨难时永恒的解决方案。\n4.要对迅速产生的感觉印象进行密切的注视，包括由恐惧、愤怒和欲望造成的扭曲和偏见。\n对这些原则，我已经展示了我是如何在斯多葛主义的文本中为之找到立足点的——有些与情感的多个层次有关，有的与同理心以及全球人类的连接性有关，有的还与心理和道德上的困扰以及同情在心理创伤治愈中发挥的作用有关，还有的与注意力发挥的作用有关。我对那些文本向来充满敬意。但我同样努力让这些文本开口对我们说话，也让我们对它们说话，对之提出质疑，思考新的实践。\n但我们仍然没能对斯多葛学派关于奴役制度的看法做出合适的清算。在这样一个我们要对自己的奴役史进行清算的时代，在“黑人的命也是命”的时代里，我们应该如何评估现代斯多葛主义呢？\n我们要关注塞内卡的看法，尤其要关注《书信集》里的第47封信。尽管有些现代学者曾把其中塞内卡的观点视为当代人文主义思想的古代根据 ，且认为其具有启蒙特征，但现在人们普遍认为事情恰恰相反。塞内卡“为以仁慈的方式对待那些被奴役者提出了强有力的辩护”，但这更多的是出于自身的利益而非社会良知。奴役制度对罗马上层人士而言十分重要。作为尼禄的御用顾问，塞内卡所强调的完全就是“对现状的接受”。\n“‘他们是奴隶。’不，他们是人。” 所以在与卢基里乌斯（Lucilius）的通信里，塞内卡在开篇就与他讲起应该如何对待他家中被奴役的佣人。他接着立刻就像连珠炮一样对自己的密友说：\n“他们是奴隶。”\n“不，他们是你的室友。”\n“他们是奴隶。”\n“不，他们是出身卑微的友人。”\n而接下来的这一个回合就传递了关键的道德教导：\n“他们是奴隶。”\n“他们是跟你一样的奴隶，尤其是如果你还没忘记你的命运和他们的命运都同样由老天爷说了算。 ……你们是由同样的种子长成的。 ……灾祸能使那些‘出身上流的贵族们’低贱。同等的运气和人性使你们成为平等的人。”\n然而，正如亚里士多德所说，那些出身上流的贵族雇用奴隶，而被奴役者却是工具，即便是在斯多葛主义那里，也只是任凭习俗和机遇支配的奴隶 。那这些工具被用来做什么呢？他们擦净宴会上的唾沫和呕吐物，切开饭桌上的珍禽，在公共场合给别人端茶送水，但在私下却要满足别人的淫欲——“因为他只在聚会上是个男孩，在卧室里他是个男人”。 他了解那些上流人士的品位，哪些食物“能让他喜笑开颜”，哪些会让他“恶心想吐”，哪些食物他“十分渴望”“哪些食物让他开心”；知道他喜欢跟谁一块儿用餐，知道谁“配不上他高贵的地位”。这种从权力的侧面切入、分门别类写好的详尽知识体系是为贵族群体而建立的，而他们则要依赖被奴役的劳动者们。\n塞内卡为仆人订立的在家务中应承担的职能简直数不胜数：“厨子、面包师、按摩师、洗浴服务员、私人训练师、管家（大管事）。” 他的家务如此铺张，此外还会额外雇用美发师、客座发言人、贴身男仆、女招待、勤杂工和迎宾员、垃圾搬运工，以及那些管束病人和疯子的人。从早晨醒来一直到夜晚沉思的时光，都要依赖奴隶的帮助，需要他们帮忙处理贵族化日常生活中的诸多事务——在屋里满足主人所有心血来潮的奇想和需要，在屋外打理花园和土地。“从根本上讲，奴隶的出逃对主人来说是一种困扰……奴隶主们的财产在这方面所遭受的损失从来都不轻。” 这毫不奇怪。失去一名奴隶对家庭的生活方式和家政状况都会造成重大破坏。\n塞内卡也许会在夜晚沉思该如何克制自己对家庭侍从的愤怒，这是因为，在他那个社会，鞭打一个在晚饭时间发出了太多噪声或是打扰了正在整理家庭账务的地主（或者说得更直接些，正如他自己所叙述的那样，“当灯光熄灭，连我的妻子也不再言语”）的奴隶一点儿也不奇怪。在就寝或清晨时通过沉思来预演管制措施，也许意味着这个奴隶不会逃跑，也不会在严酷的审讯下袭击你。\n这就是塞内卡的境遇中以人道的方式对待奴隶所基于的社会基础，这也是对传统习俗做出的调整。而道德上的要求则更为崇高——就此而言，人人都在被奴役着。“告诉我谁能幸免于此！有的人被性欲奴役，有的人被贪婪奴役，还有的人被野心奴役——他们都是欲望的奴隶、恐惧的奴隶。”\n奴役是一种精神状态，在这种意义上人人皆是如此。所以不要认为“朋友只能在集会场所或是议院的大厅里才能交到”。你的后院中和家务事里也有朋友。一个人的“衣着”或是“生活中的地位”与他们真正的自由毫不相关， 应该自由的是精神。\n这既是斯多葛主义具有吸引力的一面，也是其有害的一面。我在整本书中自始至终都在努力将现代斯多葛主义往外在的方向引导——将它所承诺的在世性、连接性和人人共享的理性和人性都呈现出来。我也拓宽了意志和注意力的角度，以使人们能对在更广的范围内影响幸福的感觉印象加以关注。这就是斯多葛主义所做出的全数承诺及其所继承的苏格拉底式遗产：要针对看到的世界中的好事和坏事反复地审视和考察自身。对斯多葛学派而言，“虚假”的好事和坏事都与外部事物或中立之物有关，而它们与理性真正的善以及理性在德性上的完善都没有关系。\n斯多葛学派从来不认为理性对外部资源来说是中立的。恰恰相反，智慧就是在大多数情形中都能选择或偏向与自然相合的善。我们偏好健康胜过疾病，偏好充足的物质条件胜过贫困，偏好善良的孩子和朋友胜过邪恶的人，这都是我们选择的。我们的这些偏好以及在错综复杂的行动世界中表现它们的方式，就是美德的具体体现。理性和理性的卓越与完善是真正的善，因为它们对我们的共同幸福而言是绝对必要的。显然，我们无法控制事情的所有结果，但是我们可以培育理性、求知欲、对真理的敬重，以及相信每个人都配享有足够的资源来对理性进行培育的信念。这是一颗斯多葛主义的种子，尽管它没有在他们那个时代生根发芽。\n所以，对于构建一种现代斯多葛主义而言，斯多葛主义是否能应对得了这一挑战呢？\n身处欧洲理性启蒙传统中的康德开启了这项工作。他发展了人人享有的理性的概念，而这也构成了作为人而非上帝、自然或宇宙的我们，为自身确立道德法则的基础。理性约束着我们，它也是普遍存在的道德责任和义务的根源，同时使责任和义务不因一时便利或私利而被取消。康德系统地构建起了人性的原则，以防止将人仅仅视为被明码标价以达成目的的工具，尽管他的学说比塞内卡的晚了近2000年，却绝不仅仅只是为人类的解放给出了一种理论模型 。\n文本和语境 所以我们该如何对待有些观点存在道德问题的文本呢？要不要删掉？要不要不教授这些内容，或者更极端些，将该作者的全部作品都放弃？或者像斯多葛哲学家们那样，基于自身判断和灵活性来应对这些挑战？我选择后者。在这些情况中，我们面临的挑战在于理解我们并不身处其中的时代和受历史架构影响（有时甚至是深受其影响）的观念。\n即使哲学伪装成超越历史的模样，但它向来都不与历史相割裂。即使某种哲学观点是“无中生有的”，它也是由有血有肉的人，基于特定的基础，被其所在的文化、实践和前辈们影响，又经常以对它们做出回应的方式得出的。\n哲学以论辩之术为傲，但做哲学却绝不仅仅意味着单纯进行论辩。哲学是一种将追随者、忠实支持者和门徒们聚集起来的学科，就像在雅典、在绘有湿壁画柱廊的沉静气氛中，或是在吕克昂的健身场里，抑或是在学园里的人所做的那样。\n但罗马斯多葛派思想家们比起亚里士多德和柏拉图，甚或那些在柱廊里进行集会的古希腊斯多葛哲学家们，仍然是一类不同的哲学家。他们不但论辩，还布道和说教，这也部分地解释了他们在历史上经久不衰的吸引力，这些都是斯多葛思想声势浩大的复兴背后的原因。斯多葛哲学可以是一种世俗宗教，也可以是一种专注于美德和道德进步而不进行宗教建设之积累的精神实践。\n从历史的角度来说，斯多葛派所带来的影响明显地以其他方式表现了出来。早期的犹太教和基督教思想家从异教思想中吸收了一些观念，这也就解释了为什么很多人仍对斯多葛主义感到十分熟悉。斯多葛学派主张控制情绪和重振意志，以此对诱惑和突然的冲动或感觉印象保持警惕，这些都吸引着早期的西方宗教思想家。他们用斯多葛主义来诠释宗教文本并引导道德进步。\n斯多葛主义就其自身而言，开启的是践行沉思的传统，而非表达崇拜的传统。斯多葛式的沉思不是东方实践中常见的那种让忙乱的心灵安静下来的方法，它最终致力于帮助人们在对日常生活中大大小小挑战的处理中寻求平静。它训练的是审慎而非畏惧，从某种程度上讲，审慎并不会使人迷失。\n向前之路 我们生活在一个焦虑的时代。我们的政治观念遭到颠覆，民主制度遭遇威胁，对疾病的掌控力也遭遇考验。经济、社会和健康中的不平等将奴役之罪恶和美国的黑人歧视传统揭露了出来。道德愤慨普遍存在，失业率达到了自大萧条以来的最高水平，这一切都让人难以看清前路。我们需要领导者，需要教育，需要科学，需要更大程度的平等。\n斯多葛哲学家们无法帮我们解决所有这些问题，但他们能在有些困境中给予我们慰藉——关于死亡的教导、面对恐惧的生活技巧、对那些不由自主的情绪进行管理的方法、准备好应对突如其来的变故的更好办法、能支撑坚韧品质的人际关联感，还有仁慈与感恩在我们生命中的重要性。塞内卡提倡培育人性，但这仍然是一项未竟的事业。我们不仅要对灵魂进行修补，也要对社会进行修补。“有些东西取决于我们，而有些则并非如此。” 问题的关键并不在于什么事情发生在了你的身上，而在于你做何反应。这些都是我们所熟知的爱比克泰德给出的教导。然而我们却无法接受爱比克泰德遭受奴役的历史事实，并以此为自己的退却做辩护。从我们当下的身份、所处的时代以及我们所面临的政治挑战来看，退却就是懦弱的表现。我们必须在那些无法接受的事情上做出改变。而我们要改变它就必然不仅要改变我们自身，也要改变将我们这个集体建构起来的制度以及社会结构。这是一项社会性的事业，需要社会大众的决心，也需要对共同人性的信念。这就是奥勒留在战场上目睹破碎的人体部位四处散落之时心中所想之事。他对自己写道，如果你让自己脱离了共同体和共同体的整体福祉，那这就是后果。你会使自己成为被放逐于人类群体之外的“流浪者”。\n斯多葛学派还就价值观的崩塌——虚假的荣誉、贪婪、过分唯物质论提出了警告。塞内卡还对极力要求下属忠诚的暴君提出了警告。他了解那些为宫中谋杀进行掩饰的演讲稿撰写者们。为了让忧心忡忡的民众冷静下来，他们书写仁慈，声称对对方的谋杀是终点而非更多杀戮的起点。塞内卡就是这样的一个演讲稿撰写者，他的双手也不干净。他的哲学作品充满了权力与害怕失去权力之间、忠诚及其代价之间、富裕与节制之间的张力。在某种程度上，他的写作是在祈求救赎。他为寻求自由而写作。\n斯多葛主义是一种在面对威胁生存的严酷的外部制约时，延续和培养内在美德的方法。这是一种适合当时那个时代的哲学，让人感觉它就是为那个时代而生的哲学。然而我们是现代人，我们要从古人那里学习的还有很多，但也有一些错误是我们要避免的。斯多葛式的训练、坚韧、美德以及理性与合理性之间的纽带都能使我们团结起来，应对个人的和集体的挑战。但这只有当理性的血管中流动着同理之心和仁慈之情的血液时才能实现。这就是那条向前之路，那条健康的现代斯多葛之路。\n",
    
    "date": "2024-05-23 15:00:00",
    "updated": "2024-05-25 16:00:00"
  }
  
]