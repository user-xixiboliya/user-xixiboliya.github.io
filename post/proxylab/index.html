<!doctype html><html lang=en-us data-theme-mode=auto><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>CMU Proxylab | Bertsin
</title><meta name=description content="CMU深入理解计算机系统的proxylab，搭建预线程化的并发代理服务器，配有cache。"><script>window.siteConfig=JSON.parse('{"anchor_icon":null,"clipboard":{"copyright":{"content":"本文版权：本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处！","count":50,"enable":false},"fail":"复制失败 (ﾟ⊿ﾟ)ﾂ","success":"复制成功(*^▽^*)"},"code_block":{"expand":true},"icon_font":"4552607_tq6stt6tcg","outdate":{"daysago":180,"enable":false,"message":"本文最后更新于 {time}，请注意文中内容可能已经发生变化。"}}')</script><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=preload as=style href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7cNoto%20Serif%20SC:400,400italic,700,700italic%7c&amp;display=swap"><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7cNoto%20Serif%20SC:400,400italic,700,700italic%7c&amp;display=swap" media=print onload='this.media="all"'><link rel=preload href=//at.alicdn.com/t/c/font_4552607_tq6stt6tcg.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=stylesheet href=/css/loader.min.2ad0e9bbffb534e893c0ecefc44787a277cf851387e8ad9dccfbc3a5f0886dbe.css><meta property="og:type" content="website"><meta property="og:title" content="CMU Proxylab | Bertsin"><meta property="og:description" content="CMU深入理解计算机系统的proxylab，搭建预线程化的并发代理服务器，配有cache。"><meta property="og:url" content="https://user-xixiboliya.github.io/post/proxylab/"><meta property="og:site_name" content="Welcome to Bertsin Homepage!"><meta property="og:image" content="/"><meta property="article:author" content="Bertsin"><meta property="article:published_time" content="2025-01-25T15:00:00-07:18"><meta property="article:modified_time" content="2025-03-16T16:00:00-07:23"><meta name=twitter:card content="summary"><meta name=twitter:image content="/"><link rel="shortcut icon" href=/favicon.ico><link rel=stylesheet href=/css/main.min.a23591d00af1734c216ea77b270e5fab60a4f92b6498af06e6b0dde48f7c49c0.css><link rel=preload as=style href=https://npm.webcache.cn/photoswipe@5.4.4/dist/photoswipe.css onload='this.onload=null,this.rel="stylesheet"'><link rel=preload as=style href=https://npm.webcache.cn/katex@0.16.9/dist/katex.min.css onload='this.onload=null,this.rel="stylesheet"'><script src=https://npm.webcache.cn/pace-js@1.2.4/pace.min.js integrity=sha384-k6YtvFUEIuEFBdrLKJ3YAUbBki333tj1CSUisai5Cswsg9wcLNaPzsTHDswp4Az8 crossorigin=anonymous></script><link rel=stylesheet href=https://npm.webcache.cn/@reimujs/aos@0.1.0/dist/aos.css></head><body><div id=loader><div class="loading-left-bg loading-bg"></div><div class="loading-right-bg loading-bg"></div><div class=spinner-box><div class=loading-taichi><svg width="150" height="150" viewBox="0 0 1024 1024" class="icon" shape-rendering="geometricPrecision"><path d="M303.5 432a80 80 0 01-12 160 80 80 0 0112-160z" fill="#ff5252"/><path d="M512 65a447 447 0 010 894V929a417 417 0 000-834 417 417 0 000 834v30a447 447 0 010-894zm0 30A417 417 0 01929 512 208.5 208.5.0 01720.5 720.5V592a80 80 0 000-160 80 80 0 000 160V720.5A208.5 208.5.0 01512 512 208.5 208.5.0 00303.5 303.5 208.5 208.5.0 0095 512 417 417 0 01512 95z" fill="#ff5252"/></svg></div><div class=loading-word>少女祈祷中...</div></div></div></div><script>var time=null,startLoading=()=>{time=Date.now(),document.getElementById("loader").classList.remove("loading")},endLoading=()=>{time?Date.now()-time>500?(time=null,document.body.style.overflow="auto",document.getElementById("loader").classList.add("loading")):(setTimeout(endLoading,500-(Date.now()-time)),time=null):(document.body.style.overflow="auto",document.getElementById("loader").classList.add("loading"))};window.addEventListener("DOMContentLoaded",endLoading),document.getElementById("loader").addEventListener("click",endLoading)</script><div id=copy-tooltip style="pointer-events:none;opacity:0;transition:all .2s ease;position:fixed;top:50%;left:50%;z-index:999;transform:translate(-50%,-50%);color:#fff;background:rgba(0,0,0,.5);padding:10px 15px;border-radius:10px"></div><div id=container><div id=wrap><div id=header-nav><nav id=main-nav><span class=main-nav-link-wrap><div class='main-nav-icon icon rotate'>&#xe62b;</div><a class=main-nav-link href=/>Home</a>
</span><span class=main-nav-link-wrap><div class='main-nav-icon icon'>&#xe633;</div><a class=main-nav-link href=/archives>Archives</a>
</span><span class=main-nav-link-wrap><div class='main-nav-icon icon'>&#xe63d;</div><a class=main-nav-link href=/about>About</a>
</span><span class=main-nav-link-wrap><div class='main-nav-icon icon'>&#xe639;</div><a class=main-nav-link href=/friend>Friend</a>
</span><a id=main-nav-toggle class=nav-icon></a></nav><nav id=sub-nav><a id=nav-search-btn class="nav-icon popup-trigger" title=Search></a></nav></div><header id=header><picture></picture>
<img fetchpriority=high src=/images/liyue-default.png alt="CMU Proxylab"><div id=header-outer><div id=header-title><a href=/ id=logo><h1 data-aos=slide-up>CMU Proxylab</h1></a><h2 id=subtitle-wrap data-aos=slide-down></h2></div></div></header><div id=content class=sidebar-right><aside id=sidebar><div class="sidebar-wrapper wrap-sticky"><div class=sidebar-wrap data-aos=fade-up><div class=sidebar-toc-sidebar><div class=sidebar-toc><h3 class=toc-title>Contents</h3><div class="sidebar-toc-wrapper toc-div-class"><nav id=TableOfContents><ul><li><a href=#环境配置>环境配置</a></li></ul><ul><li><a href=#web-proxy的实验任务1>web proxy的实验任务1</a><ul><li><a href=#解析url>解析url</a></li><li><a href=#构建请求头>构建请求头</a></li><li><a href=#do-it-方法>do it 方法</a></li><li><a href=#do-get方法>do get方法</a></li><li><a href=#basic结果>Basic结果</a></li></ul></li></ul><ul><li><a href=#并发>并发</a><ul><li><a href=#main>main</a></li><li><a href=#thread>thread</a></li></ul></li><li><a href=#缓存>缓存</a></li><li><a href=#修改makefile>修改makefile</a></li><li><a href=#result>Result</a></li></ul></nav></div></div></div><div class="sidebar-common-sidebar hidden"><div class=sidebar-author><img data-src=/avatar/avatar.webp data-sizes=auto alt=Bertsin class=lazyload><div class=sidebar-author-name>Bertsin</div><div class=sidebar-description>祈祷中...</div></div><div class=sidebar-state><div class=sidebar-state-article><div>Posts</div><div class=sidebar-state-number>24</div></div><div class=sidebar-state-category><div>Categories</div><div class=sidebar-state-number>8</div></div><div class=sidebar-state-tag><div>Tags</div><div class=sidebar-state-number>1</div></div></div><div class=sidebar-social><div class="icon-bilibili sidebar-social-icon"><a href="https://space.bilibili.com/651491932?spm_id_from=333.1007.0.0" itemprop=url target=_blank aria-label=bilibili rel="noopener external nofollow noreferrer"></a></div><div class="icon-email sidebar-social-icon"><a href=linboxi123@163.com itemprop=url target=_blank aria-label=email rel="noopener external nofollow noreferrer"></a></div><div class="icon-github sidebar-social-icon"><a href=https://github.com/user-xixiboliya itemprop=url target=_blank aria-label=github rel="noopener external nofollow noreferrer"></a></div><div class="icon-zhihu sidebar-social-icon"><a href=https://www.zhihu.com/people/lllll-19-64-21 itemprop=url target=_blank aria-label=zhihu rel="noopener external nofollow noreferrer"></a></div></div><div class=sidebar-menu><div class=sidebar-menu-link-wrap><a class=sidebar-menu-link-dummy href=/ aria-label=Home></a><div class='sidebar-menu-icon icon rotate'>&#xe62b;</div><div class=sidebar-menu-link>Home</div></div><div class=sidebar-menu-link-wrap><a class=sidebar-menu-link-dummy href=/archives aria-label=Archives></a><div class='sidebar-menu-icon icon'>&#xe633;</div><div class=sidebar-menu-link>Archives</div></div><div class=sidebar-menu-link-wrap><a class=sidebar-menu-link-dummy href=/about aria-label=About></a><div class='sidebar-menu-icon icon'>&#xe63d;</div><div class=sidebar-menu-link>About</div></div><div class=sidebar-menu-link-wrap><a class=sidebar-menu-link-dummy href=/friend aria-label=Friend></a><div class='sidebar-menu-icon icon'>&#xe639;</div><div class=sidebar-menu-link>Friend</div></div></div></div><div class=sidebar-btn-wrapper style=position:static><div class="sidebar-toc-btn current"></div><div class=sidebar-common-btn></div></div></div></div><div class=sidebar-widget></div></aside><section id=main><article class="h-entry article" itemprop=blogPost itemscope itemtype=https://schema.org/BlogPosting><div class=article-inner data-aos=fade-up><div class=article-meta><div class=article-date><span class=article-date-link data-aos=zoom-in><time datetime="2025-01-25 15:00:00 -0718 -0718" itemprop=datePublished>2025-01-25</time>
<time style=display:none id=post-update-time>2025-03-16</time></span></div><div class=article-category><a class=article-category-link href=/categories/technology data-aos=zoom-in>TECHNOLOGY</a></div></div><div class=hr-line></div><div class="e-content article-entry" itemprop=articleBody><p>本文的所有配置、指令均以 Ubuntu 环境为例，而且假设你不具有桌面环境，只有纯命令行环境。</p><h1 id=pre-start><a class=header-anchor href=#pre-start></a>Pre-start</h1><p>在工作目录下解压<code>proxylab - handout.tar</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>tar -xvf proxylab-handout.tar  
</span></span></code></pre></div><ul><li><code>-x</code>：表示提取文件，也就是解压操作。</li><li><code>-v</code>：用于显示详细的解压过程，方便你了解解压的进度和具体文件。</li><li><code>-f</code>：指定要处理的文件名，后面紧跟要解压的 <code>.tar</code> 文件的名称。</li></ul><p>以下是简要介绍，本文的根工作空间是<code>proxylab-handout</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>proxylab-handout
</span></span><span style=display:flex><span>├── Makefile
</span></span><span style=display:flex><span>├── README
</span></span><span style=display:flex><span>├── csapp.c
</span></span><span style=display:flex><span>|—— cache.c  //自行编写的cache
</span></span><span style=display:flex><span>|—— cache.h  //自行编写的chche
</span></span><span style=display:flex><span>|—— proxy.h
</span></span><span style=display:flex><span>├── csapp.h
</span></span><span style=display:flex><span>├── driver.sh   //简单自动评分程序。进行基本的合理性检查。
</span></span><span style=display:flex><span>├── free-port.sh
</span></span><span style=display:flex><span>├── nop-server.py
</span></span><span style=display:flex><span>├── port-for-user.pl  //给出偶数端口号，以便和Tiny web server 进行 testing。
</span></span><span style=display:flex><span>├── proxy.c  //打印出一个特定的 HTTP <span style=color:#e6db74>`</span>User-Agent<span style=color:#e6db74>`</span> 头部信息到标准输出。用于标识客户端软件的类型和版本，服务器可以根据这个信息来提供不同的服务或内容。
</span></span><span style=display:flex><span>└── tiny  //tiny服务器
</span></span></code></pre></div><h2 id=环境配置><a class=header-anchor href=#%e7%8e%af%e5%a2%83%e9%85%8d%e7%bd%ae></a>环境配置</h2><p>配置linux 版本的chrome 和 chrome driver 。两者版本需对应，还有自动化测试工具Selenium，参考[Arthals&rsquo;ink环境配置](<a href=https://arthals.ink/blog/proxy-lab#%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE>更适合北大宝宝体质的 Proxy Lab 踩坑记 • Arthals&rsquo; ink</a>)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb
</span></span><span style=display:flex><span>sudo dpkg -i google-chrome-stable_current_amd64.deb
</span></span><span style=display:flex><span>rm google-chrome-stable_current_amd64.deb
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>wget https://edgedl.me.gvt1.com/edgedl/chrome/chrome-for-testing/&lt;your chrome corresponse verison&gt;/linux64/chromedriver-linux64.zip
</span></span><span style=display:flex><span>unzip chromedriver-linux64.zip
</span></span><span style=display:flex><span>rm chromedriver-linux64.zip
</span></span><span style=display:flex><span>sudo mv chromedriver /usr/local/bin/    <span style=color:#75715e>#（即默认环境变量 `$PATH` 检索的位置）下，这样就可以在任意目录下使用 `chromedriver` 命令用以启动驱动。</span>
</span></span><span style=display:flex><span>sudo apt install net-tools
</span></span><span style=display:flex><span>pip3 install selenium
</span></span></code></pre></div><p>开启<code>tiny</code>服务器，在当前shell中：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>cd tiny <span style=color:#f92672>&amp;&amp;</span> make clean <span style=color:#f92672>&amp;&amp;</span> make &amp; ./tiny <span style=color:#ae81ff>7778</span> &amp; cd ..
</span></span><span style=display:flex><span>jobs   如果删去的话：kill %1 
</span></span><span style=display:flex><span>cd proxylab-handout
</span></span><span style=display:flex><span>make clean <span style=color:#f92672>&amp;&amp;</span> make <span style=color:#f92672>&amp;&amp;</span> ./proxylab <span style=color:#ae81ff>7777</span> &amp; 
</span></span><span style=display:flex><span>curl -v --proxy http://localhost:7777 http://localhost:7778/
</span></span></code></pre></div><h1 id=about><a class=header-anchor href=#about></a>About</h1><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/* rio_readinitb - Associate a descriptor with a read buffer and reset buffer
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * open_clientfd - Open connection to server at &lt;hostname, port&gt; and
</span></span></span><span style=display:flex><span><span style=color:#75715e> *     return a socket descriptor ready for reading and writing. This
</span></span></span><span style=display:flex><span><span style=color:#75715e> *     function is reentrant and protocol-independent.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *     On error, returns:
</span></span></span><span style=display:flex><span><span style=color:#75715e> *       -2 for getaddrinfo error
</span></span></span><span style=display:flex><span><span style=color:#75715e> *       -1 with errno set for other errors.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * if (!Rio_readlineb(&amp;rio, buf, MAXLINE))  //line:netp:doit:readrequest 带缓冲区的读，将一行读入buf中。
</span></span></span><span style=display:flex><span><span style=color:#75715e> * /
</span></span></span></code></pre></div><h1 id=begin><a class=header-anchor href=#begin></a>begin</h1><h2 id=web-proxy的实验任务1><a class=header-anchor href=#web-proxy%e7%9a%84%e5%ae%9e%e9%aa%8c%e4%bb%bb%e5%8a%a11></a>web proxy的实验任务1</h2><p>要求：</p><ul><li><p>实现一个处理 HTTP/1.0 GET 请求的基本顺序 web 代理</p></li><li><p>如果接收到一个浏览器请求为 HTTP/1.1 版本，则应将它作为 HTTP/1.0 请求转发</p></li><li><p>转发合法的 HTTP 请求</p></li><li><p>假设请求为 <code>GET http://www.cmu.edu/hub/index.html HTTP/1.1</code></p></li><li><p>则主机名为 <code>www.cmu.edu</code></p></li><li><p>请求的页面为 <code>/hub/index.html</code></p></li><li><p>HTTP 请求每行以 <code>\r\n</code> 结束，以一个空行 <code>\r\n</code> 结尾</p></li><li><p>代理发送的请求的 header 为：</p></li><li><p><code>Host</code>: 如 <code>Host: www.cmu.edu</code></p></li><li><p><code>User-Agent</code>: 如 <code>User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:10.0.3) Gecko/20120305 Firefox/10.0.3</code></p></li><li><p><code>Connection</code>: 必须发送 <code>Connection: close</code></p></li><li><p><code>Proxy-Connection</code>: 必须发送 <code>Proxy-Connection: close</code></p></li></ul><blockquote><p>实现大体思路：</p></blockquote><p><img src=output_image/2cde49b6c279b1e29f9a2944347e34b4.png alt></p><p>在<code>proxy</code>中，<code>open_listenfd(char* port)</code> 为我们完成了<code>getaddrinfo()</code>、<code>socket()</code>、<code>bind()</code>、<code>listen()</code>部分，<code>port</code>则是<code>char *argv[1]</code>，<code>argc</code>记录调用命令的参数个数。</p><p>首先，参考基于线程的并发<code>hello world</code>服务器，这只是一部分，后续我们会修改成预线程化的并发处理方式：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc,<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>argv[])
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>signal</span>(SIGPIPE,SIG_IGN);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> listenfd,connfd,<span style=color:#f92672>*</span>connfdp;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>socklen_t</span> clientlen;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> sockaddr_storage clientaddr;  <span style=color:#75715e>// 容纳不同地址族（如 IPv4、IPv6 等）的套接字地址信息
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>char</span> client_hostname[MAXLINE],client_port[MAXLINE];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pthread_t</span> tid;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(argc <span style=color:#f92672>!=</span> <span style=color:#ae81ff>2</span>){
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>fprintf</span>(stderr,<span style=color:#e6db74>&#34;Usage: %s &lt;port&gt;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, argv[<span style=color:#ae81ff>0</span>]);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>exit</span>(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    listenfd <span style=color:#f92672>=</span> <span style=color:#a6e22e>Open_listenfd</span>(argv[<span style=color:#ae81ff>1</span>]);  <span style=color:#75715e>//listenfd 是监听socket的文件描述符，绑定到argv[1] port上。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,listenfd);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span>(<span style=color:#ae81ff>1</span>){
</span></span><span style=display:flex><span>        clientlen <span style=color:#f92672>=</span> <span style=color:#66d9ef>sizeof</span>(clientaddr);
</span></span><span style=display:flex><span>        connfdp <span style=color:#f92672>=</span> (<span style=color:#66d9ef>int</span><span style=color:#f92672>*</span>)<span style=color:#a6e22e>Malloc</span>(<span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>int</span>));
</span></span><span style=display:flex><span>        <span style=color:#f92672>*</span>connfdp <span style=color:#f92672>=</span> <span style=color:#a6e22e>Accept</span>(listenfd,(SA<span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>clientaddr,<span style=color:#f92672>&amp;</span>clientlen); <span style=color:#75715e>//将 struct sockaddr_storage 类型的指针转换为 struct sockaddr * 类型的指针
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        connfd <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>connfdp;
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;connfd in main:%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,connfd);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;tid : %ld </span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,tid);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Pthread_create</span>(<span style=color:#f92672>&amp;</span>tid,NULL,<span style=color:#66d9ef>thread</span>,connfdp);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Pthread_join</span>(tid,NULL);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;connented to (%s,%s)</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,client_hostname,client_port);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Close(connfd);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;%s&#34;</span>, user_agent_hdr);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>exit</span>(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>thread</span>(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>vargp)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> connfd <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>((<span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>)vargp);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Free</span>(vargp);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Pthread_detach</span>(<span style=color:#a6e22e>pthread_self</span>());
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Hello,world!</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>doit</span>(connfd);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Close</span>(connfd);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>将上述<code>printf("Hello,world!\n");</code>替换成具体的实现<code>GET</code>方法的<code>void doit()</code>函数，在<code>void doit()</code>中，要求实现对<code>http://localhost:7778/</code>(<code>tiny</code>的访问路径)的解析，解析成<code>hostname</code>，<code>port</code>，<code>path='/'</code>三部分，<code>hostname , port</code>用于<code>Open_clientfd()</code>打开<code>server</code>的<code>&lt;hostname,port></code>，返回套接字描述符，准备读写。</p><h3 id=解析url><a class=header-anchor href=#%e8%a7%a3%e6%9e%90url></a>解析url</h3><ul><li><p><code>int strncmp(const char *s1, const char *s2, size_t n);</code>：</p></li><li><p><strong>功能</strong>：比较字符串 <code>s1</code> 和 <code>s2</code> 的前 <code>n</code> 个字符。如果两个字符串的前 <code>n</code> 个字符相等，则返回 0；如果 <code>s1</code> 的字符按字典序小于 <code>s2</code> 的字符，则返回一个小于 0 的值；如果 <code>s1</code> 的字符按字典序大于 <code>s2</code> 的字符，则返回一个大于 0 的值。在代码中，<code>strncmp(url, prefix, prefix_len)</code> 用于判断输入的 URL 是否以 <code>"http://"</code> 开头，如果不是则直接返回，不再进行后续解析。</p></li><li><p><code>char *strchr(const char *s, int c);</code></p></li><li><p><strong>功能</strong>：在字符串 <code>s</code> 中查找字符 <code>c</code> 第一次出现的位置，并返回指向该位置的指针。如果字符 <code>c</code> 不在字符串 <code>s</code> 中，则返回 <code>NULL</code>。在代码中，<code>strchr(host_start, '/')</code> 用于查找 URL 中路径部分的起始位置，<code>strchr(host_start, ':')</code> 用于查找端口号部分的起始位置。</p></li><li><p><code>char *strdup(const char *s);</code></p></li><li><p><strong>功能</strong>：分配足够的内存来复制字符串 <code>s</code>，并将 <code>s</code> 的内容复制到新分配的内存中，然后返回指向新字符串的指针。如果内存分配失败，则返回 <code>NULL</code>。在代码中，<code>strdup("80")</code> 用于在没有明确指定端口号时，为 <code>url_data->port</code> 分配内存并复制默认端口号 <code>"80"</code>，<code>strdup(path_start)</code> 和 <code>strdup("/")</code> 用于为 <code>url_data->path</code> 分配内存并复制相应的路径字符串。</p></li><li><p><code>char *strncpy(char *dest, const char *src, size_t n);</code></p></li><li><p><strong>功能</strong>：将字符串 <code>src</code> 的前 <code>n</code> 个字符复制到字符串 <code>dest</code> 中。如果 <code>src</code> 的长度小于 <code>n</code>，则 <code>dest</code> 会以 null 字符填充剩余位置；如果 <code>src</code> 的长度大于等于 <code>n</code>，则 <code>dest</code> 不会自动添加 null 字符，需要手动添加。在代码中，<code>strncpy(url_data->hostname, host_start, host_len)</code> 用于将提取的主机名字符串复制到 <code>url_data->hostname</code> 中，<code>strncpy(url_data->port,port_start + 1,port_len)</code> 用于将提取的端口号字符串复制到 <code>url_data->port</code> 中。</p></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>parse_url</span>(URL<span style=color:#f92672>*</span> url_data, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> url) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>url_data <span style=color:#f92672>||</span> <span style=color:#f92672>!</span>url) <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> prefix <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;http://&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>size_t</span> prefix_len <span style=color:#f92672>=</span> <span style=color:#a6e22e>strlen</span>(prefix);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>strncmp</span>(url, prefix, prefix_len) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>) <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 每一个部分的开始位置
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> host_start <span style=color:#f92672>=</span> url <span style=color:#f92672>+</span> prefix_len;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> path_start <span style=color:#f92672>=</span> <span style=color:#a6e22e>strchr</span>(host_start, <span style=color:#e6db74>&#39;/&#39;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> port_start <span style=color:#f92672>=</span> <span style=color:#a6e22e>strchr</span>(host_start,<span style=color:#e6db74>&#39;:&#39;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (port_start <span style=color:#f92672>-</span> host_start <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span> (<span style=color:#e6db74>&#34;port_start - host_start error.&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>size_t</span> host_len <span style=color:#f92672>=</span> path_start <span style=color:#f92672>?</span> (<span style=color:#66d9ef>size_t</span>)(port_start <span style=color:#f92672>-</span> host_start) <span style=color:#f92672>:</span> <span style=color:#a6e22e>strlen</span>(host_start);
</span></span><span style=display:flex><span>    url_data<span style=color:#f92672>-&gt;</span>hostname <span style=color:#f92672>=</span> (<span style=color:#66d9ef>char</span><span style=color:#f92672>*</span>)<span style=color:#a6e22e>malloc</span>(host_len <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>strncpy</span>(url_data<span style=color:#f92672>-&gt;</span>hostname, host_start, host_len);
</span></span><span style=display:flex><span>    url_data<span style=color:#f92672>-&gt;</span>hostname[host_len] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;\0&#39;</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果没有端口号
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (port_start <span style=color:#f92672>==</span> NULL){
</span></span><span style=display:flex><span>        url_data<span style=color:#f92672>-&gt;</span>port <span style=color:#f92672>=</span> <span style=color:#a6e22e>strdup</span>(<span style=color:#e6db74>&#34;80&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>{
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> port_end <span style=color:#f92672>=</span> path_start <span style=color:#f92672>?</span> path_start : (host_start <span style=color:#f92672>+</span> <span style=color:#a6e22e>strlen</span>(host_start));
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>size_t</span> port_len <span style=color:#f92672>=</span> (<span style=color:#66d9ef>size_t</span>)(port_end <span style=color:#f92672>-</span> (port_start <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>        url_data<span style=color:#f92672>-&gt;</span>port <span style=color:#f92672>=</span> (<span style=color:#66d9ef>char</span><span style=color:#f92672>*</span>)<span style=color:#a6e22e>malloc</span>(port_len <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>strncpy</span>(url_data<span style=color:#f92672>-&gt;</span>port,port_start <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>,port_len);
</span></span><span style=display:flex><span>        url_data<span style=color:#f92672>-&gt;</span>port[port_len] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;\0&#39;</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    url_data<span style=color:#f92672>-&gt;</span>path <span style=color:#f92672>=</span> path_start <span style=color:#f92672>?</span> <span style=color:#a6e22e>strdup</span>(path_start) <span style=color:#f92672>:</span> <span style=color:#a6e22e>strdup</span>(<span style=color:#e6db74>&#34;/&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Hostname: %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, url_data<span style=color:#f92672>-&gt;</span>hostname);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Port: %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, url_data<span style=color:#f92672>-&gt;</span>port);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Path: %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, url_data<span style=color:#f92672>-&gt;</span>path);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=构建请求头><a class=header-anchor href=#%e6%9e%84%e5%bb%ba%e8%af%b7%e6%b1%82%e5%a4%b4></a>构建请求头</h3><p>要求构建的请求头格式：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>GET / HTTP/1.0
</span></span><span style=display:flex><span>Host: localhost:7778
</span></span><span style=display:flex><span>Accept: */*
</span></span><span style=display:flex><span>Connection: close
</span></span><span style=display:flex><span>Proxy-Connection: close
</span></span><span style=display:flex><span>User-Agent: Mozilla/5.0 <span style=color:#f92672>(</span>X11; Linux x86_64; rv:10.0.3<span style=color:#f92672>)</span> Gecko/20120305 Firefox/10.0.3
</span></span></code></pre></div><p><code>build_header</code> 函数的主要功能是构建一个 HTTP 请求头，这个请求头将被代理服务器用于向目标服务器发送请求。它会从客户端的请求中读取部分信息，对其进行处理和筛选，然后添加必要的请求头字段，最终生成一个完整的 HTTP 请求头。</p><p>当读取到空行（<code>\r\n</code>）时，意味着客户端请求头结束，此时跳出循环。</p><p>跳过 <code>Connection</code>、<code>Proxy-Connection</code> 和 <code>User-Agent</code> 这些头字段。因为代理服务器需要统一控制这些字段，避免客户端的设置对代理转发产生影响。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>build_header</span>(URL <span style=color:#f92672>*</span>url_data, <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>serverbuf, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>version, <span style=color:#66d9ef>rio_t</span> <span style=color:#f92672>*</span>clientrio)
</span></span><span style=display:flex><span>{  
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>snprintf</span>(serverbuf, MAXLINE, <span style=color:#e6db74>&#34;GET %s %s</span><span style=color:#ae81ff>\r\n</span><span style=color:#e6db74>&#34;</span>, url_data<span style=color:#f92672>-&gt;</span>path, version);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 使用 snprintf 函数将请求行（如 &#34;GET /path HTTP/1.0&#34;）写入 serverbuf 缓冲区。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 这样做是因为所有的 HTTP GET 请求都以请求行开始，指定了请求方法（GET）、请求路径和 HTTP 版本。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 第二步：初始化缓冲区和标志位
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>char</span> buf[MAXLINE];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> has_host_flag <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Rio_readlineb</span>(clientrio, buf, MAXLINE);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>strcmp</span>(buf, <span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\r\n</span><span style=color:#e6db74>&#34;</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>strncasecmp</span>(buf, <span style=color:#e6db74>&#34;Host:&#34;</span>, <span style=color:#ae81ff>5</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            has_host_flag <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 跳过客户端发送的 Connection、Proxy-Connection、User-Agent 头
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>strncasecmp</span>(buf, <span style=color:#e6db74>&#34;Connection:&#34;</span>, <span style=color:#ae81ff>11</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>strncasecmp</span>(buf, <span style=color:#e6db74>&#34;Proxy-Connection:&#34;</span>, <span style=color:#ae81ff>17</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>strncasecmp</span>(buf, <span style=color:#e6db74>&#34;User-Agent:&#34;</span>, <span style=color:#ae81ff>11</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>strcat</span>(serverbuf, buf);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>has_host_flag)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>sprintf</span>(buf, <span style=color:#e6db74>&#34;Host: %s</span><span style=color:#ae81ff>\r\n</span><span style=color:#e6db74>&#34;</span>, url_data<span style=color:#f92672>-&gt;</span>hostname);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>strcat</span>(serverbuf, buf);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>strcat</span>(serverbuf, <span style=color:#e6db74>&#34;Connection: close</span><span style=color:#ae81ff>\r\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>strcat</span>(serverbuf, <span style=color:#e6db74>&#34;Proxy-Connection: close</span><span style=color:#ae81ff>\r\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>strcat</span>(serverbuf, user_agent_hdr);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>strcat</span>(serverbuf, <span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\r\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Generated header:</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>%s&#34;</span>, serverbuf);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=do-it-方法><a class=header-anchor href=#do-it-%e6%96%b9%e6%b3%95></a>do it 方法</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>doit</span>(<span style=color:#66d9ef>int</span> connfd){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> buf[MAXLINE], method[MAXLINE], url[MAXLINE], version[MAXLINE];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>http <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;HTTP/1.0&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>rio_t</span> clientrio;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Rio_readinitb</span>(<span style=color:#f92672>&amp;</span>clientrio, connfd);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>Rio_readlineb</span>(<span style=color:#f92672>&amp;</span>clientrio, buf, MAXLINE) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>sscanf</span>(buf, <span style=color:#e6db74>&#34;%s%s%s&#34;</span>, method, url, version);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 仅使用GET方法,不是GET的话就return。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>strcmp</span>(method, <span style=color:#e6db74>&#34;GET&#34;</span>))
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;proxy dosen&#39;t support this method.&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// HTTP/1.1 -》 HTTP/1.0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>strcmp</span>(version, http))
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>strcpy</span>(version, http);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;version: %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, version);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>do_get</span>(<span style=color:#f92672>&amp;</span>clientrio, method, url, version,connfd,buf);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>   <span style=color:#75715e>//  Close(connfd);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><ul><li><p><strong>读取请求行</strong><br>在 <code>doit</code> 函数中，使用 <code>Rio_readlineb</code> 从客户端读入请求数据，通常第一行是形如 <code>"GET http://example.com/path HTTP/1.1"</code> 的请求行。使用 <code>sscanf</code> 分解出方法、URL 和版本。</p></li><li><p><strong>判断请求方法</strong><br>代码只支持 GET 请求，如果请求方法不是 <code>"GET"</code>，则打印不支持提示并直接返回。</p></li><li><p><strong>版本号处理</strong><br>如果请求的 HTTP 版本不是 <code>"HTTP/1.0"</code>，则将其强制改为 HTTP/1.0，这样后续与服务器的通信保持一致。</p></li></ul><h3 id=do-get方法><a class=header-anchor href=#do-get%e6%96%b9%e6%b3%95></a>do get方法</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>do_get</span>(<span style=color:#66d9ef>rio_t</span> <span style=color:#f92672>*</span>clientrio, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>method, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>url, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>version, <span style=color:#66d9ef>int</span> connfd, <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>buf)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> serverbuf[MAXLINE];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>rio_t</span> server_rio;
</span></span><span style=display:flex><span>    URL <span style=color:#f92672>*</span>url_data <span style=color:#f92672>=</span> <span style=color:#a6e22e>Malloc</span>(<span style=color:#66d9ef>sizeof</span>(URL));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>ssize_t</span> n;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>parse_url</span>(url_data, url);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(<span style=color:#a6e22e>query_cache</span>(cache, connfd, url))
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Can not find in cache , build header will coming!</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>build_header</span>(url_data, serverbuf, version, clientrio);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> serverfd <span style=color:#f92672>=</span> <span style=color:#a6e22e>Open_clientfd</span>(url_data<span style=color:#f92672>-&gt;</span>hostname, url_data<span style=color:#f92672>-&gt;</span>port);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (serverfd <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;connection failed.</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Rio_readinitb</span>(<span style=color:#f92672>&amp;</span>server_rio, serverfd);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;server id: %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, serverfd);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Rio_writen</span>(serverfd, serverbuf, <span style=color:#a6e22e>strlen</span>(serverbuf));
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 临时缓存
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> response_cache[CACHESIZE];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> total_size <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> ((n <span style=color:#f92672>=</span> <span style=color:#a6e22e>Rio_readlineb</span>(<span style=color:#f92672>&amp;</span>server_rio, buf, MAXLINE)) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;proxy received %d bytes,then send to client</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, (<span style=color:#66d9ef>int</span>)n);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Rio_writen</span>(connfd, buf, n);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (total_size <span style=color:#f92672>+</span> n <span style=color:#f92672>&lt;</span> CACHESIZE)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>memcpy</span>(response_cache <span style=color:#f92672>+</span> total_size, buf, n);
</span></span><span style=display:flex><span>            total_size <span style=color:#f92672>+=</span> n;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            total_size <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (total_size <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>cache_insert</span>(cache, connfd, url, response_cache,total_size);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Close</span>(serverfd);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (url_data)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>free_url</span>(url_data);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>free</span>(url_data);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>free_url</span>(URL<span style=color:#f92672>*</span> url_data) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>url_data) <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>free</span>(url_data<span style=color:#f92672>-&gt;</span>hostname);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>free</span>(url_data<span style=color:#f92672>-&gt;</span>port);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>free</span>(url_data<span style=color:#f92672>-&gt;</span>path);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>chatgpt</code>的解释：</p><ul><li><p><strong>解析 URL</strong><br>在 <code>do_get</code> 函数中，首先调用 <code>parse_url</code> 对 URL 进行解析。解析过程包括：</p><ul><li>检查 URL 是否以 <code>"http://"</code> 开头。</li><li>提取主机名、端口号（如果有，否则默认为 80）和路径（如果未提供路径则默认为 <code>/</code>）。</li><li>打印解析结果，方便调试。</li></ul></li><li><p><strong>缓存查询</strong><br>调用 <code>query_cache(cache, connfd, url)</code> 判断请求是否已存在缓存中。如果存在则直接返回缓存内容给客户端，无需重新发起请求。</p></li><li><p><strong>构建转发请求头</strong><br>如果缓存中未找到对应响应，调用 <code>build_header</code> 生成新的 HTTP 请求头。此函数：</p><ul><li>使用 <code>snprintf</code> 构造首行 <code>"GET &lt;path> &lt;version>"</code>。</li><li>逐行读取客户端发送的请求头信息，跳过客户端的 <code>Connection</code>、<code>Proxy-Connection</code> 和 <code>User-Agent</code> 字段，确保这些头部由代理自行设置。</li><li>若客户端请求中未包含 <code>Host</code> 字段，则手动添加一个 <code>Host: &lt;hostname></code> 字段。</li><li>最后添加 <code>"Connection: close"</code>、<code>"Proxy-Connection: close"</code> 和预定义的 <code>User-Agent</code> 头，保证服务器端连接在响应后关闭。</li></ul></li><li><p><strong>建立与目标服务器的连接</strong><br>使用 <code>Open_clientfd(url_data->hostname, url_data->port)</code> 根据解析的主机名和端口建立到目标服务器的连接。成功后利用 <code>Rio_writen</code> 将构造好的请求头发送给目标服务器。</p></li><li><p><strong>中继服务器响应</strong><br>通过一个循环不断调用 <code>Rio_readlineb</code> 读取服务器响应：</p><ul><li>每读取一行数据，通过 <code>Rio_writen</code> 发送回客户端，实现响应中继。</li><li>同时，将数据临时保存在 <code>response_cache</code> 缓存数组中（如果数据总量未超过缓存大小）。</li><li>打印调试信息，显示每次中继的数据字节数。</li></ul></li><li><p><strong>缓存响应数据</strong><br>如果整个响应数据大小小于缓存容量（<code>CACHESIZE</code>），则调用 <code>cache_insert</code> 将响应内容缓存，方便后续相同请求快速响应。</p></li><li><p><strong>资源释放</strong><br>完成响应中继后，关闭与服务器的连接，并调用 <code>free_url</code> 释放在 URL 解析时分配的内存。</p></li></ul><h3 id=basic结果><a class=header-anchor href=#basic%e7%bb%93%e6%9e%9c></a>Basic结果</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>*** Basic ***
</span></span><span style=display:flex><span>Starting tiny on <span style=color:#ae81ff>20186</span>
</span></span><span style=display:flex><span>Starting proxy on <span style=color:#ae81ff>29325</span>
</span></span><span style=display:flex><span>1: home.html
</span></span><span style=display:flex><span>   Fetching ./tiny/home.html into ./.proxy using the proxy
</span></span><span style=display:flex><span>   Fetching ./tiny/home.html into ./.noproxy directly from Tiny
</span></span><span style=display:flex><span>   Comparing the two files
</span></span><span style=display:flex><span>   Success: Files are identical.
</span></span><span style=display:flex><span>2: csapp.c
</span></span><span style=display:flex><span>   Fetching ./tiny/csapp.c into ./.proxy using the proxy
</span></span><span style=display:flex><span>   Fetching ./tiny/csapp.c into ./.noproxy directly from Tiny
</span></span><span style=display:flex><span>   Comparing the two files
</span></span><span style=display:flex><span>   Success: Files are identical.
</span></span><span style=display:flex><span>3: tiny.c
</span></span><span style=display:flex><span>   Fetching ./tiny/tiny.c into ./.proxy using the proxy
</span></span><span style=display:flex><span>   Fetching ./tiny/tiny.c into ./.noproxy directly from Tiny
</span></span><span style=display:flex><span>   Comparing the two files
</span></span><span style=display:flex><span>   Success: Files are identical.
</span></span><span style=display:flex><span>4: godzilla.jpg
</span></span><span style=display:flex><span>   Fetching ./tiny/godzilla.jpg into ./.proxy using the proxy
</span></span><span style=display:flex><span>   Fetching ./tiny/godzilla.jpg into ./.noproxy directly from Tiny
</span></span><span style=display:flex><span>   Comparing the two files
</span></span><span style=display:flex><span>   Success: Files are identical.
</span></span><span style=display:flex><span>5: tiny
</span></span><span style=display:flex><span>   Fetching ./tiny/tiny into ./.proxy using the proxy
</span></span><span style=display:flex><span>   Fetching ./tiny/tiny into ./.noproxy directly from Tiny
</span></span><span style=display:flex><span>   Comparing the two files
</span></span><span style=display:flex><span>   Success: Files are identical.
</span></span><span style=display:flex><span>Killing tiny and proxy
</span></span><span style=display:flex><span>basicScore: 40/40
</span></span></code></pre></div><h1 id=concurency-并发-与cache-缓存><a class=header-anchor href=#concurency-%e5%b9%b6%e5%8f%91-%e4%b8%8ecache-%e7%bc%93%e5%ad%98></a>Concurency 并发 与cache 缓存</h1><h2 id=并发><a class=header-anchor href=#%e5%b9%b6%e5%8f%91></a>并发</h2><h3 id=main><a class=header-anchor href=#main></a>main</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>argv[])
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>signal</span>(SIGPIPE, SIG_IGN);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> listenfd, <span style=color:#f92672>*</span>connfdp;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>socklen_t</span> clientlen;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> sockaddr_storage clientaddr; <span style=color:#75715e>// 容纳不同地址族（如 IPv4、IPv6 等）的套接字地址信息
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>pthread_t</span> tid;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (argc <span style=color:#f92672>!=</span> <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>fprintf</span>(stderr, <span style=color:#e6db74>&#34;Usage: %s &lt;port&gt;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, argv[<span style=color:#ae81ff>0</span>]);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>exit</span>(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    listenfd <span style=color:#f92672>=</span> <span style=color:#a6e22e>Open_listenfd</span>(argv[<span style=color:#ae81ff>1</span>]); <span style=color:#75715e>// listenfd 是监听socket的文件描述符，绑定到argv[1] port上。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    cache <span style=color:#f92672>=</span> <span style=color:#a6e22e>Malloc</span>(<span style=color:#66d9ef>sizeof</span>(cache_header));
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>cache_init</span>(cache);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, listenfd);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> NTHREADS; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Pthread_create</span>(<span style=color:#f92672>&amp;</span>tid, NULL, <span style=color:#66d9ef>thread</span>, NULL);  <span style=color:#75715e>//为线程捆绑thread方法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        clientlen <span style=color:#f92672>=</span> <span style=color:#66d9ef>sizeof</span>(clientaddr);
</span></span><span style=display:flex><span>        connfdp <span style=color:#f92672>=</span> (<span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>)<span style=color:#a6e22e>Malloc</span>(<span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>int</span>));
</span></span><span style=display:flex><span>        <span style=color:#f92672>*</span>connfdp <span style=color:#f92672>=</span> <span style=color:#a6e22e>Accept</span>(listenfd, (SA <span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>clientaddr, <span style=color:#f92672>&amp;</span>clientlen); <span style=color:#75715e>// 将 struct sockaddr_storage 类型的指针转换为 struct sockaddr * 类型的指针
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// connfdp 加入队列
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;connfdp number is %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#f92672>*</span>connfdp);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>pthread_mutex_lock</span>(<span style=color:#f92672>&amp;</span>queue_mutex);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> myQueueNode <span style=color:#f92672>*</span>node <span style=color:#f92672>=</span> <span style=color:#a6e22e>Malloc</span>(<span style=color:#66d9ef>sizeof</span>(myQueueNode));
</span></span><span style=display:flex><span>        node<span style=color:#f92672>-&gt;</span>connfdp <span style=color:#f92672>=</span> connfdp;
</span></span><span style=display:flex><span>        node<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (queue.tail <span style=color:#f92672>==</span> NULL)
</span></span><span style=display:flex><span>        { <span style=color:#75715e>// 队列为空
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            queue.head <span style=color:#f92672>=</span> queue.tail <span style=color:#f92672>=</span> node;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        { <span style=color:#75715e>// 追加到队列尾部
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            queue.tail<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> node;
</span></span><span style=display:flex><span>            queue.tail <span style=color:#f92672>=</span> node;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>pthread_cond_signal</span>(<span style=color:#f92672>&amp;</span>queue_cond); <span style=color:#75715e>// 通知一个等待的线程
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>pthread_mutex_unlock</span>(<span style=color:#f92672>&amp;</span>queue_mutex);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;tid : %ld </span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, tid);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;%s&#34;</span>, user_agent_hdr);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>free</span>(cache);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>exit</span>(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol><li><p>主线程首先通过 <code>pthread_mutex_lock(&amp;queue_mutex);</code> 获取互斥锁，从而保证在修改共享队列 <code>queue</code> 时不会被其他线程干扰。</p></li><li><p>随后，主线程创建一个新的节点 <code>node</code> 并将新的连接描述符加入到队列中（如果队列为空则初始化头尾，否则追加到队列尾）。</p></li><li><p>添加节点完成后，通过 <code>pthread_cond_signal(&amp;queue_cond);</code> 通知至少一个等待该条件变量的线程（这些线程可能正处于等待队列非空的状态）。</p></li><li><p>最后，主线程通过 <code>pthread_mutex_unlock(&amp;queue_mutex);</code> 释放锁，允许其他线程访问共享队列。</p></li></ol><h3 id=thread><a class=header-anchor href=#thread></a>thread</h3><ul><li><strong>线程等待任务</strong><br>每个工作线程在 <code>thread</code> 函数开始时通过 <code>pthread_mutex_lock</code> 加锁后检查队列。如果队列为空，调用 <code>pthread_cond_wait</code> 阻塞等待新的连接到来。</li><li><strong>从队列中取出任务</strong><br>一旦队列中有任务，线程获取队列头节点，将其从队列中摘除。取出连接后释放互斥锁。</li><li><strong>调用请求处理函数</strong><br>线程调用 <code>doit(connfd)</code> 处理这个客户端请求。处理完后关闭连接并释放对应的内存资源。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>thread</span>(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>vargp)
</span></span><span style=display:flex><span>{  
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>pthread_mutex_lock</span>(<span style=color:#f92672>&amp;</span>queue_mutex);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (queue.head <span style=color:#f92672>==</span> NULL)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>pthread_cond_wait</span>(<span style=color:#f92672>&amp;</span>queue_cond, <span style=color:#f92672>&amp;</span>queue_mutex);
</span></span><span style=display:flex><span>    }  
</span></span><span style=display:flex><span>    myQueueNode <span style=color:#f92672>*</span>node <span style=color:#f92672>=</span> queue.head;
</span></span><span style=display:flex><span>    queue.head <span style=color:#f92672>=</span> queue.head<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>( queue.head <span style=color:#f92672>==</span> NULL)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        queue.tail <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// int connfd = *((int *)vargp);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>connfdp <span style=color:#f92672>=</span> node<span style=color:#f92672>-&gt;</span>connfdp;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Free</span>(node);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>pthread_mutex_unlock</span>(<span style=color:#f92672>&amp;</span>queue_mutex);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;thread is working...</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> connfd <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>connfdp;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>doit</span>(connfd);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Close</span>(connfd);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>free</span>(connfdp);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这种做法确保了在对队列进行操作时的线程安全，防止了多个线程同时修改队列而产生数据竞争或数据不一致的问题。</p><h2 id=缓存><a class=header-anchor href=#%e7%bc%93%e5%ad%98></a>缓存</h2><p><img src=output_image/a1ad5ed038fd5fdde02af741f19b2631.png alt></p><p> <code>Proxy</code> 中，当多个客户端或一个客户端多次访问同一个服务端的同一对象时，<code>Proxy</code> 每次都要从服务端请求，这是很耗费时间的。如果 <code>Proxy</code> 能把访问过的对象存储下来，那么再次遇到同样的请求时，就不需要再连接到服务端了，可以直接回复给客户端。而 <code>Cache</code> 的大小并不是无限的，所以就又要考虑替换策略，本实验要求使用 <code>LRU</code>，采用的是读者与写者的模型，读者的优先级高于写者。（见书上707页）</p><p><a href=https://zhuanlan.zhihu.com/p/497982541>CSAPP | Lab9-Proxy Lab 深入解析 - 知乎</a></p><p><code>cache</code>，包括<code>cache.c</code>和<code>cache.h</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// cache.h
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#define CACHESIZE 102400
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define CACHENUM 10
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define CACHENAMELEN 64
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> size;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> timestamp;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>char</span> cache_name[CACHENAMELEN];
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>char</span> content[CACHESIZE];
</span></span><span style=display:flex><span>} cache_content;
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> used_cache_num;
</span></span><span style=display:flex><span>  cache_content menu[CACHENUM];
</span></span><span style=display:flex><span>} cache_header;
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>cache_insert</span>(cache_header <span style=color:#f92672>*</span>cache_content, <span style=color:#66d9ef>int</span> connfd,<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> url,<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>response_cache,<span style=color:#66d9ef>int</span> response_size);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>cache_init</span>(cache_header<span style=color:#f92672>*</span> cache);  <span style=color:#75715e>//cache_header 是结构体类型，不能把取地址运算符用在类型声明上
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>cache_clean</span>(cache_header<span style=color:#f92672>*</span> cache);
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>query_cache</span>(cache_header<span style=color:#f92672>*</span> cache,<span style=color:#66d9ef>int</span> connfd,<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> url);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// cache.c
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>sem_t</span> mutex,w;
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> cache_time_stamp <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> reader_cnt <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @brief 添加到缓存
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @param  cache_header     My Param doc
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @param  connfd           My Param doc
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @param  url              My Param doc
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @param  response_cache   My Param doc
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @param  response_size    My Param doc
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>cache_insert</span>(cache_header <span style=color:#f92672>*</span>cache_header, <span style=color:#66d9ef>int</span> connfd, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>url, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>response_cache, <span style=color:#66d9ef>int</span> response_size)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>P</span>(<span style=color:#f92672>&amp;</span>w);
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 若cache已经insert满了，找到最老的content进行LRU替换
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> (cache_header<span style=color:#f92672>-&gt;</span>used_cache_num <span style=color:#f92672>==</span> CACHENUM)
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> oldest <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;</span> CACHENUM; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (cache_header<span style=color:#f92672>-&gt;</span>menu[i].timestamp <span style=color:#f92672>&lt;</span> cache_header<span style=color:#f92672>-&gt;</span>menu[oldest].timestamp)
</span></span><span style=display:flex><span>        oldest <span style=color:#f92672>=</span> i;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    cache_header<span style=color:#f92672>-&gt;</span>menu[oldest].size <span style=color:#f92672>=</span> response_size;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>strncpy</span>(cache_header<span style=color:#f92672>-&gt;</span>menu[oldest].cache_name, url, CACHENAMELEN <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    cache_header<span style=color:#f92672>-&gt;</span>menu[oldest].cache_name[CACHENAMELEN <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;\0&#39;</span>;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>memcpy</span>(cache_header<span style=color:#f92672>-&gt;</span>menu[oldest].content, response_cache, response_size);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>P</span>(<span style=color:#f92672>&amp;</span>mutex); <span style=color:#75715e>// 更新时间戳的时候需要加锁
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    cache_header<span style=color:#f92672>-&gt;</span>menu[oldest].timestamp <span style=color:#f92672>=</span> cache_time_stamp;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>V</span>(<span style=color:#f92672>&amp;</span>mutex);
</span></span><span style=display:flex><span>    cache_time_stamp<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// cache 没满
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Insert into cache...&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>P</span>(<span style=color:#f92672>&amp;</span>mutex);
</span></span><span style=display:flex><span>    cache_header<span style=color:#f92672>-&gt;</span>menu[cache_header<span style=color:#f92672>-&gt;</span>used_cache_num].timestamp <span style=color:#f92672>=</span> cache_time_stamp;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>V</span>(<span style=color:#f92672>&amp;</span>mutex); 
</span></span><span style=display:flex><span>    cache_header<span style=color:#f92672>-&gt;</span>menu[cache_header<span style=color:#f92672>-&gt;</span>used_cache_num].size <span style=color:#f92672>=</span> response_size;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>strncpy</span>(cache_header<span style=color:#f92672>-&gt;</span>menu[cache_header<span style=color:#f92672>-&gt;</span>used_cache_num].cache_name, url, CACHENAMELEN);
</span></span><span style=display:flex><span>    cache_header<span style=color:#f92672>-&gt;</span>menu[cache_header<span style=color:#f92672>-&gt;</span>used_cache_num].cache_name[CACHENAMELEN <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;\0&#39;</span>;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>memcpy</span>(cache_header<span style=color:#f92672>-&gt;</span>menu[cache_header<span style=color:#f92672>-&gt;</span>used_cache_num].content, response_cache, response_size);
</span></span><span style=display:flex><span>    cache_header<span style=color:#f92672>-&gt;</span>used_cache_num <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    cache_time_stamp<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>V</span>(<span style=color:#f92672>&amp;</span>w);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>其实上述这段代码并不难，只是<code>cache_content struct</code> 的相关内容的替换，使用静态变量<code>static int cache_time_stamp = 0</code>记录总共对缓存进行操作的此时，包括读、写。读的时候更新对应<code>content</code>的 <code>time stamp</code>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @brief 初始化cache
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @param  cache
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>cache_init</span>(cache_header <span style=color:#f92672>*</span>cache)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  cache<span style=color:#f92672>-&gt;</span>used_cache_num <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> CACHENUM; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> CACHENUM; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      cache<span style=color:#f92672>-&gt;</span>menu[i].size <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>      cache<span style=color:#f92672>-&gt;</span>menu[i].timestamp <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>memset</span>(cache<span style=color:#f92672>-&gt;</span>menu[i].cache_name, <span style=color:#ae81ff>0</span>, CACHENAMELEN);
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>memset</span>(cache<span style=color:#f92672>-&gt;</span>menu[i].content, <span style=color:#ae81ff>0</span>, CACHESIZE);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>sem_init</span>(<span style=color:#f92672>&amp;</span>mutex, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>sem_init</span>(<span style=color:#f92672>&amp;</span>w, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>cache_clean</span>(cache_header <span style=color:#f92672>*</span>cache)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> CACHENUM; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>free</span>(cache<span style=color:#f92672>-&gt;</span>menu[i].content);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>free</span>(cache<span style=color:#f92672>-&gt;</span>menu[i].cache_name);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>free</span>(cache);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @brief  在缓存查找
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @param  cache            My Param doc
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @param  connfd           My Param doc
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @param  url              My Param doc
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @return int              1 命中缓存
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>query_cache</span>(cache_header <span style=color:#f92672>*</span>cache, <span style=color:#66d9ef>int</span> connfd, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>url)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Querying cache...</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> find_flag <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 当读者进来时，排队进入
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>P</span>(<span style=color:#f92672>&amp;</span>mutex); <span style=color:#75715e>// 进来一个读者时即加锁
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  reader_cnt <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (reader_cnt <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>)  <span style=color:#75715e>//统计目前在下面for循环还没出去的reader数量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>P</span>(<span style=color:#f92672>&amp;</span>w);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>V</span>(<span style=color:#f92672>&amp;</span>mutex); <span style=color:#75715e>// 读者解锁，下一个读者可以进来
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> CACHENUM; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>strcmp</span>(cache<span style=color:#f92672>-&gt;</span>menu[i].cache_name, url) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    { <span style=color:#75715e>// 缓存命中
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Get from proxy cache,then send to client</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>char</span> cachebuf[MAXLINE];
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>strncpy</span>(cachebuf, cache<span style=color:#f92672>-&gt;</span>menu[i].content, cache<span style=color:#f92672>-&gt;</span>menu[i].size);
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>Rio_writen</span>(connfd, cachebuf, cache<span style=color:#f92672>-&gt;</span>menu[i].size);
</span></span><span style=display:flex><span>      cache_time_stamp<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>      cache<span style=color:#f92672>-&gt;</span>menu[i].timestamp <span style=color:#f92672>=</span> cache_time_stamp;
</span></span><span style=display:flex><span>      find_flag <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>P</span>(<span style=color:#f92672>&amp;</span>mutex); <span style=color:#75715e>// 读者加锁，一个一个出去，确保reader_cnt的修改是原子的
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  reader_cnt <span style=color:#f92672>-=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (reader_cnt <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>V</span>(<span style=color:#f92672>&amp;</span>w);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>V</span>(<span style=color:#f92672>&amp;</span>mutex); <span style=color:#75715e>// 下一个读者可以出去
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span>(find_flag) <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=修改makefile><a class=header-anchor href=#%e4%bf%ae%e6%94%b9makefile></a>修改makefile</h2><p>由于自行创建了<code>cache.c</code>和<code>cache.h</code>文件，需要按照如下修改<code>Makefile</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># Makefile for Proxy Lab</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span><span style=color:#75715e># You may modify this file any way you like (except for the handin</span>
</span></span><span style=display:flex><span><span style=color:#75715e># rule). You instructor will type &#34;make&#34; on your specific Makefile to</span>
</span></span><span style=display:flex><span><span style=color:#75715e># build your proxy from sources.</span>
</span></span><span style=display:flex><span>CC <span style=color:#f92672>=</span> gcc
</span></span><span style=display:flex><span>CFLAGS <span style=color:#f92672>=</span> -g -Wall
</span></span><span style=display:flex><span>LDFLAGS <span style=color:#f92672>=</span> -lpthread
</span></span><span style=display:flex><span>all: proxy
</span></span><span style=display:flex><span>csapp.o: csapp.c csapp.h
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>$(</span>CC<span style=color:#66d9ef>)</span> <span style=color:#66d9ef>$(</span>CFLAGS<span style=color:#66d9ef>)</span> -c csapp.c
</span></span><span style=display:flex><span>cache.o: cache.c cache.h //<span style=color:#e6db74>`</span>cache.o<span style=color:#e6db74>`</span>目标依赖于<span style=color:#e6db74>`</span>cache.c<span style=color:#e6db74>`</span>源文件和<span style=color:#e6db74>`</span>cache.h<span style=color:#e6db74>`</span>头文件。当这些文件发生变化时，<span style=color:#e6db74>`</span>make<span style=color:#e6db74>`</span>会重新编译<span style=color:#e6db74>`</span>cache.c<span style=color:#e6db74>`</span>文件，使用<span style=color:#e6db74>`</span><span style=color:#66d9ef>$(</span>CC<span style=color:#66d9ef>)</span> <span style=color:#66d9ef>$(</span>CFLAGS<span style=color:#66d9ef>)</span> -c cache.c<span style=color:#e6db74>`</span>命令生成<span style=color:#e6db74>`</span>cache.o<span style=color:#e6db74>`</span>目标文件。
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>$(</span>CC<span style=color:#66d9ef>)</span> <span style=color:#66d9ef>$(</span>CFLAGS<span style=color:#66d9ef>)</span> -c cache.c
</span></span><span style=display:flex><span>proxy.o: proxy.c csapp.h cache.h cache.c proxy.h
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>$(</span>CC<span style=color:#66d9ef>)</span> <span style=color:#66d9ef>$(</span>CFLAGS<span style=color:#66d9ef>)</span> -c proxy.c
</span></span><span style=display:flex><span>proxy: proxy.o csapp.o cache.o
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>$(</span>CC<span style=color:#66d9ef>)</span> <span style=color:#66d9ef>$(</span>CFLAGS<span style=color:#66d9ef>)</span> proxy.o csapp.o cache.o -o proxy <span style=color:#66d9ef>$(</span>LDFLAGS<span style=color:#66d9ef>)</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Creates a tarball in ../proxylab-handin.tar that you can then</span>
</span></span></code></pre></div><h2 id=result><a class=header-anchor href=#result></a>Result</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>*** Concurrency ***
</span></span><span style=display:flex><span>Starting tiny on port <span style=color:#ae81ff>33243</span>
</span></span><span style=display:flex><span>Starting proxy on port <span style=color:#ae81ff>25385</span>
</span></span><span style=display:flex><span>Starting the blocking NOP server on port <span style=color:#ae81ff>2897</span>
</span></span><span style=display:flex><span>Trying to fetch a file from the blocking nop-server
</span></span><span style=display:flex><span>Fetching ./tiny/home.html into ./.noproxy directly from Tiny
</span></span><span style=display:flex><span>Fetching ./tiny/home.html into ./.proxy using the proxy
</span></span><span style=display:flex><span>Checking whether the proxy fetch succeeded
</span></span><span style=display:flex><span>Success: Was able to fetch tiny/home.html from the proxy.
</span></span><span style=display:flex><span>Killing tiny, proxy, and nop-server
</span></span><span style=display:flex><span>concurrencyScore: 15/15
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>*** Cache ***
</span></span><span style=display:flex><span>Starting tiny on port <span style=color:#ae81ff>3695</span>
</span></span><span style=display:flex><span>Starting proxy on port <span style=color:#ae81ff>15956</span>
</span></span><span style=display:flex><span>Fetching ./tiny/tiny.c into ./.proxy using the proxy
</span></span><span style=display:flex><span>Fetching ./tiny/home.html into ./.proxy using the proxy
</span></span><span style=display:flex><span>Fetching ./tiny/csapp.c into ./.proxy using the proxy
</span></span><span style=display:flex><span>Killing tiny
</span></span><span style=display:flex><span>Fetching a cached copy of ./tiny/home.html into ./.noproxy
</span></span><span style=display:flex><span>Success: Was able to fetch tiny/home.html from the cache.
</span></span><span style=display:flex><span>Killing proxy
</span></span><span style=display:flex><span>cacheScore: 15/15
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>totalScore: 70/70
</span></span></code></pre></div></div><footer class=article-footer><div class=share-wrapper><a href="http://connect.qq.com/widget/shareqq/index.html?url=https://user-xixiboliya.github.io/post/proxylab/&amp;title=CMU%20Proxylab&amp;desc=CMU%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%b3%bb%e7%bb%9f%e7%9a%84proxylab%ef%bc%8c%e6%90%ad%e5%bb%ba%e9%a2%84%e7%ba%bf%e7%a8%8b%e5%8c%96%e7%9a%84%e5%b9%b6%e5%8f%91%e4%bb%a3%e7%90%86%e6%9c%8d%e5%8a%a1%e5%99%a8%ef%bc%8c%e9%85%8d%e6%9c%89cache%e3%80%82&amp;source=https://user-xixiboliya.github.io/" target=_blank rel="noopener noreferrer" title="CMU Proxylab"><div class="share-icon icon icon-qq"></div></a><a href=javascript:; title="CMU Proxylab"><div class="share-icon icon icon-weixin"><div id=share-weixin><div class=share-weixin-dom><div class=share-weixin-content><img id=share-weixin-banner><div id=share-weixin-title></div><div id=share-weixin-desc></div></div><div class=share-weixin-qrcode><div class=share-weixin-info><div id=share-weixin-author></div><div id=share-weixin-theme>Powered By hugo-theme-reimu</div></div><img id=share-weixin-qr></div></div><div class=share-weixin-canvas></div></div></div></a></div><ul class=article-tag-list itemprop=keywords></ul></footer></div><nav id=article-nav data-aos=fade-up><div class="article-nav-link-wrap article-nav-link-left"><img data-src="https://upload-bbs.miyoushe.com/upload/2025/03/21/289087756/97d887d799d67579da10427573ff4ca7_6224929516410348176.jpg?x-oss-process=image//resize,s_600/quality,q_80/auto-orient,0/interlace,1/format,jpg" data-sizes=auto alt=人工智能概论复习笔记 class=lazyload>
<a href=https://user-xixiboliya.github.io/post/ai%E6%A6%82%E8%AE%BA/></a><div class=article-nav-caption>Newer</div><h3 class=article-nav-title>人工智能概论复习笔记</h3></div><div class="article-nav-link-wrap article-nav-link-right"><img data-src="https://upload-bbs.miyoushe.com/upload/2024/07/13/225492857/a2b8afcbef8b57736457a633a3444076_4067520047044828723.png?x-oss-process=image//resize,s_600/quality,q_80/auto-orient,0/interlace,1/format,png" data-sizes=auto alt="daemon 与 服务" class=lazyload>
<a href=https://user-xixiboliya.github.io/post/daemon%E5%B0%8F%E8%AE%B0/></a><div class=article-nav-caption>Older</div><h3 class=article-nav-title>daemon 与 服务</h3></div></nav></article></section></div><footer id=footer><div style=width:100%;overflow:hidden><div class=footer-line></div></div><div id=footer-info><div><span class=icon-copyright></span>
2020 -
2025
<span class="footer-info-sep rotate"></span>
Bertsin</div><div>Powered by&nbsp;<a href=https://gohugo.io/ target=_blank>Hugo</a>&nbsp; Theme.<a href=https://github.com/D-Sketon/hugo-theme-reimu target=_blank>Reimu</a></div><div><span class=icon-brush>&nbsp;
11.0k
</span>&nbsp;|&nbsp;
<span class=icon-coffee>&nbsp;
01:08</span></div><div><span class=icon-eye></span>
<span id=busuanzi_container_site_pv>Number of visits&nbsp;<span id=busuanzi_value_site_pv></span></span>
&nbsp;|&nbsp;
<span class=icon-user></span>
<span id=busuanzi_container_site_uv>Number of visitors&nbsp;<span id=busuanzi_value_site_uv></span></span></div></div></footer><div class=sidebar-top><div class="sidebar-top-taichi rotate"></div><div class=arrow-up></div></div><div id=mask class=hide></div></div><nav id=mobile-nav><div class=sidebar-wrap><div class=sidebar-toc-sidebar><div class=sidebar-toc><h3 class=toc-title>Contents</h3><div class="sidebar-toc-wrapper toc-div-class"><nav id=TableOfContents><ul><li><a href=#环境配置>环境配置</a></li></ul><ul><li><a href=#web-proxy的实验任务1>web proxy的实验任务1</a><ul><li><a href=#解析url>解析url</a></li><li><a href=#构建请求头>构建请求头</a></li><li><a href=#do-it-方法>do it 方法</a></li><li><a href=#do-get方法>do get方法</a></li><li><a href=#basic结果>Basic结果</a></li></ul></li></ul><ul><li><a href=#并发>并发</a><ul><li><a href=#main>main</a></li><li><a href=#thread>thread</a></li></ul></li><li><a href=#缓存>缓存</a></li><li><a href=#修改makefile>修改makefile</a></li><li><a href=#result>Result</a></li></ul></nav></div></div></div><div class="sidebar-common-sidebar hidden"><div class=sidebar-author><img data-src=/avatar/avatar.webp data-sizes=auto alt=Bertsin class=lazyload><div class=sidebar-author-name>Bertsin</div><div class=sidebar-description>祈祷中...</div></div><div class=sidebar-state><div class=sidebar-state-article><div>Posts</div><div class=sidebar-state-number>24</div></div><div class=sidebar-state-category><div>Categories</div><div class=sidebar-state-number>8</div></div><div class=sidebar-state-tag><div>Tags</div><div class=sidebar-state-number>1</div></div></div><div class=sidebar-social><div class="icon-bilibili sidebar-social-icon"><a href="https://space.bilibili.com/651491932?spm_id_from=333.1007.0.0" itemprop=url target=_blank aria-label=bilibili rel="noopener external nofollow noreferrer"></a></div><div class="icon-email sidebar-social-icon"><a href=linboxi123@163.com itemprop=url target=_blank aria-label=email rel="noopener external nofollow noreferrer"></a></div><div class="icon-github sidebar-social-icon"><a href=https://github.com/user-xixiboliya itemprop=url target=_blank aria-label=github rel="noopener external nofollow noreferrer"></a></div><div class="icon-zhihu sidebar-social-icon"><a href=https://www.zhihu.com/people/lllll-19-64-21 itemprop=url target=_blank aria-label=zhihu rel="noopener external nofollow noreferrer"></a></div></div><div class=sidebar-menu><div class=sidebar-menu-link-wrap><a class=sidebar-menu-link-dummy href=/ aria-label=Home></a><div class='sidebar-menu-icon icon rotate'>&#xe62b;</div><div class=sidebar-menu-link>Home</div></div><div class=sidebar-menu-link-wrap><a class=sidebar-menu-link-dummy href=/archives aria-label=Archives></a><div class='sidebar-menu-icon icon'>&#xe633;</div><div class=sidebar-menu-link>Archives</div></div><div class=sidebar-menu-link-wrap><a class=sidebar-menu-link-dummy href=/about aria-label=About></a><div class='sidebar-menu-icon icon'>&#xe63d;</div><div class=sidebar-menu-link>About</div></div><div class=sidebar-menu-link-wrap><a class=sidebar-menu-link-dummy href=/friend aria-label=Friend></a><div class='sidebar-menu-icon icon'>&#xe639;</div><div class=sidebar-menu-link>Friend</div></div></div></div></div><div class=sidebar-btn-wrapper><div class="sidebar-toc-btn current"></div><div class=sidebar-common-btn></div></div></nav></div><div class=site-search><div class="reimu-popup popup"><div class=reimu-search><div class=reimu-search-input-icon></div><div class=reimu-search-input id=reimu-search-input></div><div class=popup-btn-close></div></div><div class=reimu-results><div id=reimu-stats></div><div id=reimu-hits></div><div id=reimu-pagination class=reimu-pagination></div></div><img class=reimu-bg src=/images/reimu.png></div></div><script src=https://npm.webcache.cn/lazysizes@5.3.2/lazysizes.min.js integrity=sha384-3gT/vsepWkfz/ff7PpWNUeMzeWoH3cDhm/A8jM7ouoAK0/fP/9bcHHR5kHq2nf+e crossorigin=anonymous></script><script src=https://npm.webcache.cn/clipboard@2.0.11/dist/clipboard.min.js integrity=sha384-J08i8An/QeARD9ExYpvphB8BsyOj3Gh2TSh1aLINKO3L0cMSH2dN3E22zFoXEi0Q crossorigin=anonymous></script><script src=/js/main.js integrity crossorigin=anonymous></script><script src=/js/aos.js integrity crossorigin=anonymous></script><script>var aosInit=()=>{AOS.init({duration:1e3,easing:"ease",once:!0,offset:50})};document.readyState==="loading"?document.addEventListener("DOMContentLoaded",aosInit):aosInit()</script><script src=/js/pjax_main.js integrity crossorigin=anonymous data-pjax></script><script>var ALGOLIA_CONFIG={logo:"/images/algolia_logo.svg",algolia:{applicationID:"E7TXX1S76T",apiKey:"f3def5697bab431015815d63d4289527",indexName:"algolia",hits:{per_page:parseInt("10")},labels:{input_placeholder:"搜索.....",hits_empty:"未发现与 「${query}」相关内容",hits_stats:"找到${hits}条结果（用时 ${time} ms）"}}}</script><script src=https://npm.webcache.cn/algoliasearch@4.17.1/dist/algoliasearch-lite.umd.js defer integrity=sha384-xvLS0jfKuoREs7pqkRI/OI8GcqohO5S+jQz7ZBtQXnsXmD+9jDOOY4cL6dCPzlrk crossorigin=anonymous></script><script src=https://npm.webcache.cn/instantsearch.js@4.56.1/dist/instantsearch.production.min.js defer integrity=sha384-hHJCflT4KBLQyHfKO9vpstIcFKn/Y+KHTORelMMEn7mOp2AVPp+7fr03dLgZiV3J crossorigin=anonymous></script><script src=/js/algolia_search.js integrity crossorigin=anonymous></script><div id=lazy-script><div><script data-pjax>window.REIMU_POST={author:"Bertsin",title:"CMU Proxylab",url:"https://user-xixiboliya.github.io/post/proxylab/",description:"CMU深入理解计算机系统的proxylab，搭建预线程化的并发代理服务器，配有cache。",cover:"https://user-xixiboliya.github.io/images/banner.webp"}</script><script src=/js/insert_highlight.js integrity crossorigin=anonymous data-pjax></script><script type=module data-pjax>
        const PhotoSwipeLightbox = (await safeImport("https:\/\/npm.webcache.cn\/photoswipe@5.4.4\/dist\/photoswipe-lightbox.esm.min.js", "sha384-DiL6M\/gG\u002bwmTxmCRZyD1zee6lIhawn5TGvED0FOh7fXcN9B0aZ9dexSF\/N6lrZi\/")).default;

        const pswp = () => {
          if (_$$('.article-entry a.article-gallery-item').length > 0) {
            new PhotoSwipeLightbox({
              gallery: '.article-entry',
              children: 'a.article-gallery-item',
              pswpModule: () => safeImport("https:\/\/npm.webcache.cn\/photoswipe@5.4.4\/dist\/photoswipe.esm.min.js", "sha384-WkkO3GCmgkC3VQWpaV8DqhKJqpzpF9JoByxDmnV8\u002boTJ7m3DfYEWX1fu1scuS4\u002bs")
            }).init();
          }
          if(_$$('.article-gallery a.article-gallery-item').length > 0) {
            new PhotoSwipeLightbox({
              gallery: '.article-gallery',
              children: 'a.article-gallery-item',
              pswpModule: () => safeImport("https:\/\/npm.webcache.cn\/photoswipe@5.4.4\/dist\/photoswipe.esm.min.js", "sha384-WkkO3GCmgkC3VQWpaV8DqhKJqpzpF9JoByxDmnV8\u002boTJ7m3DfYEWX1fu1scuS4\u002bs")
            }).init();
          }
          window.lightboxStatus = 'done';
          window.removeEventListener('lightbox:ready', pswp);
        }
        if(window.lightboxStatus === 'ready') {
          pswp()
        } else {
          window.addEventListener('lightbox:ready', pswp);
        }
      </script><script src=https://npm.webcache.cn/qrcode@1.4.4/build/qrcode.min.js defer data-pjax integrity=sha384-0RsG1yo/crf/1Qc14sho26SXXOTngNCjgJw7fuvXBt9W/OChF/Ijx+aUuBDqQwEk crossorigin=anonymous></script><script src=https://npm.webcache.cn/html-to-image@1.11.11/dist/html-to-image.js defer data-pjax integrity=sha384-UbfRVKN3/elS1r7JcK2FhmPP+KlJ4CvYwbyYD7tH+uTkbT9bNJr9eJeQ0FoFbAgz crossorigin=anonymous></script></div></div><script src=https://npm.webcache.cn/busuanzi@2.3.0/bsz.pure.mini.js async integrity=sha384-0M75wtSkhjIInv4coYlaJU83+OypaRCIq2SukQVQX04eGTCBXJDuWAbJet56id+S crossorigin=anonymous></script><script>"serviceWorker"in navigator&&navigator.serviceWorker.getRegistrations().then(e=>{for(let t of e)t.unregister()})</script><script>const reimuCopyright=String.raw`
   ______     ______     __     __    __     __  __    
  /\  == \   /\  ___\   /\ \   /\ "-./  \   /\ \/\ \   
  \ \  __<   \ \  __\   \ \ \  \ \ \-./\ \  \ \ \_\ \  
   \ \_\ \_\  \ \_____\  \ \_\  \ \_\ \ \_\  \ \_____\ 
    \/_/ /_/   \/_____/   \/_/   \/_/  \/_/   \/_____/ 
                                                    
  `;console.log(String.raw`%c ${reimuCopyright}`,"color: #ff5252;"),console.log("%c Theme.Reimu %c https://github.com/D-Sketon/hugo-theme-reimu ","color: white; background: #ff5252; padding:5px 0;","padding:4px;border:1px solid #ff5252;")</script></body></html>