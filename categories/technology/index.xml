<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Technology on Welcome to Bertsin Homepage!</title><link>https://user-xixiboliya.github.io/categories/technology/</link><description>Recent content in Technology on Welcome to Bertsin Homepage!</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Wed, 25 Jun 2025 16:00:00 -0723</lastBuildDate><atom:link href="https://user-xixiboliya.github.io/categories/technology/index.xml" rel="self" type="application/rss+xml"/><item><title>Windows-cpp-clang 环境搭建</title><link>https://user-xixiboliya.github.io/post/windows-cpp/</link><pubDate>Wed, 25 Jun 2025 15:00:00 -0718</pubDate><guid>https://user-xixiboliya.github.io/post/windows-cpp/</guid><description>&lt;blockquote>
&lt;p>本文初版参照RM视觉组的msys2-windows-cpp环境搭建教程，并在一定程度上进行了补充。&lt;/p>
&lt;/blockquote>
&lt;p>让我们开始吧。&lt;/p>
&lt;p>首先，欢迎大家了解RC视觉组并学习一些相关知识。在往期培训过程中，我们一般使用linux进行环境配置，但是由于需要了解的知识过于硬核，导致培训效果不太理想。&lt;/p>
&lt;p>因此我们打算先使用windows配置环境并学习核心知识，之后再进行linux/ubuntu22.04环境的过渡。&lt;/p>
&lt;h1 id="环境基础知识">
&lt;a class="header-anchor" href="#%e7%8e%af%e5%a2%83%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86">&lt;/a>
环境基础知识
&lt;/h1>&lt;h2 id="集成开发环境ide">
&lt;a class="header-anchor" href="#%e9%9b%86%e6%88%90%e5%bc%80%e5%8f%91%e7%8e%af%e5%a2%83ide">&lt;/a>
集成开发环境（IDE）
&lt;/h2>&lt;p>集成开发环境本质上是把编写、构建、调试、测试、重构与版本控制等开发工作流所需的工具整合到一个统一界面中，减少来回切换工具的成本，让开发更高效、更可控。对于 C++ 这种语言，IDE 不仅要提供语法高亮和自动补全，还需要与编译器、构建系统和调试器深度集成，以便处理头文件搜索、宏展开、模板实例化和平台相关的差异等复杂问题。&lt;/p>
&lt;p>从功能角度看，一个适合 C++ 的 IDE 通常包含智能补全（基于 language server）、跳转定义/查找引用、重构支持、集成构建与任务系统、强大的调试器（断点、单步、变量/内存查看、核心转储分析）、静态分析与代码格式化（例如 clang-tidy、clang-format）、以及测试框架和版本控制的可视化支持。对于大型或跨平台项目，还希望 IDE 能处理 CMake/meson/bazel 等构建系统的配置，方便在不同平台和不同编译器间切换。&lt;/p>
&lt;p>目前常见的选项各有侧重点：Visual Studio（Windows）在与 MSVC、Windows SDK、性能分析器和图形化调试方面最为成熟，适合开发 Windows 原生应用和大型企业项目；CLion（JetBrains）对 CMake 支持出色，提供强力的重构与代码分析，跨平台但为付费软件；Visual Studio Code（VSCode）则以轻量、免费与扩展生态见长，通过安装插件可以把它变成功能接近传统 IDE 的开发环境，适合希望高度定制或在 Linux/WSL/macOS 上开发的用户。&lt;/p>
&lt;p>推荐把 &lt;strong>VSCode&lt;/strong>当作 C++ 开发工具的原因在于其灵活性：你可以按需安装 language server（如 clangd 或 Microsoft 的 C/C++ 扩展）、CMake Tools、调试适配器（gdb/LLDB 或 Windows 的 cppvsdbg）、以及格式化/静态检查扩展。配合 Remote-WSL、Remote-Containers 或 Dev Containers，可以在容器或 WSL2 中运行实际的构建工具链和调试器，同时在宿主机上享受轻快的编辑体验，这对跨平台开发和保持一致的开发环境特别有益。&lt;/p>
&lt;h1 id="环境变量">
&lt;a class="header-anchor" href="#%e7%8e%af%e5%a2%83%e5%8f%98%e9%87%8f">&lt;/a>
环境变量
&lt;/h1>&lt;p>环境变量是操作系统中用于存储有关系统运行环境的信息的特定名称对象。它们对于指定程序运行的方式和位置至关重要，因为它们可以告诉系统在哪里查找必要的文件和程序。环境变量分为用户变量和系统变量，用户变量仅对当前登录的用户有效，而系统变量对所有用户都有效。一个关于windows环境变量介绍的博客是：&lt;a href="https://zhuanlan.zhihu.com/p/82011100">看懂什么是环境变量! - 知乎&lt;/a>&lt;/p>
&lt;h2 id="搭建环境">
&lt;a class="header-anchor" href="#%e6%90%ad%e5%bb%ba%e7%8e%af%e5%a2%83">&lt;/a>
搭建环境
&lt;/h2>&lt;p>对于c++开发环境，windows下可选择的环境还有visual studio (vs)，dev-c++等，然而vs使用的编译器为MinGW，是linux中使用的gcc编译器的windows移植版。目前mingw-w64位项目目前的状况比较复杂，有多个发行分支，具体可以参看&lt;a href="https://link.zhihu.com/?target=https%3A//www.mingw-w64.org/downloads/">官网的下载页&lt;/a>。目前在windows上最新、最靠谱的发行分支就是&lt;strong>MSYS2&lt;/strong>。&lt;/p></description></item><item><title>RC 网络仓库服务器</title><link>https://user-xixiboliya.github.io/post/rcserver/</link><pubDate>Sun, 25 May 2025 15:00:00 -0718</pubDate><guid>https://user-xixiboliya.github.io/post/rcserver/</guid><description>&lt;h1 id="rc-网络仓库服务介绍">
&lt;a class="header-anchor" href="#rc-%e7%bd%91%e7%bb%9c%e4%bb%93%e5%ba%93%e6%9c%8d%e5%8a%a1%e4%bb%8b%e7%bb%8d">&lt;/a>
RC 网络仓库服务介绍
&lt;/h1>&lt;h2 id="intro-服务是什么">
&lt;a class="header-anchor" href="#intro-%e6%9c%8d%e5%8a%a1%e6%98%af%e4%bb%80%e4%b9%88">&lt;/a>
Intro 服务是什么
&lt;/h2>&lt;p>本文档介绍的对象是一组部署在服务器上，用于RC视觉组共享与传承工作成果的Web服务。主要提供了私有远程git仓库服务(gogs)，文档与博客分享服务(hugo)，与文件下载服务，并最终通过 nginx (读作 Engine X) 集成到服务器的一个端口上。目前，该服务仅通过端口转发的形式，将运行在ROBOCON局域网下的服务器服务端口借由路由器（校园网域）暴露到一个校园网ip，每次路由器重启，校园网中的服务ip都会变化。&lt;/p>
&lt;h2 id="aim-部署目的">
&lt;a class="header-anchor" href="#aim-%e9%83%a8%e7%bd%b2%e7%9b%ae%e7%9a%84">&lt;/a>
Aim 部署目的
&lt;/h2>&lt;ul>
&lt;li>私有远程git仓库服务（以下以 git-service 代称）：核心目的是用于收集视觉组各年工作项目，防止之前的方案随时间丢失。由于github，gitcode等网站的“组织”功能往往需要按时间付费，并且具有人数限制，因此采用 &lt;a href="https://github.com/gogs/gogs/">gogs&lt;/a> 作为队内专用的git仓库。这个服务能够帮助团队协作开发（需要有git使用能力），跟踪各个组员进度。&lt;/li>
&lt;li>文档与博客分享（以下以 doc-service 代称）：鼓励记录分享自己的经验，以及阅读他人的经验。采用 &lt;a href="https://github.com/google/docsy">Docs&lt;/a> 这一仓库，其可以将简单的markdown 文档生成美观的静态网站。&lt;/li>
&lt;li>文件下载服务(以下以 file-service 代称)：除了保存资源文件，还可以把配置好的系统镜像，docker镜像放在里面，这样就可以免去配置环境的烦恼。现在采用的FileBrowser是一个充满bug的程序，打算换其他的。&lt;/li>
&lt;/ul>
&lt;h2 id="description-详细介绍">
&lt;a class="header-anchor" href="#description-%e8%af%a6%e7%bb%86%e4%bb%8b%e7%bb%8d">&lt;/a>
Description 详细介绍
&lt;/h2>&lt;h3 id="ssh-登录">
&lt;a class="header-anchor" href="#ssh-%e7%99%bb%e5%bd%95">&lt;/a>
ssh 登录
&lt;/h3>&lt;p>&lt;img src="image/ip.png" alt="">&lt;/p>
&lt;p>从队里华为路由器登录界面（华为路由器默认局域网ip为192.168.3.1）可以看到，通过有线方式连接的 rc-server 记录其 ip 地址，可以在连接 ROBOCON 局域网的情况下访问服务器。主用户用户名是robocon，密码是qingchun，服务均部署在git用户下，git用户无法直接通过ssh登录，需要登录后切换。ssh 端口经过路由器转发到 22 端口，为了防止枚举用户名与密码破解，通过端口转发方式访问的连接都只能通过 public-key 方式进行登录认证，而无法使用密码登录。使用robocon和git用户登录服务器均需要公钥。&lt;/p>
&lt;p>另外，如果您想从校园网登上服务器，您可以在局域网条件下先查看路由器在校园网下的WAN IP，然后通过该IP登录服务器。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 从robocon用户切换到git用户&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>su git
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="git-service">
&lt;a class="header-anchor" href="#git-service">&lt;/a>
git-service
&lt;/h3>&lt;p>SOURCE:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/gogs/gogs/">&lt;!-- raw HTML omitted -->github 仓库地址&lt;!-- raw HTML omitted -->&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gogs.io/docs/">&lt;!-- raw HTML omitted -->中文文档&lt;!-- raw HTML omitted -->&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.bookstack.cn/read/gogs_zh/advanced-configuration_cheat_sheet.md">&lt;!-- raw HTML omitted -->custom/conf/app.ini配置文件解释&lt;!-- raw HTML omitted -->&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.csdn.net/helloxiaozhe/article/details/134348522">&lt;!-- raw HTML omitted -->简单CSDN安装教程&lt;!-- raw HTML omitted -->&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.csdn.net/qq_36025814/article/details/122272936">&lt;!-- raw HTML omitted -->详细CSDN安装教程&lt;!-- raw HTML omitted -->&lt;/a>&lt;/li>
&lt;/ul>
&lt;h4 id="下载安装与首次配置">
&lt;a class="header-anchor" href="#%e4%b8%8b%e8%bd%bd%e5%ae%89%e8%a3%85%e4%b8%8e%e9%a6%96%e6%ac%a1%e9%85%8d%e7%bd%ae">&lt;/a>
下载安装与首次配置
&lt;/h4>&lt;p>按照 &lt;em>中文文档&lt;/em> 中的 &lt;a href="https://gogs.io/docs/installation">&lt;!-- raw HTML omitted -->下载安装-环境要求&lt;!-- raw HTML omitted -->&lt;/a> 配置依赖后，按照 &lt;a href="https://gogs.io/docs/installation/install_from_binary">&lt;!-- raw HTML omitted -->下载安装-二进制安装/源码安装/包管理安装&lt;!-- raw HTML omitted -->&lt;/a> 中的任意一种方式进行安装(推荐使用压缩包安装)，然后使用命令行运行&amp;quot;./gogs web&amp;quot;(压缩包安装)，第一次启动服务，会在&lt;a href="http://localhost:3000/install">http://localhost:3000/install&lt;/a>上启动配置安装界面，类似如下：&lt;/p></description></item><item><title>2025XJTU AI系统复习</title><link>https://user-xixiboliya.github.io/post/ai_system%E5%A4%8D%E4%B9%A0/</link><pubDate>Thu, 01 May 2025 15:00:00 -0710</pubDate><guid>https://user-xixiboliya.github.io/post/ai_system%E5%A4%8D%E4%B9%A0/</guid><description>&lt;h1 id="深度神经网络基础">
&lt;a class="header-anchor" href="#%e6%b7%b1%e5%ba%a6%e7%a5%9e%e7%bb%8f%e7%bd%91%e7%bb%9c%e5%9f%ba%e7%a1%80">&lt;/a>
深度神经网络基础
&lt;/h1>&lt;h2 id="早期的深度学习框架">
&lt;a class="header-anchor" href="#%e6%97%a9%e6%9c%9f%e7%9a%84%e6%b7%b1%e5%ba%a6%e5%ad%a6%e4%b9%a0%e6%a1%86%e6%9e%b6">&lt;/a>
早期的深度学习框架
&lt;/h2>&lt;p>主要用来CNN网络图像识别，由一些常用的layers组成。
主要特点就是通过.yaml这样的配置文件定义神经网络，可由一些常用的layer构成一个简单的图，支持多设备加速，代表框架是由UCB提出的Caffe。&lt;/p>
&lt;h3 id="基于数据流图dag的计算框架">
&lt;a class="header-anchor" href="#%e5%9f%ba%e4%ba%8e%e6%95%b0%e6%8d%ae%e6%b5%81%e5%9b%bedag%e7%9a%84%e8%ae%a1%e7%ae%97%e6%a1%86%e6%9e%b6">&lt;/a>
基于数据流图DAG的计算框架
&lt;/h3>&lt;ul>
&lt;li>基本数据结构是tensor&lt;/li>
&lt;li>基本运算单元接收N个输入tensor，输出M个tensor。 tensorflow中有大于400个基本的operator
在数据流图中，&lt;strong>节点&lt;/strong>表示&lt;code>operator&lt;/code>，&lt;strong>边&lt;/strong>表示&lt;code>tensor&lt;/code>。有一些特殊的节点用来构建控制流，控制边用来表示节点之间的依赖关系。&lt;/li>
&lt;/ul>
&lt;h4 id="静态数据流图tensorflow">
&lt;a class="header-anchor" href="#%e9%9d%99%e6%80%81%e6%95%b0%e6%8d%ae%e6%b5%81%e5%9b%betensorflow">&lt;/a>
静态数据流图TensorFlow
&lt;/h4>&lt;p>先定义后执行，静态图表示在编译时首先生成神经网络的结构，然后再执行对应的操作。&lt;/p>
&lt;ul>
&lt;li>静态图定义图后可以全局图优化&lt;/li>
&lt;/ul>
&lt;h4 id="动态数据流图pytorch">
&lt;a class="header-anchor" href="#%e5%8a%a8%e6%80%81%e6%95%b0%e6%8d%ae%e6%b5%81%e5%9b%bepytorch">&lt;/a>
动态数据流图pytorch
&lt;/h4>&lt;p>边定义边运行，每次编译时都需要构建一个新的计算图。&lt;/p>
&lt;p>&lt;strong>计算流图&lt;/strong>：引入中间变量将复杂的函数分解成一系列基本函数，构成计算流图。&lt;/p>
&lt;h3 id="自动求导">
&lt;a class="header-anchor" href="#%e8%87%aa%e5%8a%a8%e6%b1%82%e5%af%bc">&lt;/a>
自动求导
&lt;/h3>&lt;p>前向计算并且保留计算结果，有个主要问题是需要保存大量的计算结果。在导数的计算也可以表示成数据流图。方便全局图优化与节省内存。&lt;/p>
&lt;p>现代大部分框架同时提供：&lt;/p>
&lt;ul>
&lt;li>自动求导系统，针对常见函数的组合&lt;/li>
&lt;li>大量内置的Operators和与之对应的反向函数&lt;/li>
&lt;li>为用户提供接口，自己提供反向函数。&lt;/li>
&lt;/ul>
&lt;h3 id="图优化">
&lt;a class="header-anchor" href="#%e5%9b%be%e4%bc%98%e5%8c%96">&lt;/a>
图优化
&lt;/h3>&lt;p>先定义后执行的模式允许框架在计算前看到全图信息。数据流图作为深度学习框架中的高层中间表示，可以允许任何等价图优化Pass去化简计算流图或提高执行效率。&lt;/p>
&lt;h4 id="图优化demm自动融合">
&lt;a class="header-anchor" href="#%e5%9b%be%e4%bc%98%e5%8c%96demm%e8%87%aa%e5%8a%a8%e8%9e%8d%e5%90%88">&lt;/a>
图优化：DEMM自动融合
&lt;/h4>&lt;p>参考文章：&lt;a href="https://zhuanlan.zhihu.com/p/435908830">深入浅出GPU优化系列：GEMM优化（一） - 知乎&lt;/a>&lt;/p>
&lt;h4 id="计算内核与多硬件支持">
&lt;a class="header-anchor" href="#%e8%ae%a1%e7%ae%97%e5%86%85%e6%a0%b8%e4%b8%8e%e5%a4%9a%e7%a1%ac%e4%bb%b6%e6%94%af%e6%8c%81">&lt;/a>
计算内核与多硬件支持
&lt;/h4>&lt;p>&lt;code>kernel&lt;/code>定义了一个算子在某种具体设备的计算实现。&lt;/p>
&lt;p>每个operator都可以注册多个kernel，取决于数据类型、计算设备不同。runtime框架会自动根据operator的设备类型，数据类型和属性选择对应的kernel来执行。&lt;/p>
&lt;p>一段反向传播代码：
$\sum({x}*{y})+{z} = c$&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> numpy &lt;span style="color:#66d9ef">as&lt;/span> np
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>N,D &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span>,&lt;span style="color:#ae81ff">4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>x &lt;span style="color:#f92672">=&lt;/span> np&lt;span style="color:#f92672">.&lt;/span>random&lt;span style="color:#f92672">.&lt;/span>randn(N,D)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>y &lt;span style="color:#f92672">=&lt;/span> np&lt;span style="color:#f92672">.&lt;/span>random&lt;span style="color:#f92672">.&lt;/span>randn(N,D)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>z &lt;span style="color:#f92672">=&lt;/span> np&lt;span style="color:#f92672">.&lt;/span>random&lt;span style="color:#f92672">.&lt;/span>randn(N,D)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a &lt;span style="color:#f92672">=&lt;/span> x &lt;span style="color:#f92672">*&lt;/span> y
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>b &lt;span style="color:#f92672">=&lt;/span> a &lt;span style="color:#f92672">+&lt;/span> z
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>c &lt;span style="color:#f92672">=&lt;/span> np&lt;span style="color:#f92672">.&lt;/span>sum(b)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>grad_c &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1.0&lt;/span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>grad_b &lt;span style="color:#f92672">=&lt;/span> grad_c &lt;span style="color:#f92672">*&lt;/span> np&lt;span style="color:#f92672">.&lt;/span>ones((N,D))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>grad_a &lt;span style="color:#f92672">=&lt;/span> grad_b&lt;span style="color:#f92672">.&lt;/span>copy()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>grad_z &lt;span style="color:#f92672">=&lt;/span> grad_b&lt;span style="color:#f92672">.&lt;/span>copy()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>grad_x &lt;span style="color:#f92672">=&lt;/span> grad_a &lt;span style="color:#f92672">*&lt;/span> y
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>grad_y &lt;span style="color:#f92672">=&lt;/span> grad_a &lt;span style="color:#f92672">*&lt;/span> x
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里给出$grad_{x}$和$grad_{y}$的求解:
&lt;img src="output_image/e54e60ea41b6c5166c8077b3778e51a1.png" alt="">&lt;/p></description></item><item><title>2025XJTU AI系统实验</title><link>https://user-xixiboliya.github.io/post/ai_system/</link><pubDate>Tue, 01 Apr 2025 15:00:00 -0710</pubDate><guid>https://user-xixiboliya.github.io/post/ai_system/</guid><description>&lt;h1 id="xjtu-ai-system-experiments-2025">
&lt;a class="header-anchor" href="#xjtu-ai-system-experiments-2025">&lt;/a>
XJTU AI system Experiments 2025
&lt;/h1>&lt;p>本仓库内容与Microsoft的AI System融合紧密，为其附属作业。这里有基本的作业项目Microsoft AI System Github、课程概述&lt;/p>
&lt;p>&lt;strong>详情请见代码仓库&lt;/strong>&lt;a href="https://github.com/user-xixiboliya/ai_system_HW">AI System&lt;/a>&lt;/p>
&lt;h2 id="menu">
&lt;a class="header-anchor" href="#menu">&lt;/a>
Menu
&lt;/h2>&lt;ul>
&lt;li>&lt;a href="https://github.com/user-xixiboliya/ai_system_HW/ai%20system%20assignment1/README.md">assignment1 深度学习框架入门&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/user-xixiboliya/ai_system_HW/ai%20system%20assignment2/README.md">assignment2 自定义pytorch算子&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/user-xixiboliya/ai_system_HW/ai%20system%20assignment3/README.md">assignment3 NNI自动调参&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/user-xixiboliya/ai_system_HW/ai%20system%20assignment4/README.md">assignment4 分布式训练&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/user-xixiboliya/ai_system_HW/ai%20system%20assignment5/README.md">assignment5 容器化部署&lt;/a>
TODO&amp;hellip;&lt;/li>
&lt;/ul></description></item><item><title>daemon 与 服务</title><link>https://user-xixiboliya.github.io/post/daemon%E5%B0%8F%E8%AE%B0/</link><pubDate>Thu, 20 Feb 2025 00:00:00 +0000</pubDate><guid>https://user-xixiboliya.github.io/post/daemon%E5%B0%8F%E8%AE%B0/</guid><description>&lt;blockquote>
&lt;p>本文内容有待完善。&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>daemon，字面上意思为“守护神、恶魔”，通常没有 GUI 界面，是 Unix/Linux 环境的典型产物。具体表现为后台运行、不与终端交互的单个进程，是一种技术实现方式。&lt;/li>
&lt;li>service，简单来说是系统为了实现某些功能必须要提供的一些服务，由系统服务管理器定义和管理的 entity，可以包含 daemon，具备依赖、失败处理等高级特性。&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>简言之：&lt;strong>“所有 service 都有 daemon，但不一定所有 daemon 都是 service”&lt;/strong>。&lt;/p>
&lt;/blockquote>
&lt;p>当然， 读者并不需要将daemon与service区分得如此细致。一般来说，在一个服务被建立之后，linux使用时，通常会在服务的名称之后加上&lt;code>d&lt;/code>，例如&lt;code>atd&lt;/code>，这个&lt;code>d&lt;/code>代表&lt;code>daemon&lt;/code>的意思。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>xixiboliya@laptop-tex4-of-boxing:~$ systemctl list-units --type&lt;span style="color:#f92672">=&lt;/span>service --state&lt;span style="color:#f92672">=&lt;/span>active --no-pager | grep &lt;span style="color:#e6db74">&amp;#39;d\.service&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> snapd.seeded.service loaded active exited Wait &lt;span style="color:#66d9ef">until&lt;/span> snapd is fully seeded
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> snapd.service loaded active running Snap Daemon
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> systemd-journald.service loaded active running Journal Service
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> systemd-logind.service loaded active running User Login Management
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> systemd-resolved.service loaded active running Network Name Resolution
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> systemd-udevd.service loaded active running Rule-based Manager &lt;span style="color:#66d9ef">for&lt;/span> Device Events and Files
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="通过systemctl-查看单一服务">
&lt;a class="header-anchor" href="#%e9%80%9a%e8%bf%87systemctl-%e6%9f%a5%e7%9c%8b%e5%8d%95%e4%b8%80%e6%9c%8d%e5%8a%a1">&lt;/a>
通过systemctl 查看单一服务
&lt;/h2>&lt;p>一般来说服务的启动有两个阶段，一个是开机的时候设置要不要启动这个服务，以及你现在要不要启动这个服务。查看服务树：&lt;code>systemctl status&lt;/code>，找到其中一个服务进行解析：&lt;/p></description></item><item><title>CMU Proxylab</title><link>https://user-xixiboliya.github.io/post/proxylab/</link><pubDate>Sat, 25 Jan 2025 15:00:00 -0718</pubDate><guid>https://user-xixiboliya.github.io/post/proxylab/</guid><description>&lt;p>本文的所有配置、指令均以 Ubuntu 环境为例，而且假设你不具有桌面环境，只有纯命令行环境。&lt;/p>
&lt;h1 id="pre-start">
&lt;a class="header-anchor" href="#pre-start">&lt;/a>
Pre-start
&lt;/h1>&lt;p>在工作目录下解压&lt;code>proxylab - handout.tar&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>tar -xvf proxylab-handout.tar 
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>-x&lt;/code>：表示提取文件，也就是解压操作。&lt;/li>
&lt;li>&lt;code>-v&lt;/code>：用于显示详细的解压过程，方便你了解解压的进度和具体文件。&lt;/li>
&lt;li>&lt;code>-f&lt;/code>：指定要处理的文件名，后面紧跟要解压的 &lt;code>.tar&lt;/code> 文件的名称。&lt;/li>
&lt;/ul>
&lt;p>以下是简要介绍，本文的根工作空间是&lt;code>proxylab-handout&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>proxylab-handout
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── Makefile
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── README
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── csapp.c
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>|—— cache.c //自行编写的cache
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>|—— cache.h //自行编写的chche
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>|—— proxy.h
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── csapp.h
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── driver.sh //简单自动评分程序。进行基本的合理性检查。
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── free-port.sh
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── nop-server.py
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── port-for-user.pl //给出偶数端口号，以便和Tiny web server 进行 testing。
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── proxy.c //打印出一个特定的 HTTP &lt;span style="color:#e6db74">`&lt;/span>User-Agent&lt;span style="color:#e6db74">`&lt;/span> 头部信息到标准输出。用于标识客户端软件的类型和版本，服务器可以根据这个信息来提供不同的服务或内容。
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>└── tiny //tiny服务器
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="环境配置">
&lt;a class="header-anchor" href="#%e7%8e%af%e5%a2%83%e9%85%8d%e7%bd%ae">&lt;/a>
环境配置
&lt;/h2>&lt;p>配置linux 版本的chrome 和 chrome driver 。两者版本需对应，还有自动化测试工具Selenium，参考[Arthals&amp;rsquo;ink环境配置](&lt;a href="https://arthals.ink/blog/proxy-lab#%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE">更适合北大宝宝体质的 Proxy Lab 踩坑记 • Arthals&amp;rsquo; ink&lt;/a>)&lt;/p></description></item><item><title>CMU CSAPP bomblab phase1 ~ phase5 解答</title><link>https://user-xixiboliya.github.io/post/bomblab/</link><pubDate>Mon, 20 Jan 2025 00:00:00 +0000</pubDate><guid>https://user-xixiboliya.github.io/post/bomblab/</guid><description>&lt;h1 id="写在前面">
&lt;a class="header-anchor" href="#%e5%86%99%e5%9c%a8%e5%89%8d%e9%9d%a2">&lt;/a>
写在前面
&lt;/h1>&lt;p>贴一个下载链接&lt;a href="https://csapp.cs.cmu.edu/3e/labs.html">CS:APP3e, Bryant and O&amp;rsquo;Hallaron (cmu.edu)&lt;/a>，点击&lt;a href="https://csapp.cs.cmu.edu/3e/bomb.tar">Self-Study Handout&lt;/a>下载lab。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/* Do all sorts of secret stuff that makes the bomb harder to defuse. */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">initialize_bomb&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Welcome to my fiendish little bomb. You have 6 phases with&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;which to blow yourself up. Have a nice day!&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/* Hmm... Six phases must be more secure than one phase! */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> input &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">read_line&lt;/span>(); &lt;span style="color:#75715e">/* Get input */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">phase_1&lt;/span>(input); &lt;span style="color:#75715e">/* Run the phase */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">phase_defused&lt;/span>(); &lt;span style="color:#75715e">/* Drat! They figured it out!
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在进入到&lt;code>phase_1&lt;/code>之前，对于&lt;code>input = read_line()&lt;/code>函数，我们查看一下input变量的地址，使用&lt;code>gdb bomb&lt;/code>命令进入gdb调试阶段，再通过查看反汇编代码确定&lt;code>input = read_line()&lt;/code>函数return时的栈顶指针&lt;code>%rsp&lt;/code>所指向的内容，先设置断点，为了方便，使用&lt;code>touch ~/.gdbinit&lt;/code>命令创建一个默认配置，具体可以参考&lt;a href="https://arthals.ink/blog/bomb-lab">这个链接&lt;/a>。&lt;/p></description></item><item><title>docker与dev container插件的使用</title><link>https://user-xixiboliya.github.io/post/docker/</link><pubDate>Mon, 20 Jan 2025 00:00:00 +0000</pubDate><guid>https://user-xixiboliya.github.io/post/docker/</guid><description>&lt;blockquote>
&lt;p>本文侧重1.讲解docker的插件使用。2.视觉consimulation项目的跨环境迁移&lt;/p>
&lt;/blockquote>
&lt;h1 id="基础配置">
&lt;a class="header-anchor" href="#%e5%9f%ba%e7%a1%80%e9%85%8d%e7%bd%ae">&lt;/a>
基础配置
&lt;/h1>&lt;ul>
&lt;li>安装vscode。&lt;/li>
&lt;li>在vscode安装 Docker 插件与ms-vscode-remote.remote-containers插件。&lt;/li>
&lt;/ul>
&lt;h1 id="docker-学习">
&lt;a class="header-anchor" href="#docker-%e5%ad%a6%e4%b9%a0">&lt;/a>
Docker 学习
&lt;/h1>&lt;p>这里可以参考：&lt;a href="https://ruanyifeng.com/blog/2018/02/docker-tutorial.html">阮一峰docker教程&lt;/a>、&lt;a href="https://www.runoob.com/docker/docker-tutorial.html">菜鸟教程docker&lt;/a>、&lt;a href="https://www.cnblogs.com/codelove/p/10606434.html">雪雁docker&lt;/a>&lt;/p>
&lt;blockquote>
&lt;p>容器container是镜像image的实例化。&lt;/p>
&lt;/blockquote>
&lt;h1 id="生成-dockerfile">
&lt;a class="header-anchor" href="#%e7%94%9f%e6%88%90-dockerfile">&lt;/a>
生成 dockerfile
&lt;/h1>&lt;blockquote>
&lt;p>一种途径是自行编写dockerfile，另一种途径是使用插件自动生成再进行修改。&lt;/p>
&lt;/blockquote>
&lt;p>dockerfile的编写：&lt;a href="https://zhuanlan.zhihu.com/p/79949030">知乎&lt;/a>、&lt;a href="https://blog.csdn.net/x1131230123/article/details/135769591">CSDN&lt;/a>&lt;/p>
&lt;p>无论是自行编写还是自动生成，需要知道的是，镜像&lt;code>image&lt;/code>是由多个“层”组成的。每一层都是镜像构建过程中的一个步骤，每次 Docker 执行一个命令（例如 RUN、COPY、ADD 等）时，都会生成一个新的层。这些层共同构成了 &lt;code>Docker&lt;/code> 镜像的内容。就使用&lt;code>dev container&lt;/code>而言，&lt;code>dockerfile&lt;/code>应该仅包含环境配置，不应该包含对应的项目功能代码包。&lt;/p>
&lt;p>自动生成示例：&lt;/p>
&lt;p>使用Docker扩展可以非常方便的从VisualStudio Code构建，管理和部署容器化应用程序，可以自动生成dockerfile、docker-compose.yml和.dockerignore文件（按F1并搜索Docker：将Docker文件添加到Workspace）
&lt;img src="image-6.png" alt="alt text">&lt;/p>
&lt;ul>
&lt;li>&lt;code>Add Docker Files to Workspace&lt;/code>用于生成一个单独的 Docker 配置文件（Dockerfile）和与之配套的基础配置文件。可能还会生成与应用环境相关的文件，例如 .dockerignore。&lt;/li>
&lt;li>&lt;code>Add Docker Compose Files to Workspace&lt;/code> 用于生成支持多服务编排的 Docker Compose 配置文件（docker-compose.yml）。如果你的项目需要多个服务（例如后端服务、数据库服务、缓存服务）共同运行，这是更适合的选项。&lt;/li>
&lt;/ul>
&lt;p>接着：根据项目选择基本配置，由于不同项目需要配置不同，跟着导引选择。
&lt;img src="image-7.png" alt="alt text">&lt;/p>
&lt;ul>
&lt;li>&lt;code>ASP.NET Core&lt;/code> 是用于构建 Web 应用程序的跨平台框架，适用于构建现代化的 Web 服务和应用。它支持 HTTP 请求处理、Web API、WebSocket、以及其他网络相关的功能。&lt;/li>
&lt;li>&lt;code>Console&lt;/code> 应用是一个基于命令行界面的应用程序，通常用于执行后台任务、处理批量操作、定时任务等。&lt;/li>
&lt;/ul>
&lt;p>这些信息自行GPT即可。&lt;/p>
&lt;h1 id="build">
&lt;a class="header-anchor" href="#build">&lt;/a>
build
&lt;/h1>&lt;p>上面步骤完成之后，你的项目会有&lt;code>dockerfile&lt;/code>和&lt;code>.dockerignore&lt;/code>，或许会有&lt;code>docker-compose.debug.yml&lt;/code>、&lt;code>docker-compose.yml&lt;/code>。&lt;/p>
&lt;p>在资源管理器中选中&lt;code>dockerfile&lt;/code>并且右键点击，找到&lt;code>build image..&lt;/code>选项，接着输入&amp;lt;镜像名&amp;gt;:&amp;lt;标签&amp;gt;
&lt;img src="image.png" alt="alt text">&lt;/p></description></item><item><title>存储系统基础</title><link>https://user-xixiboliya.github.io/post/%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E5%9F%BA%E7%A1%80/</link><pubDate>Fri, 17 Jan 2025 00:00:00 +0000</pubDate><guid>https://user-xixiboliya.github.io/post/%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E5%9F%BA%E7%A1%80/</guid><description>&lt;p>存储系统分为四类：&lt;/p>
&lt;ul>
&lt;li>单机存储 File-system Key-Value&lt;/li>
&lt;li>单机数据库 关系型和非关系型&lt;/li>
&lt;li>分布式存储 分布式文件系统GFS HDFS等 对象存储TOS&lt;/li>
&lt;li>分布式数据库：关系型(MySQL Oracle)和非关系型数据库
&lt;img src="attachment/2fe4cb8f650425e13a28cea09cab648c.png" alt="">&lt;/li>
&lt;/ul>
&lt;h1 id="分布式存储选型">
&lt;a class="header-anchor" href="#%e5%88%86%e5%b8%83%e5%bc%8f%e5%ad%98%e5%82%a8%e9%80%89%e5%9e%8b">&lt;/a>
分布式存储选型
&lt;/h1>&lt;p>&lt;img src="attachment/ea14c570671bd78031d891aa1ae06de6.png" alt="">
&lt;img src="attachment/544c6d6234371abea3cc0ed7edecd847.png" alt="">
在TOS中，所有的数据都存储在“桶”中。桶是容器，可以理解为用于组织存储对象的命名空间。每个桶都具有唯一的名字，并可以设置权限来控制谁可以访问。
&lt;img src="attachment/306e5e5c965c370fefe58da2883ab8ee.png" alt="">&lt;/p>
&lt;h1 id="存储对象使用">
&lt;a class="header-anchor" href="#%e5%ad%98%e5%82%a8%e5%af%b9%e8%b1%a1%e4%bd%bf%e7%94%a8">&lt;/a>
存储对象使用
&lt;/h1>&lt;p>先在TOS上申请一个Bucket，里面可以存放很多objects。此外，TOS提供了丰富的RESTful API，可以实现文件的上传、下载、删除、查询等操作。&lt;/p>
&lt;p>对象存储对外提供的一般都是Restful风格的接口。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>restful风格&lt;span style="color:#960050;background-color:#1e0010">：&lt;/span>[&lt;span style="color:#960050;background-color:#1e0010">参考链接&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>](https:&lt;span style="color:#75715e">//zhuanlan.zhihu.com/p/334809573)、[参考链接2](https://www.runoob.com/w3cnote/restful-architecture.html)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">以资源为基础&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">：资源可以是一个图片、音乐、一个&lt;/span>XML格式&lt;span style="color:#960050;background-color:#1e0010">、&lt;/span>HTML格式或者JSON格式等网络上的一个实体&lt;span style="color:#960050;background-color:#1e0010">，除了一些二进制的资源外普通的文本资源更多以&lt;/span>JSON为载体&lt;span style="color:#960050;background-color:#1e0010">、面向用户的一组数据&lt;/span>(&lt;span style="color:#960050;background-color:#1e0010">通常从数据库中查询而得到&lt;/span>)&lt;span style="color:#960050;background-color:#1e0010">。&lt;/span>RESTful风格的API则要求在URL上都以名词的方式出现&lt;span style="color:#960050;background-color:#1e0010">，从几种请求方式上就可以看出想要进行的操作，这点与非&lt;/span>RESTful风格的API形成鲜明对比&lt;span style="color:#960050;background-color:#1e0010">。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">统一接口&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">对资源的操作包括获取、创建、修改和删除，这些操作正好对应&lt;/span>HTTP协议提供的GET&lt;span style="color:#960050;background-color:#1e0010">、&lt;/span>POST&lt;span style="color:#960050;background-color:#1e0010">、&lt;/span>PUT和DELETE方法&lt;span style="color:#960050;background-color:#1e0010">。换言而知，使用&lt;/span>RESTful风格的接口但从接口上你可能只能定位其资源&lt;span style="color:#960050;background-color:#1e0010">，但是无法知晓它具体进行了什么操作，需要具体了解其发生了什么操作动作要从其&lt;/span>HTTP请求方法类型上进行判断&lt;span style="color:#960050;background-color:#1e0010">。具体的&lt;/span>HTTP方法和方法含义如下&lt;span style="color:#960050;background-color:#1e0010">：&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">-&lt;/span> GET&lt;span style="color:#960050;background-color:#1e0010">（&lt;/span>SELECT&lt;span style="color:#960050;background-color:#1e0010">）：从服务器取出资源（一项或多项）。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">-&lt;/span> POST&lt;span style="color:#960050;background-color:#1e0010">（&lt;/span>CREATE&lt;span style="color:#960050;background-color:#1e0010">）：在服务器新建一个资源。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">-&lt;/span> PUT&lt;span style="color:#960050;background-color:#1e0010">（&lt;/span>UPDATE&lt;span style="color:#960050;background-color:#1e0010">）：在服务器更新资源（客户端提供完整资源数据）。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">-&lt;/span> PATCH&lt;span style="color:#960050;background-color:#1e0010">（&lt;/span>UPDATE&lt;span style="color:#960050;background-color:#1e0010">）：在服务器更新资源（客户端提供需要修改的资源数据）。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">-&lt;/span> DELETE&lt;span style="color:#960050;background-color:#1e0010">（&lt;/span>DELETE&lt;span style="color:#960050;background-color:#1e0010">）：从服务器删除资源。&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="attachment/2c1b089c1aeef36efa097e0a7e31e4b5.png" alt="">&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@PutMapping&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/dogs/{id}&amp;#34;&lt;/span>) &lt;span style="color:#75715e">//`@PutMapping(&amp;#34;/dogs/{id}&amp;#34;)`：这是Spring注解，它将HTTP请求（路径为`/dogs/{id}`的PUT请求）与 `updateDog()` 方法绑定。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> ResponseEntity&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">updateDog&lt;/span>(&lt;span style="color:#a6e22e">@PathVariable&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> id, &lt;span style="color:#a6e22e">@RequestBody&lt;/span> Dog dog) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dog.&lt;span style="color:#a6e22e">setId&lt;/span>(id); &lt;span style="color:#75715e">// 设置ID&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">boolean&lt;/span> isSuccess &lt;span style="color:#f92672">=&lt;/span> dogMapper.&lt;span style="color:#a6e22e">updateDog&lt;/span>(dog);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (isSuccess) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ResponseEntity&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Dog updated successfully&amp;#34;&lt;/span>, HttpStatus.&lt;span style="color:#a6e22e">OK&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ResponseEntity&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Failed to update dog&amp;#34;&lt;/span>, HttpStatus.&lt;span style="color:#a6e22e">BAD_REQUEST&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} 
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="multiupload-接口">
&lt;a class="header-anchor" href="#multiupload-%e6%8e%a5%e5%8f%a3">&lt;/a>
MultiUpload 接口
&lt;/h2>&lt;p>对于GB数据大对象：
&lt;img src="attachment/d5ba229bc15946a82b98b3fd154f5022.png" alt="">&lt;/p></description></item><item><title>Git 相关</title><link>https://user-xixiboliya.github.io/post/git%E7%9B%B8%E5%85%B3/</link><pubDate>Wed, 15 Jan 2025 00:00:00 +0000</pubDate><guid>https://user-xixiboliya.github.io/post/git%E7%9B%B8%E5%85%B3/</guid><description>&lt;p>本文前半部分较为基础，后半部分对&lt;code>.git&lt;/code>目录下进行了相关的解释。&lt;/p>
&lt;h2 id="基本命令">
&lt;a class="header-anchor" href="#%e5%9f%ba%e6%9c%ac%e5%91%bd%e4%bb%a4">&lt;/a>
基本命令
&lt;/h2>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>cd : 改变目录
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cd .. 退回到上级目录
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cd &lt;span style="color:#f92672">(&lt;/span>filename&lt;span style="color:#f92672">)&lt;/span>进入文件夹
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pwd 显示当前目录
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>clear 清屏
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ls 显示当前目录下的所有文件
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>touch （文件名.后缀） 新建一个文件
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rm （文件名.后缀） 删除一个文件
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mkdir test 建立一个test目录
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rm -r test 删除test
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mv index.txt test 移动index至test中
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>history 查看历史命令
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>help 帮助
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>exit 退出
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="git项目基础">
&lt;a class="header-anchor" href="#git%e9%a1%b9%e7%9b%ae%e5%9f%ba%e7%a1%80">&lt;/a>
git项目基础
&lt;/h2>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>cd /path/to/your/project &lt;span style="color:#75715e"># 进入项目目录 &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git init &lt;span style="color:#75715e"># 初始化 Git 仓库 &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git add . &lt;span style="color:#75715e"># 添加所有文件到暂存区 &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git commit -m &lt;span style="color:#e6db74">&amp;#34;initial commit&amp;#34;&lt;/span> &lt;span style="color:#75715e"># 提交文件 &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git remote add origin https://github.com/your_username/your_repository.git &lt;span style="color:#75715e"># 添加远程仓库 &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git branch -M main 将本地主分支设置为main
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git checkout -b new-branch &lt;span style="color:#75715e"># 创建并切换到新分支&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git push -u origin new-branch &lt;span style="color:#75715e"># 推送到新分支&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>内容过于基础，不再赘述。
&lt;img src="imgs/github.png" alt="">&lt;/p></description></item><item><title>Linux/ubuntu VPN教程</title><link>https://user-xixiboliya.github.io/post/vpn%E6%95%99%E7%A8%8B/</link><pubDate>Thu, 14 Nov 2024 00:00:00 +0000</pubDate><guid>https://user-xixiboliya.github.io/post/vpn%E6%95%99%E7%A8%8B/</guid><description>&lt;h2 id="ubuntu-2204-vpn配置教程">
&lt;a class="header-anchor" href="#ubuntu-2204-vpn%e9%85%8d%e7%bd%ae%e6%95%99%e7%a8%8b">&lt;/a>
Ubuntu 22.04 VPN配置教程
&lt;/h2>&lt;hr>
&lt;p>ubuntu版本不同其实差别不是很大。&lt;/p>
&lt;h4 id="步骤一建立clash文件夹并导入安装包">
&lt;a class="header-anchor" href="#%e6%ad%a5%e9%aa%a4%e4%b8%80%e5%bb%ba%e7%ab%8bclash%e6%96%87%e4%bb%b6%e5%a4%b9%e5%b9%b6%e5%af%bc%e5%85%a5%e5%ae%89%e8%a3%85%e5%8c%85">&lt;/a>
步骤一：建立clash文件夹并导入安装包
&lt;/h4>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>mkdir clash
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cd clash
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>之后在本仓库下载&lt;code>clashpremium-release-linux-amd64.s1lSU-Ho.tar.gz&lt;/code>导入到&lt;code>~/clash/&lt;/code>路径下，换言之，就是将安装包放置在&lt;code>clash&lt;/code>文件夹里面，之后解压该文件，并修改命名为&lt;code>clash&lt;/code>&lt;/p>
&lt;pre tabindex="0">&lt;code>bash
tar -xzvf clashpremium-release-linux-amd64.s1lSU-Ho.tar.gz.tar.gz
&lt;/code>&lt;/pre>&lt;h4 id="步骤二配置vpn参数文件">
&lt;a class="header-anchor" href="#%e6%ad%a5%e9%aa%a4%e4%ba%8c%e9%85%8d%e7%bd%aevpn%e5%8f%82%e6%95%b0%e6%96%87%e4%bb%b6">&lt;/a>
步骤二：配置VPN参数文件
&lt;/h4>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>wget -O config.yaml &lt;span style="color:#e6db74">&amp;#34;https://cqd4w.no-mad-world.club/link/JMdr9H6ofZOHDvJO?clash=3&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="步骤三执行配置命令实现启动clash和vpn代理">
&lt;a class="header-anchor" href="#%e6%ad%a5%e9%aa%a4%e4%b8%89%e6%89%a7%e8%a1%8c%e9%85%8d%e7%bd%ae%e5%91%bd%e4%bb%a4%e5%ae%9e%e7%8e%b0%e5%90%af%e5%8a%a8clash%e5%92%8cvpn%e4%bb%a3%e7%90%86">&lt;/a>
步骤三：执行配置命令实现启动clash和VPN代理
&lt;/h4>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>chmod +x clash
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>./clash -d . 
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>执行效果图如下所示：
&lt;img src="imgs/clash_results.png" alt="clash_results image">&lt;/p>
&lt;h4 id="步骤四购买机场提供的稳定vpn并修改设置网络参数">
&lt;a class="header-anchor" href="#%e6%ad%a5%e9%aa%a4%e5%9b%9b%e8%b4%ad%e4%b9%b0%e6%9c%ba%e5%9c%ba%e6%8f%90%e4%be%9b%e7%9a%84%e7%a8%b3%e5%ae%9avpn%e5%b9%b6%e4%bf%ae%e6%94%b9%e8%ae%be%e7%bd%ae%e7%bd%91%e7%bb%9c%e5%8f%82%e6%95%b0">&lt;/a>
步骤四：购买机场提供的稳定VPN,并修改设置网络参数
&lt;/h4>&lt;p>机场链接&lt;a href="https://ikuuu.one/user/tutorial?os=linux&amp;amp;client=clash##">IKUUU VPN&lt;/a>&lt;/p>
&lt;p>在这个机场里面选择VPN网络包,效果如下图所示
&lt;img src="imgs/VPN_merchant.png" alt="VPN_choice image">
以 Ubuntu 20.04 为例，打开系统设置，选择网络，点击网络代理右边的&lt;code>设置&lt;/code>按钮，选择手动，填写&lt;code> HTTP&lt;/code> 和 &lt;code>HTTPS&lt;/code> 代理为 &lt;code>127.0.0.1:7890&lt;/code>，填写 &lt;code>Socks&lt;/code> 主机为 &lt;code>127.0.0.1:7891&lt;/code>，即可启用系统代理&lt;/p>
&lt;p>修改图如下所示&lt;/p>
&lt;p>&lt;img src="imgs/change_results.png" alt="change_results image">&lt;/p>
&lt;p>之后点击&lt;code>clash&lt;/code>链接&lt;a href="https://clash.razord.top/#/proxies">clash board&lt;/a>&lt;/p>
&lt;p>clash界面如下图所示&lt;/p>
&lt;p>&lt;img src="imgs/clash.png" alt="clash image">&lt;/p>
&lt;p>点击确定，之后便可享用VPN了&lt;/p>
&lt;p>最终clash效果图如下所示：&lt;/p>
&lt;p>&lt;img src="imgs/VPN_results.png" alt="VPN_results image">&lt;/p>
&lt;p>外网游行&amp;ndash;&lt;code>Youtube&lt;/code>展示:&lt;/p>
&lt;p>&lt;img src="imgs/Youtube.png" alt="Youtube image">&lt;/p>
&lt;h4 id="平日开启vpn的方法">
&lt;a class="header-anchor" href="#%e5%b9%b3%e6%97%a5%e5%bc%80%e5%90%afvpn%e7%9a%84%e6%96%b9%e6%b3%95">&lt;/a>
平日开启VPN的方法
&lt;/h4>&lt;p>在终端中&lt;code>cd&lt;/code>到&lt;code>clash&lt;/code>的文件夹下，输入&lt;code>./clash -d .&lt;/code>启动clash，启动完之后一般不要使用&lt;code>ctrl+c&lt;/code>或&lt;code>ctrl+z&lt;/code>打断运行，否则再次输入&lt;code>./clash -d .&lt;/code>运行会出现端口占用，如果打断了就只能：&lt;/p></description></item><item><title>ssh与remote ssh的使用</title><link>https://user-xixiboliya.github.io/post/sshremotessh/</link><pubDate>Sat, 07 Sep 2024 00:00:00 +0000</pubDate><guid>https://user-xixiboliya.github.io/post/sshremotessh/</guid><description>&lt;h2 id="ssh简介">
&lt;a class="header-anchor" href="#ssh%e7%ae%80%e4%bb%8b">&lt;/a>
ssh简介
&lt;/h2>&lt;p>ssh是一个多义词。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>SSH（Secure Shell，安全外壳）是一种&lt;strong>网络安全协议&lt;/strong>。SSH协议通过对网络数据进行加密和验证，在不安全的网络环境中提供了安全的网络服务。作为Telnet和其他不安全远程shell协议的安全替代方案，目前SSH协议已经被全世界广泛使用，大多数设备都支持SSH功能。&lt;a href="https://info.support.huawei.com/info-finder/encyclopedia/zh/SSH.html">关于ssh协议的更多内容&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ssh是通过SSH协议提供远程终端(壳shell)访问（远程命令行登入）的&lt;strong>计算机服务&lt;/strong>。其分为客户端与服务端，其中客户端预装在几乎每一台windows与linux上，而服务端需要手动安装，以防止被攻击破解。在客户端登录服务端后，默认情况下，客户端的命令行指令会被发送到服务端，服务端的指令执行结果也会发回客户端，其效果如同直接使用服务端的命令行一样（即远程终端）；通过重定向程序的输入输出流到ssh服务，也可以达到为明文流量加密的作用;ssh的其他应用还包括端口转发，代理等，堪称万能的网络工具。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Java三大框架。（显然不是这个）&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="ssh使用入门">
&lt;a class="header-anchor" href="#ssh%e4%bd%bf%e7%94%a8%e5%85%a5%e9%97%a8">&lt;/a>
ssh使用入门
&lt;/h2>&lt;h3 id="在服务器安装ssh服务端">
&lt;a class="header-anchor" href="#%e5%9c%a8%e6%9c%8d%e5%8a%a1%e5%99%a8%e5%ae%89%e8%a3%85ssh%e6%9c%8d%e5%8a%a1%e7%ab%af">&lt;/a>
在服务器安装ssh服务端
&lt;/h3>&lt;p>ssh服务由多个软件提供，其中Linux上openSSH是开源免费的，可以通过下列命令直接安装&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo apt update
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo apt install openssh-server
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol>
&lt;li>
&lt;p>上述命令的显示样式在markdown中被称为&amp;quot;代码块&amp;quot;，代码块中的代码会根据注释中指明的计算机语言被高亮与上色。不作说明的情况下，其中的shell命令都需要被执行。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在官方文档中，每行shell命令的开头往往会加上&lt;code>$&lt;/code>，从而将多个命令与对应的输出之间做区分。但是为了方便读者观看与直接复制使用命令，本文档约定命令的输出应当尽量以图片的形式进行展示，因循此例。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="获取服务器ip地址">
&lt;a class="header-anchor" href="#%e8%8e%b7%e5%8f%96%e6%9c%8d%e5%8a%a1%e5%99%a8ip%e5%9c%b0%e5%9d%80">&lt;/a>
获取服务器ip地址
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo apt install net-tools
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ifconfig
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="1.png" alt="output">&lt;/p>
&lt;p>观察输出，其中第一项&lt;code>eth0&lt;/code>是一个以太网网关，本机地址为172.22.44.10(wsl2的默认地址)，第二项&lt;code>lo&lt;/code>是本地环回地址(localhost 127.0.0.1)。通过同样的方法，在其他网络中也可以分辨出你想通过哪一个网络访问该服务器，以及该服务器在网络中的ip地址是什么。&lt;/p>
&lt;h3 id="登入">
&lt;a class="header-anchor" href="#%e7%99%bb%e5%85%a5">&lt;/a>
登入
&lt;/h3>&lt;p>ssh支持两种最常见的登录方法，一是密码验证，另一种是利用数字签名算法进行身份验证。&lt;/p>
&lt;h4 id="密码验证">
&lt;a class="header-anchor" href="#%e5%af%86%e7%a0%81%e9%aa%8c%e8%af%81">&lt;/a>
密码验证
&lt;/h4>&lt;p>在终端(Bash或powershell)输入以下命令&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>ssh &lt;span style="color:#e6db74">${&lt;/span>UserName&lt;span style="color:#e6db74">}&lt;/span>@&lt;span style="color:#e6db74">${&lt;/span>IPaddress&lt;span style="color:#e6db74">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;ol>
&lt;li>&lt;code>${UserName}&lt;/code>与&lt;code>${IPaddress}&lt;/code>是Bash中引用变量的方式，在此处分别指代：服务器上想要登录的账户的用户名，服务器地址。比如你需要访问的服务器的ip是172.22.44.10，用户名是rc，那么应该输入&lt;code>ssh rc@172.22.44.10&lt;/code>&lt;/li>
&lt;li>实际上&lt;code>${IPaddress}&lt;/code>的位置还可以填写主机名&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;ul>
&lt;li>
&lt;p>如果是第一次登录，成功进入登录验证阶段&lt;/p>
&lt;p>&lt;img src="3.png" alt="verification messages">&lt;/p>
&lt;p>此时输入&lt;code>yes&lt;/code>（注意不能是缩写&lt;code>y&lt;/code>,&lt;code>Y&lt;/code>,&lt;code>(Enter)&lt;/code>），会提示输入密码，正确与不正确均有反馈，遵循提示即可&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果未成功进入登录验证阶段&lt;/p>
&lt;ul>
&lt;li>
&lt;p>ip地址/主机名输错，超时&lt;/p>
&lt;p>&lt;img src="4.png" alt="alt text">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>登录的主机ip地址与之前登录过的不同主机的ip地址恰好相同&lt;/p>
&lt;p>&lt;img src="2.png" alt="error messages">&lt;/p>
&lt;p>参考解决方案：&lt;a href="https://blog.csdn.net/wangguchao/article/details/85614914">问题解决——SSH时出现WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="秘钥验证">
&lt;a class="header-anchor" href="#%e7%a7%98%e9%92%a5%e9%aa%8c%e8%af%81">&lt;/a>
秘钥验证
&lt;/h4>&lt;h5 id="首先生成非对称加密算法的密钥对">
&lt;a class="header-anchor" href="#%e9%a6%96%e5%85%88%e7%94%9f%e6%88%90%e9%9d%9e%e5%af%b9%e7%a7%b0%e5%8a%a0%e5%af%86%e7%ae%97%e6%b3%95%e7%9a%84%e5%af%86%e9%92%a5%e5%af%b9">&lt;/a>
首先生成非对称加密算法的密钥对
&lt;/h5>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>ssh-keygen
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Ubuntu上的输出结果
&lt;img src="5.png" alt="Ubuntu上的输出结果">&lt;/p>
&lt;p>Windows上的输出结果
&lt;img src="6.png" alt="Windows上的输出结果">&lt;/p>
&lt;p>接下来会弹出一堆选项，要求你确认一堆东西或者设置密码之类的，为了方便，一直按&lt;code>Enter&lt;/code>直到完成设置。&lt;/p></description></item></channel></rss>