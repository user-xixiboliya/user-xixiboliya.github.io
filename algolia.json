[{"objectID":"1762812600","permalink":"/post/paperreading3/","title":"Paper Reading 3 - VLN Section","content":" Dream to Recall: Imagination-Guided Experience Retrieval for Memory-Persistent Vision-and-Language Navigation 世界模型(RSSM)的任务是：基于语言条件，想象未来导航状态：即预测 $z_{t+1},z_{t+2},…,z_{t+d}$（潜在状态）作为“如果继续导航，会发生什么/我会到哪里”。 同时，这些想象状态既用于“编码当前经验以存入记忆”，也用于“生成检索查询”以便后续从记忆中调取相关经验。 Disentangling Foreground and Background for vision-Language Navigation via Online Augmentation NaVid: Video-based VLM Plans the Next Step for Vision-and-Language Navigation 翻译：NaVid: Video-based VLM Plans the Next Step for Vision-and-Language Navigation\nJanusVLN：通过双重隐式记忆解耦视觉语言导航中的语义与空间性 使用RGB达到导航的效果。对于图片输入，3D空间信息由VGGT得到，2D视觉编码则由Qwen VL得到。\nLaViRA: Language-Vision-Robot Actions Translation for Zero-Shot Vision Language Navigation in Continuous Environments 输入是纯 RGB 图像和 自然语言指令。 VLN-Zero:Rapid Exploration and Cache-Enabled Neurosymbolic Vision-Language Planning for Zero-Shot Transfer in Robot Navigation 论文标题：VLN-Zero: Rapid Exploration and Cache-Enabled Neurosymbolic Vision-Language Planning for Zero-Shot Transfer in Robot Navigation\n这篇论文提出了 VLN-Zero，一种新颖的基于神经符号的视觉-语言导航 (VLN) 规划框架，旨在实现机器人在 零样本转移 (zero-shot transfer)环境下的高效导航。该方法的核心创新在于将 快速探索 和 缓存增强 与 神经符号规划 结合起来，解决了传统视觉-语言导航任务中对样本依赖性和环境复杂性的高要求。 VLN-Zero 的目标是在 未见环境（zero-shot transfer）中实现机器人导航。传统的视觉-语言导航方法通常依赖于大规模的环境数据集和充足的训练样本，然而在实际应用中，机器人可能会遇到完全新的环境，这使得现有方法在适应性和普适性方面存在局限。为了克服这一挑战，VLN-Zero提出了一个新的方法框架，通过神经符号推理和环境缓存来支持机器人在未知环境中迅速适应并有效执行任务。\nVLN-Zero 的关键技术之一是结合了 快速探索 和 缓存增强。具体来说，系统首先在任务初期执行 快速探索，通过较少的行动迅速了解环境的结构与布局。然后，通过 缓存机制 将这些经验存储下来，供后续的决策使用。这种策略使得机器人可以利用先前的经验进行推理，从而减少对传统大量样本的依赖，实现在未见环境中的 零样本转移。\n此外，VLN-Zero 采用了 神经符号规划，它结合了神经网络和符号推理的方法。神经网络负责处理环境的感知输入（如图像和语言），而符号推理则负责将视觉和语言指令转换为高效的计划行动。通过这种方式，系统能够在VLA任务中更好地理解和执行复杂指令，同时能够处理多变的环境和任务要求。\n在训练过程中，VLN-Zero 使用了多种增强技术，特别是 环境缓存，以减少模型对环境细节的依赖。通过缓存机制，机器人可以在不同的任务间共享相同的环境知识，从而提高任务执行效率。训练过程中，模型不仅学习如何理解和执行语言指令，还学习如何在新的、未知的环境中应用这些知识。此外，论文还提出了一种自适应的训练方法，允许机器人在探索过程中根据环境变化自动调整策略。\n部署时，机器人根据 视觉输入 和 语言指令 进行实时推理。通过前期的缓存和符号推理，机器人可以有效地将输入的语言指令转化为动作，即使在完全没有见过的环境中，也能通过缓存的环境信息和符号规划策略执行任务。该方法在大规模仿真环境中进行了测试，并取得了良好的零样本转移结果，证明了其高效的跨环境泛化能力。\nVLN-Zero 的主要贡献在于其创新的 神经符号规划框架，以及 快速探索 和 缓存增强 策略。这些方法有效地提高了机器人在 零样本转移 任务中的表现，突破了传统视觉-语言导航方法对于大量训练样本和环境依赖的限制。论文还通过多种实验验证了该方法在多种场景中的有效性，展示了其在 跨环境导航 和 复杂任务执行 中的巨大潜力。\nWalk and Read Less: Improving the Efficiency of Vision-and-Language Navigation via Tuning-Free Multimodal Token Pruning 一篇剪枝的文章。 DAgger Diffusion Navigation: DAgger Boosted Diffusion Policy for Vision-Language Navigation Boosting Zero-Shot VLN via Abstract Obstacle Map-Based Waypoint Prediction with TopoGraph-and-VisitInfo-Aware Prompting Boosting Zero-Shot VLN via Abstract Obstacle Map-Based Waypoint Prediction with TopoGraph-and-VisitInfo-Aware Prompting\n","date":"2025-11-10 15:00:00","updated":"2025-11-10 16:00:00"},{"objectID":"1761084600","permalink":"/post/paperreading/","title":"Paper Reading 1","content":" pi0 $$\\boldsymbol{o}_t = \\left[ \\left[ \\boldsymbol{I}_1^t, \\dots, \\boldsymbol{I}_n^t, \\ell_t \\right], \\left[ \\boldsymbol{q}_t \\right], \\left[ \\boldsymbol{a}_t^\\tau, \\boldsymbol{a}_{t+1}^\\tau, \\dots, \\boldsymbol{a}_{t+H-1}^\\tau \\right] \\right]$$ $\\pi_{0}$的数据集构建的很成功，预训练的数据来源未$\\pi 0$数据集以及开源数据集OXE，以量取胜，之后再对于特定任务进行微调。为了使数据结构统一，robot state被对齐到18维度。\n$$L^\\tau(\\theta) = \\mathbb{E}_{p(\\boldsymbol{A}_t \\mid \\boldsymbol{o}_t), q(\\boldsymbol{A}_t^\\tau \\mid \\boldsymbol{A}_t)} \\left\\| \\boldsymbol{v}_\\theta \\left( \\boldsymbol{A}_t^\\tau, \\boldsymbol{o}_t \\right) - \\boldsymbol{u} \\left( \\boldsymbol{A}_t^\\tau \\mid \\boldsymbol{A}_t \\right) \\right\\|^2$$ 在推理时，真实动作序列通过Euler步进法进行恢复,$\\boldsymbol{A}_{t}^{\\tau + \\delta} = \\boldsymbol{A}_{t}^{\\tau} + \\delta \\boldsymbol{v}_{\\theta}(\\boldsymbol{A}_{t}^{\\tau}, \\boldsymbol{o}_{t})$，$\\delta$=0.1。以下是对上式的解读，不过貌似原论文没找到。 原文提出的一些局限性：大多数知识来源于预训练阶段，微调则负责告诉模型如何用某些知识完成用户的指令。复杂任务的高精度数据(long\u0001horizon移动操作任务)进行微调会导致模型脆弱，以zero shot 方式运行预训练模型并不总能展现出后训练数据中所展示的流畅策略。\naction expert 有两种，一种是自回归的detokenizer,另一种是flow matching 的Diffusion Policy（例如pi0）。流匹配的DP倾向于让model学到一个分布，将噪声流到动作，输出的控制信号是连续的。自回归的Detokenizer是逐token预测，输出空间是离散的token化动作。\n对于VLA而言，大部分VLA的主干是VLM，另⼀种范式的兴起也不可忽视，也就是World Model的范式，换言之，即使用 Video Prediction Model 作为 VLA 的主干部分，并且辅佐以 DP 或者 Detokenizer 进行 Action 的输出。参考链接 相关工作有MindJourney 、Unified Video Action Model和Genie Envisioner。但这个idea并不是很新的了。\n$\\pi_{0.5}$ 揭示了一个端到端学习的robot可以执行长时间范围的灵巧操作技能。 $\\pi_{0.5}$做了subtask的划分，高层 VLM 是建模观测 + 整体 task prompt 到 subtask prompt 的分布；低层 VLA 是建模观测 +subtask prompt 到 action 的分布，并且多了action expert。参考$\\pi 0$的输入，图像 patch、文本提示和连续动作 token 均使用双向注意力。\n$\\pi_{0.5}$的范式与$\\pi_{0}$几乎差不多，且某种程度上与unified model当前的范式基本一致，VLM在训练VLA数据的过程中输出hidden state，之后使用hidden state作为condition，并且使用流匹配的DP进行action的输出。\n向前追溯，包括TinyVLA和CogACT等，均是使用相同的思路，使用VLM作为backbone，并且使用DP/flow matching进行action的输出。\nTest-Time Scaling with World Models for Spatial Reasoning 当下VLM在处理诸如预测自我中心运动后场景变化这样简单的任务时常常遇到困难，这是因为它们感知二维图像，但缺乏对三维动态的内部模型。MindJourney通过将VLM与⼀个基于视频扩散的可控世界模型相结合，赋予VLM所缺失的这种能力。\n每一个初始动作action被映射成一个相机的姿态变换，一条轨迹被确定为姿态变换序列。尽管原文在原理中意识将相机姿态输入diffusion model中，但文章末尾提到diffusion model会生成许多与查询无关的图像，可见相机位姿并没有在diffusion model中起到很好的限制作用。原文之后又讲到对于轨迹空间进行剪枝，剪枝的标准是对于每次 (轨迹，图像)对创建natural language description，让VLM进行评估。\nYilun Du 在采访中指出（尽管个人能量函数那一块有点扯淡），他认为其他大多数任务都在使用video model生成数据或者video based planning，应该做的是使video model做高层直接作为更高层次的planner会好许多。具体来说，给定当前的一帧图像，由video model生成一段未来的视觉视频序列。根据这段预测视频，就可以推断出当前应该采取的动作。因为如果知道未来每一帧应该处于什么位置，那么规划出当前的动作其实是一个相对简单的问题，只需要通过controller进行解析。\nshow-o 自回归对于text token是合理的，但其对于image prediction受限于因果注意力，而且diffusion model在image generate方面有着更优越的能力。于是本文想提出一个单一的transformer融合自回归与扩散，同时处理多模态理解和生成任务。 文本仍是用llm处理，图像采用了MAGVIT-v2，将256$\\times$ 256图像编码为16 $\\times$ 16个离散词元。对于图像文本输入，支持自适应因果注意力和全注意力。\nNaVILA: Legged Robot Vision-Language-Action Model for Navigation 研究问题：该方法使得四足能够在复杂的环境中进行VLN 解决的challenge：是人类语言到四足低级腿部低级action的转化。架构分为两层，上层是VLA： 训练时冻结LLM，对于Vision encoder和projector进行训练，然后就是对于LLM的输入采取规范的格式，LLM生成中间级别的指令流（例如前进75cm），然后将指令转换为固定的命令速度。尽管十分工程化，但其突出了跨平台的适应性。对于不同的机器人只需要替换低级策略，无需重新训练VLM。\n数据：采用的数据是youtube、模拟轨迹（R2R-CE/RxR-CE）、辅助数据（ScanQA）和通用 VQA。传感器采用雷达生成的2.5D高度图，解决透明物体（玻璃）和强光环境下的感知问题。\n文章里道出：本文提升模型了对复杂指令和场景的理解，且在现有 VLN 任务中优于前人方法，单RGB输入达到了与全景视图、里程计等输入相当的效果。\n开源情况：https://navila-bot.github.io/ 部分开源\nYou Only Teach Once 提出了一种高效的学习范式，从视频中提取目标（单RGB多RGB）、位姿等等特征，迁移到机械臂的动作生成。 视觉动作的模仿学习通过利用标注端到端学习，基于diffusion model，本文提出了BiDP，添加了motion mask，将视觉任务简化为点云。大体框架是：\n提取动作的3D点轨迹到2D，滤出目标物体的关键帧进行利用IGEV-Stereo升为点云，粗略估计手部夹角。 动作injection：将轨迹简化为关键帧（检测末端执行器速度极值），手眼变换成K个动作，K为10。 手臂协调需要掩码，对于拉抽屉而言需要hold one hand. （这没什么） 现实中对物体的点云进行平移旋转达到数据增殖 将观测点云降采样，diffusion: SIM框架、DDPM和Unet等组件，未详细道出。 实验部分进行的任务都是长序列的复杂任务，相较于pi0，成本更低，自动回放（对每个任务设置不同位置和不同资产进行替代？）生成了许多演示使得数据成本极低。在长期性能比较的定量结果上有显著提升，成功率为35.0%高于EquiBot。在基础五项任务上是76.8%。 局限性： 面向固定工作台。 执行器限制：平行夹爪无法完成精细操作。 进行了分布外的物体的测试，但任务结构相同，未涉及任务结构的变换，视觉误差和固定工作台限制其范化能力，有很多组件都有待升级。 RobotDancing: Residual-Action Reinforcement Learning Enables Robust Long-Horizon Humanoid Motion Tracking 这是一个tiny的工作。 解决问题：实现长时程高动态的人形运动追踪，因为关节的电机指令并未起到闭环补偿模型与现实系统之间的Gap。 模型部分： 舞蹈动作由LAFAN1 舞蹈集并且利用Unitree的重定向代码生成参考舞蹈动作$G$和base link position. training：对于t时刻，从目标舞蹈动作$G$检索$t+1$时刻的动作用于纠正actor生成的action。将t时刻之前$k$步的参考动作$G_{t-k+1:t+1}$和加噪的前k步观测给到actor，用$G_{t+1}$纠正actor output，由PD转换为底层关节controller给到robot。 policy消融实验体现了论文方法收敛速度更快，能在train阶段达到更高的reward，并且误差比baseline小。 在宇树的H2 H1 G1上泛化性良好，其他的不好说。 Iterative RL for VLA model (iRe-VLA) 解决问题：通过监督微调可以将VLMs融入低级机器人的控制，VLA的在线RL用于大型VLA可能极其不稳定，因而提出了迭代RL，即本文iRe-vla，在RL和监督微调（SFT）之间迭代。 模型结构： 由预训练VLM加上轻量动作头生成底层控制动作，LoRA微调VLM的参数$\\theta$与动作头参数$\\phi$即可。 在RL和SFT之间迭代：在RL时冻结VLM的$\\theta$防止崩溃，只优化动作头（Token Learner 和 MLP）的参数$\\phi$，将调出来的轨迹收集到online Database中；采用$D_{b}$内原有数据与新的在线数据$D_{RL}$监督训练，文章说是防止遗忘。 实验部分最初在 MetaWorld 和 FrankaKitchen 基准测试中进行了实验。采用三个领域进行测试：专家数据集中观察到的任务、运用强化学习的新任务，以及留出法未见的任务。 观察曲线可以看到RL阶段Unfreeze VLM出现了性能下降。 将 iRe-VLA 方法与标准的 PPO 算法进行了比较，确保了实验的公平性。通过对比，结果表明 iRe-VLA 方法在各种任务中表现出了较好的性能。标准PPO在引入RL任务时往往不稳定。 消融实验表明，始终冻结VLM进行RL-SFT并没有本文iRe-VLA效果好。 局限：无法从零开始学习陌生技能，当前方法更适用于已有技能的微调和优化，而非完全的技能迁移或自主学习新任务。 Do generative video models learn physical principles from videos? 本文是Google DeepMind的一篇报告，其主页甚至给出了各个模型对于物理理解的Leaderboard，目前在该Benchmark下最好的是VideoPoet，Sora(i2v)的rank并不是很高。\n论文的结论是：对视频生成式模型，视觉逼真并不等同于物理理解。 本文开发了Physics-IQ Benchmark，用于测评模型的物理理解能力。 模型将看到3秒的图像并且对于接下来5秒的视频进行延续。 Local Policies Enable Zero-shot Long-horizon Manipulation 问题：sim2real中面临挑战，主要源于难以模拟复杂的接触以及“生成真实的任务分布”。 贡献：ManipGen，其利用一种新的局部策略，使得sim2real能够迁移以及zero-shot。在仿真中训练agent便可以实现迁移规模化，提出了在仿真中训练的policy；进而同VLM和运动规划器结合进行部署。 在仿真中训练了数千个RL expert，采用PPO，通过DAgger将单任务RL expert蒸馏为用于迁移的视觉动作policy，使模型能够跨物体适应多种技能。VLM将动作分解实现基于text的长时程操作以及局部的sim2real迁移。 对于语言目标$g$和观测$O$，使得VLM预测$k$个语言子目标$\\sum\\limits_k {{g_k}}$，从$g_{k}$中提取子策略，子目标被LLM结构化为(物体，技能)元组。每次的输入为第$k$子目标$g_{k}$和当前观测$O^t$，操作分为两个阶段$\\pi_{reach}$和$\\pi_{loc}$，$\\pi_{reach}$需要接近物体并靠近目标位姿$X_{targ,k}$(采用Grounded SAM对点云分割)，运动规划器则是Neural MP。接着由$\\pi_{loc}$进行丰富的交互。如此分配，不同场景下的相同任务$\\pi_{loc}$相对固定，仅需观察交互区域周围的环境，采用的是腕部相机的深度图。 对于上文中提到的训练RL expert的阶段一，聚焦于抓取、放置、打开、关闭把手的基础任务，基础数据是使用 3.5K 个多样化对象（UnidexGrasp 数据集），随机生成初始位姿与障碍物；以及2.6K 个门/抽屉把手（PartNet 数据集），随机化尺寸、形状、摩擦系数等物理属性。观测$O$则是单一观测，并引入特权信息（物体的网格进行位姿采样）。奖励function则综合了：特定末端执行器的位姿+特定关节配置和特定物体位姿+末端执行器相对于物体的运动+是否成功+惩罚动作。\nRL expert的阶段二如何蒸馏，传统 DAgger 在多任务场景下不稳定（不同任务的初始状态差异大），改进方法为回放缓冲区（存储最近 K$\\times$B 条轨迹），交替进行策略更新和与新数据收集，平衡在线与离线学习。换而言之就是边训练边采样，每采到一批新轨迹，就在当前经验池$K$批上训练一次，如果经验池满了则删去最旧的，再放入最新的，然后训练一次。$K=100$时效果最佳。除此之外对于边缘像素丢失进行了处理。\n论文对于现有方法的分析是：SayCan在初始位姿不理想或者任务需要丰富的接触控制时不理想；LLMTrajGen在避障上做的不好。传统的sim2real 方法如 Transic，IndustReal 需任务特定训练或真实世界修正数据，无法 zero shot。\n未来：解决透明/反光物体的深度感知问题（如 RGB-D 融合）；引入在线自适应机制（如实时策略微调）减少模块化系统的级联错误。\n","date":"2025-10-21 15:00:00","updated":"2025-10-21 16:00:00"},{"objectID":"1761084600","permalink":"/post/paperreading2/","title":"Paper Reading 2","content":" Local Policies Enable Zero-shot Long-horizon Manipulation 问题：sim2real中面临挑战，主要源于难以模拟复杂的接触以及“生成真实的任务分布”。 贡献：ManipGen，其利用一种新的局部策略，使得sim2real能够迁移以及zero-shot。在仿真中训练agent便可以实现迁移规模化，提出了在仿真中训练的policy；进而同VLM和运动规划器结合进行部署。 在仿真中训练了数千个RL expert，采用PPO，通过DAgger将单任务RL expert蒸馏为用于迁移的视觉动作policy，使模型能够跨物体适应多种技能。VLM将动作分解实现基于text的长时程操作以及局部的sim2real迁移。 对于语言目标$g$和观测$O$，使得VLM预测$k$个语言子目标$\\sum\\limits_k {{g_k}}$，从$g_{k}$中提取子策略，子目标被LLM结构化为(物体，技能)元组。每次的输入为第$k$子目标$g_{k}$和当前观测$O^t$，操作分为两个阶段$\\pi_{reach}$和$\\pi_{loc}$，$\\pi_{reach}$需要接近物体并靠近目标位姿$X_{targ,k}$(采用Grounded SAM对点云分割)，运动规划器则是Neural MP。接着由$\\pi_{loc}$进行丰富的交互。如此分配，不同场景下的相同任务$\\pi_{loc}$相对固定，仅需观察交互区域周围的环境，采用的是腕部相机的深度图。 对于上文中提到的训练RL expert的阶段一，聚焦于抓取、放置、打开、关闭把手的基础任务，基础数据是使用 3.5K 个多样化对象（UnidexGrasp 数据集），随机生成初始位姿与障碍物；以及2.6K 个门/抽屉把手（PartNet 数据集），随机化尺寸、形状、摩擦系数等物理属性。观测$O$则是单一观测，并引入特权信息（物体的网格进行位姿采样）。奖励function则综合了：特定末端执行器的位姿+特定关节配置和特定物体位姿+末端执行器相对于物体的运动+是否成功+惩罚动作。\nRL expert的阶段二如何蒸馏，传统 DAgger 在多任务场景下不稳定（不同任务的初始状态差异大），改进方法为回放缓冲区（存储最近 K$\\times$B 条轨迹），交替进行策略更新和与新数据收集，平衡在线与离线学习。换而言之就是边训练边采样，每采到一批新轨迹，就在当前经验池$K$批上训练一次，如果经验池满了则删去最旧的，再放入最新的，然后训练一次。$K=100$时效果最佳。除此之外对于边缘像素丢失进行了处理。\n论文对于现有方法的分析是：SayCan在初始位姿不理想或者任务需要丰富的接触控制时不理想；LLMTrajGen在避障上做的不好。传统的sim2real 方法如 Transic，IndustReal 需任务特定训练或真实世界修正数据，无法 zero shot。\n未来：解决透明/反光物体的深度感知问题（如 RGB-D 融合）；引入在线自适应机制（如实时策略微调）减少模块化系统的级联错误。\nAdaptive Compliance Policy:Learning Approximate Compliance for Diffusion Guided Control 对于robot需要精确的力控制的任务，大多数imitation learning需要以位置为中心，缺乏显式的力感知能力，并且协作机械臂添加力和力矩传感器通常成本较高且需要额外的硬件设计。本论文通过关节力矩估计末端执行器的力，同时利用数字孪生预测力矩进行补偿。\n本论文是双环的框架，外层是输入image，末端位姿和受力，以25Hz去predict下一个动作；接着将目标位姿输入内环，内环的阻抗扭矩控制器，运行频率为 2 kHz,重力补偿则是250Hz，输出为生成力矩指令，即“力入-力出”的结构。这一套有两种互补的力反馈机制：手持控制器提供触觉反馈，在虚拟现实中提供视觉反馈，也就是力向量可视化。 外环：外部力估计量提供交互力，与正向运动学（FK）输出融合，并通过多层感知机（MLP）层进一步处理。视觉观测由双残差网络主干网络编码，并通过交叉注意力模块与估计的力嵌入进行融合，多模态加噪输入transformer encoder。内环是将预测的动作位姿通过逆向运动学进行跟踪，给到阻抗扭矩控制器。\n仿真中的数据采集基于mujoco，数据采集一共采集了150条轨迹，每一条轨迹包含同步的 RGB图像、笛卡尔位置、关节力矩、末端执行器力/力矩以及操作员指令。\n对于仿真与实机实验结果，一共设置了三组：末端执行器position、末端执行器position+关节力矩、末端执行器position+末端执行器力，输入图像均为RGB图像。\n仅使用末端执行器位置组仿真68%，到实机成功率掉得厉害；加入关节力矩观测量的第二组并没有加入末端执行器的第三组好，第三组的仿真成功率为90%，实机成功率为80%。一种解释是原始的关节转矩收到运动链的影响导致噪声较大且含义模糊。 本论文只是一个对于力控的trival性探索，可以看见其框架均为手搭，未来能在任务、结合VLA的指令等方向上进行探索。\nDiffusion-Based Impedance Learning for Contact-Rich Manipulation Tasks diffusion policy的开山之作。\n原文链接：Diffusion-Based Impedance Learning for Contact-Rich Manipulation Tasks\n解决的问题：对于富接触和操作任务中，机器人不仅要生成运动轨迹（信息域），还要通过力/力矩控制与环境交互（能量域）。传统的运动擅长于路径和姿态生成，往往不专注于物理上的交互力学，其生成的轨迹无法保证力、阻抗参数合适。经典的阻抗控制（Impedance Control）方法能够很好地调节交互刚度与阻尼，但通常需要人工手工调参或为每个任务单独设计阻抗参数。因而本文希望提出一个能够统一学习运动轨迹与实时调节力参数的框架，这个框架是基于diffusion model的，该框架的关键要素是方向性刚度自适应。 文章中有一些概念：\nZFT：名义上的零力轨迹：一种程序化的平衡运动，在执行过程中保持不变，可通过基于帧的编程、模仿学习学到 sZFT simulated的零力轨迹，并未被预先编程，而是由扩散模型根据观测到的位姿和外部力矩重构得到，并且仅作为刚度估计的输入。 整体流程是：\n首先有机器人执行动作、产生轨迹 ＋ 外力 力矩观测。 利用一个diffusion model来重构sZFT。 在diffusion中，输入为轨迹tokens+力矩（上下文），噪声分为平移和旋转，旋转噪声的添加则是基于SLERP方法。 基于这个重构的 sZFT 和当前观测（位姿偏差＋外力 外力矩），通过一个能量-基的控制模块，计算或调整刚度$K_{t}$和旋转刚度$K_{r}$，给到阻抗控制器使其实时追踪、适应接触状态。 控制器在任务空间按计算出来的阻抗参数执行轨迹跟踪交互。 对于扩散模型：将信息域和能量域连接起来，学习预测观测位姿$(p,q)$与真实值平衡位姿之间的差异(可以由外部的力矩$F_{ext}$得到)，推理阶段则对位姿差进行去噪，输出重构的sZFT。在碰到意外障碍物时，规划的 ZFT 会使其进入接触状态，产生一个外部力矩。在该力矩的条件下，扩散模型重构出 sZFT，接着将sZFT输入到能量-基的“刚度估计”模块中。\n实验是在跑酷和插销插入两种任务上，论文研究了各个轴基于任务在时间维度上对于sZFT的贡献。\nAdaptive Compliance Policy: Learning Approximate Compliance for Diffusion Guided Control 研究的问题：目前主流的视觉-运动策略通常仅预测位置和姿态，但精密的接触需要控制接触力或者力矩以满足合规性(compliance)。 贡献：提出了Adaptive Compliance Policy（ACP）这一新框架，动态地和空间地调整合规参数，以适应不同任务阶段和接触方向；提出了一种能够从人类示范中标注合规参数的方法，使得演示具有两个有用属性——“避免大的接触力”和“鼓励精准跟踪”。 模型训练方面采用了体感教学+估算出的合规标签进行策略网络监督训练；观测数据鱼眼 RGB 图像，机器人末端执行器位姿，以及力/力矩数据。论文中的机械臂为一个RGB摄像头、一个力矩传感器，通过人类示范估计合规性。 对于刚度方向，在力反馈方向上使用低刚度$k_{low}$，而在其他方向上使用高刚度$k_{high}$。 策略网络（ACP）输出不仅是参考目标位姿（reference pose），还包括一个虚拟目标位姿（virtual target pose）和刚度值（stiffness）方向性合规参数，一共是19维向量。虚拟目标与参考目标的方向差编码出合规方向。虚拟目标位姿实际上是将一个力目标转换为位置目标（原文表述是虚拟目标位姿的计算方式是，当机器人在跟踪虚拟目标时，若达到参考位姿，则会施加参考力。这实际上 将一个力目标转换为位置目标）。\n输出这些高层策略之后，通过经典的低层高频合规控制器（如阻抗/顺应控制器）执行，从而真正“位置控制 + 力控制”并行。 因此，体系从“示范 → 合规标签估算 → 策略学习 → 输出参考＋合规参数 → 控制器执行”形成完整流程。\n实验部分则是分了四组，在物品翻转任务中，(ACP w.o FFT)(对力信号不使用fft而是时间卷积)的性能与$ACP$相似。在擦拭花瓶任务中，采用FFT编码的ACP更优，FFT 编码与 RGB 编码通过交叉注意力结合使用时，能够更好地判断下一个最佳擦拭位置。\nDiffusion Policy: Visuomotor Policy Learning via Action Diffusion 继diffusion policy后的作品，提出了DDPMs(decoder diffusion policy model)，把扩散模型作为 visuomotor policy 的开创性工作之一。 解决的问题：在机器人视觉-运动（visuomotor）策略学习（如模仿学习 行为克隆）中，一个关键难点是 动作 动作序列分布往往是多模态的（即给定一个观察，可能有多种合理动作或轨迹）。普通的策略回归（预测平均动作）容易产生 “模糊” 或 “平均化” 的动作，从而性能下降。并且动作空间可能很高维，需要有更好地拓展框架用于适应之后的任务。 本文将图像生成模型DDPM从图像生成等领域转移到“策略生成 动作生成”这一场景。核心想法是：如果我们把“给定观察 → 生成动作”看作一个「从随机噪声 → 动作序列」的生成过程，那么扩散模型天然具备“从噪声逐步生成复杂分布”的能力。\n本文引入视觉条件化（视觉输入 + 状态输入 → 动作输出的扩散模型）以适应真实机器人任务。时间序列扩散 Transformer以处理动作序列（而不仅单步动作）及其时间依赖性。滚动视野控制：策略并不是一步预测最终动作，而是在滚动控制模式下预测一段动作序列，执行部分，再重新预测。该设计使模型更适应在线控制环境。\n数据收集：从演示中收集视觉观察 $O$状态 $s$（及对应动作序列 $a_{0},a_{1},…a_{T−1}​$（可为多步动作段）。 训练阶段，构建一个条件扩散模型：输入包括当前观察 O (视觉 +状态) 及噪声化的动作序列$x_{t}$​ (在正向过程中) + time-step t。在正向过程：按预定噪声 schedule 把真实动作（或动作序列）扰动为 $x_{t}$​（t从0到T噪声步骤）。 在反向训练阶段，模型预测噪声或动作得分梯度（score），损失通常为 MSE 噪声预测损失。该网络为视觉条件 + $x_{t}$+ t → 估计噪声。 推理、采样阶段：给定当前观察$o$，初始从高斯噪声 $x_{T}∼N(0,I)$开始。进行 K 次去噪迭代在每一步用网络预测 score (或噪声) → 更新 $x_{t−1}=x_{t}+step-size∗score+noise$。得到最终 $x_{0}$​ 作为动作序列（或动作）。在滚动视野控制模式中，模型生成一个动作段（n 步），只执行首步或首若干步，然后再由新的观察重新生成。 此外，论文发现Diffusion policy的特性有：位控优于速度控制，位控的动作多模态性更为明显。对于空闲动作鲁棒，时空动作一致性。 主要局限性部分分两点：实时性：扩散模型本质上需要多步迭代去噪，在真实机器人实时控制场景中可能延迟较高。论文虽然使用滚动控制、短序列预测等设计缓解，但仍不是 “一步预测” 的即时策略。资源需求：训练条件扩散模型、视觉 encoder、Transformer 架构，对计算资源要求较高。执行采样也较重。\n3D Diffuser Actor: Multi-task 3D Robot Manipulation with Iterative Error Feedback 解决的问题：位置+动作预测，机器人操作通常要求预测三维平移+三维旋转，动作空间高维。2D图像或者低维姿态的策略难以泛化，使用3D场景(多摄像机)表示能够更好地泛化。论文提出一种策略模型：能够基于 3D 场景表示 + 语言任务指令，用diffusion policy预测末端执行器的 3D 平移＋旋转轨迹，从而提升多视角、强泛化的机器人操作能力。 创新点：在每一步迭代的去噪过程中，模型将末端执行器当前估计姿态视作 3D 场景中的一个 token，与 3D 场景视图 token + 语言指令 token 一起输入。\n在每一个去噪iteration 中，模型会将当前末端执行器姿态估计视作一个 3D scene token，然后基于场景中 3D 视觉 token、语言 token、动作历史 token，通过 3D 相对位置注意力计算出 “平移误差 + 旋转误差”，然后将这个误差用作修正量，对估计姿态做更新。误差是末端执行器姿态轨迹估计（模型在去噪步骤 $t$的输出状态）去预测它与真实目标之间的误差。然后用这个误差来“修正”当前估计。\n局限性：采样速度，实时性、训练，部署资源成本等。\nOcto: An Open-Source Generalist Robot Policy 在机器人操作与视觉-动作策略学习领域，通常的方法是为每一种机器人、每一种任务、每一种传感器配置专门训练一个策略。这种 “专属” 策略方式导致数据收集量大、效率低、难以泛化、模型迁移、微调困难，因此，作者提出希望构建一个通用机器人策略模型，用户不必从零开始训练，而是基于该模型做少量微调即可。 机器人领域也正朝向“Foundation 模型”方向：即先在多任务、多模态、大规模数据上预训练一个通用模型，再在下游做少量任务特定适配。Octo 正是朝这个方向迈出一步。\nOcto 有着极高灵活性、模块化设计，架构设计允许 改变传感器输入改变动作空间，实验中，Octo 在新机器人、新任务、新输入输出配置上只用了约 100 条演示即进行微调，并在数小时内完成。官网给出微调成功率显著高于从零训练。\n大致pipeline：\n输入 tokenizers：将语言、目标图像、视觉序列、机器人状态等转换为 token 表示。 (“tokenizer”模块) Transformer 主干网络：以 sequence 模型形式处理这些 token（包括观测序列 +任务指令 +目标）— block-wise masked attention 结构使得历史观测、当前观测与任务指令被正确编码。 Readout token: 模型中加入可学习的 “readout tokens” 用于动作预测。然后接一个 “diffusion decoding head” 或连续动作预测头来输出动作。 输出：动作序列或动作片段（可以是末端执行器动作或关节位置控制）。 预训练：在大规模数据上训练 Transformer + 动作头，目标是学习从观察指令 → 动作分布。因为动作空间是连续且多模态，采用扩散解码比简单回归更合适。 微调：利用预训练模型作为初始化，插入或修改少量的 tokenizer/输出头以适配新的输入输出，再微调模型。 主要局限性：对于动作输出/实时控制可能难以代替专门设计策略，尽管模型规模比某些超大模型小很多，但预训练仍需大量数据与计算资源，微调虽快但仍需一定硬件支持。 3D Diffusion Policy : Generalizable Visuomotor Policy Learning via Simple 3D Representations 主要解决问题：传统的视觉模仿学习通常需要大量人类演示才能学出稳定的策略，并且这些策略在训练分布之外往往泛化能力差且容易产生越界、碰撞的问题。\n核心动机：将视觉模态转向3D，如点云、体素、深度＋位姿等信息。采用Diffusion Policy，并且希望少样本也能取得不错效果。 环境以单摄像机获取深度图，将深度图通过相机内外参转为点云并且对点云进行裁剪+下采样，之后使用一个轻量点编码器（MLP）将点云映射到一个紧凑的特征向量（3D 表示）。决策模块基于 diffusion-based policy 架构，模型从噪声中逐步“去噪”生成动作序列预测，模型输出的动作可以是相对 end-effector 位置、手部关节角度、抓取动作等，视任务而定。\n创新点：通过消融分析，展示“简单点云表示”胜过更复杂的 3D 表示（如体素、深度图直接、或其它点编码器）在本任务中的效果。用单视图深度→点云转换，而不是多视图、复杂扫描，增强实用性。使用稀疏点云（而不是密集体素／隐式场） + 高效编码器—强调“简单”3D 表示即可取得好效果。 将该 3D 表示作为条件输入给 diffusion 模型，用于生成 动作序列，而不仅是静态动作。在真实机器人上验证其泛化能力。\n之后工作：点云表示有可能并非最优的 3D 表示，并且diffusion的推理频率的控制频率仍待探究。\nRDT-1B: a Diffusion Foundation Model for Bimanual Manipulation 解决的问题：双臂机器人操作的场景下如何学习一个泛化性强的policy，并且当前双臂数据集匮乏现有方法泛化能力差，多臂系统并没有设计统一的框架进行表示。因此，本研究的目标是构建一个双臂操控的「大模型」——即一个规模大、预训练于多机器人数据、然后能用于双臂任务 fine-tune 或甚至 zero-shot 的策略模型。\n不同机器人、不同操作平台具有不同的动作维度、不同类型。论文设计了一个 “Physically Interpretable Unified Action Space”，将各种动作映射到统一表示，使预训练数据能够跨机器人共享。具体而言就是“意义槽”，即这个空间的每个“槽”都有固定“物理意义”，文章是128维。为了让统一空间也能涵盖机器人的状态与动作，RDT-1B 将 “当前状态” 与 “要输出的动作” 放在同一空间结构内。动作以 “动作 chunk”（action chunk）形式输出——即模型一次预测一段时间内的动作序列，而不仅单步动作。\n主要启示：大模型 + 多数据 +统一表示 是提升泛化能力的关键，扩散模型可用于控制任务。并且大规模预训练 + fine-tune 可实现少样本新任务的泛化。\nALOHA Unleashed: A Simple Recipe for Robot Dexterity 解决的问题：尽管模仿学习在机器人上成功许多，但大多定位于“推放抓取”类的任务，并非高灵巧任务。仅靠标准模仿学习 + 少量数据”是否能胜任这种“高度灵巧 + 双臂 +变形物体”的任务？如果不能，怎样的“规模＋模型”组合足够？ 创新点：任务难度更高，你可以看到系鞋带、随机厨房的任务。开环执行，模型预测一个长度为 50 动作的 chunk，然后机器人执行，无需每步反馈重规划，这简化了控制流程。\n大致pipeline：\n输入：4 幅 RGB 图像（每幅 480×640) + 机器人本体状态 。 视觉编码：每个图像用 ResNet50 提取特征 。 Transformer 编码器：将所有视角特征 + proprioceptive embedding（被投影为 1 个 embedding）拼接、加位置编码，输入 Transformer Encoder。 Diffusion Policy Decoder：在 action chunk 模式下（一个 chunk 长度为 50 步动作，每步 14 维：12 维关节位置(6dof ×2臂) + 2 维夹爪位置) 。模型以 “noised” action chunk + observation embedding + diffusion timestep 作为输入，输出预测的噪声，进行反向去噪流程。 推理：从初始噪声采样 action chunk →通过 50 次 diffusion 去噪 →输出动作序列 →机器人执行这 50 步动作。整套前向 + 50 步去噪耗时约 0.043 秒。 其为每个任务都训练了一个独立的扩散策略，使用了隐式扩散去噪DDIM， 主要局限性：尚未实现 “一个模型覆盖多任务” 的情形，所需数据成本仍然较高，需要许多人类操作员。\nDiffusion Policy Policy Optimization(扩散策略最优化) 动机：已有基于扩散模型的策略在机器人控制/连续控制任务中显示出优势，但是，这类扩散策略在后续用传统强化学习方法（例如策略梯度、PPO）做 fine-tune 或在线调优时，存在效率低的问题。该论文解决的问题是，如何设计一个高效、稳定、适合将预训练的扩散策略用于机器人/连续控制任务的强化学习优化框架？让扩散策略通过 RL Fine-tuning 真正变得可用、高效且可靠——解决“扩散策略虽优秀但难以用 RL 优化”这个瓶颈。 大致pipeline：\n预训练阶段行为克隆或演示数据训练一个扩散策略。 微调阶段： 将预训练的扩散策略作为初始策略 $π_{θ}$​。 在环境中采样轨迹（状态、动作、奖励）与扩散策略交互。 由于策略为扩散模型，其内部可视为“denoising”过程（多步采样）—作者将其视为 “inner MDP”。 使用策略梯度 PG方法对该策略进行优化。 在训练过程中，DPPO 强调“结构化探索”：策略样本仍然保持在数据流形上（由预训练演示数据定义），而不是随机跳出流形，从而避免产生无效/危险动作。 训练结束后，得到 fine-tuned 的扩散策略，可用于部署。 局限性：模型依赖于预训练、扩散策略本身计算量大等。 ","date":"2025-10-21 15:00:00","updated":"2025-10-21 16:00:00"},{"objectID":"1750889880","permalink":"/post/windows-cpp/","title":"Windows-cpp-clang 环境搭建","content":" 本文初版参照RM视觉组的msys2-windows-cpp环境搭建教程，并在一定程度上进行了补充。\n让我们开始吧。\n首先，欢迎大家了解RC视觉组并学习一些相关知识。在往期培训过程中，我们一般使用linux进行环境配置，但是由于需要了解的知识过于硬核，导致培训效果不太理想。\n因此我们打算先使用windows配置环境并学习核心知识，之后再进行linux/ubuntu22.04环境的过渡。\n环境基础知识 集成开发环境（IDE） 集成开发环境本质上是把编写、构建、调试、测试、重构与版本控制等开发工作流所需的工具整合到一个统一界面中，减少来回切换工具的成本，让开发更高效、更可控。对于 C++ 这种语言，IDE 不仅要提供语法高亮和自动补全，还需要与编译器、构建系统和调试器深度集成，以便处理头文件搜索、宏展开、模板实例化和平台相关的差异等复杂问题。\n从功能角度看，一个适合 C++ 的 IDE 通常包含智能补全（基于 language server）、跳转定义/查找引用、重构支持、集成构建与任务系统、强大的调试器（断点、单步、变量/内存查看、核心转储分析）、静态分析与代码格式化（例如 clang-tidy、clang-format）、以及测试框架和版本控制的可视化支持。对于大型或跨平台项目，还希望 IDE 能处理 CMake/meson/bazel 等构建系统的配置，方便在不同平台和不同编译器间切换。\n目前常见的选项各有侧重点：Visual Studio（Windows）在与 MSVC、Windows SDK、性能分析器和图形化调试方面最为成熟，适合开发 Windows 原生应用和大型企业项目；CLion（JetBrains）对 CMake 支持出色，提供强力的重构与代码分析，跨平台但为付费软件；Visual Studio Code（VSCode）则以轻量、免费与扩展生态见长，通过安装插件可以把它变成功能接近传统 IDE 的开发环境，适合希望高度定制或在 Linux/WSL/macOS 上开发的用户。\n推荐把 VSCode当作 C++ 开发工具的原因在于其灵活性：你可以按需安装 language server（如 clangd 或 Microsoft 的 C/C++ 扩展）、CMake Tools、调试适配器（gdb/LLDB 或 Windows 的 cppvsdbg）、以及格式化/静态检查扩展。配合 Remote-WSL、Remote-Containers 或 Dev Containers，可以在容器或 WSL2 中运行实际的构建工具链和调试器，同时在宿主机上享受轻快的编辑体验，这对跨平台开发和保持一致的开发环境特别有益。\n环境变量 环境变量是操作系统中用于存储有关系统运行环境的信息的特定名称对象。它们对于指定程序运行的方式和位置至关重要，因为它们可以告诉系统在哪里查找必要的文件和程序。环境变量分为用户变量和系统变量，用户变量仅对当前登录的用户有效，而系统变量对所有用户都有效。一个关于windows环境变量介绍的博客是：看懂什么是环境变量! - 知乎\n搭建环境 对于c++开发环境，windows下可选择的环境还有visual studio (vs)，dev-c++等，然而vs使用的编译器为MinGW，是linux中使用的gcc编译器的windows移植版。目前mingw-w64位项目目前的状况比较复杂，有多个发行分支，具体可以参看官网的下载页。目前在windows上最新、最靠谱的发行分支就是MSYS2。\nMinGW (Minimalist GNU for Windows) 是一种用于开发原生 Windows 应用的最小化 GNU 开发环境，可以理解为开发 Windows 程序的 gcc，也就是说这个gcc就是专门编译出能在windows平台运行的程序的编译器。MinGW 本身并不一定要运行在 Windows 下，Linux 上也可以通过 MinGW 工具链交叉编译 Windows 程序。\n因此我们主要介绍msys32作为包含gcc的工具库，以vscode作为代码编辑器，进行环境配置。 ps: 关于mingw和mingw-w64的渊源，可以看这篇文章\nmsys2 MSYS2（Minimal SYStem 2）是一个集成了大量的GNU工具链、工具和库的开源软件包集合。它提供了一个类似于Linux的shell环境，可以在Windows系统中编译和运行许多Linux应用程序和工具。\n下载与安装 这里放一份不错的教程，按照这篇博文来安装并使用msys2 UCRT64：给萌新的C/C++环境搭建攻略\n这个是官网下载链接：MSYS2，并且包含了简单的环境配置过程。安装包下载速度较慢，有代理会快很多。\n安装教程的补充(添加环境变量) 要告诉其他应用 msys 2 装在哪里，也就是要把 msys 2 添加到环境变量当中。\nwin 10/11：设置-\u0026gt;系统-\u0026gt;关于-\u0026gt;高级系统设置-\u0026gt;环境变量\n找到系统变量名为 \u0026ldquo;Path\u0026quot;的变量，双击打开： 点击新建，把刚才安装 msys 2 的路径粘进去。我们只需要添加您ucrt 64安装路径下的bin文件夹，如图所示： 安装编译工具 msys 2 本质上是编译工具链的管理工具，我们还需要使用它来安装一些工具。\n还是刚才打开的 ucrt 64 界面，先输入 pacman -Syu 后回车进行软件源更新。这个过程可能有些慢，可通过更换国内源解决，大家可查阅 msys 2换源的相关资料。关于 ucrt 的介绍知乎老哥说的比较清楚了，大家可以了解一下。之后 msys 2 应该会重启，按个 Y 回车后，重新打开即可。\n之后，输入安装指令： pacman -S mingw-w64-ucrt-x86_64-toolchain ，遇到需要选择的部分一路回车就行。\n安装clangd： pacman -S mingw-w64-ucrt-x86_64-clang mingw-w64-ucrt-x86_64-clang-tools-extra 。以上安装步骤大致需要 3 G 的硬盘空间。\nclangd是llvm项目推出的C++语言服务器，通过LSP(Language Server Protocal)协议向编辑器如vscode/vim/emacs提供语法补全、错误检测、跳转、格式化等等功能。是基于Clang C编译器的。\n如何验证你装的东西有没有用呢？打开powershell终端试试。\n分别输入 gcc 以及 clangd 后得到如图输出，说明安装成功，并且环境变量生效： cmake !!! tip \u0026ldquo;提示\u0026rdquo; 以下教程简略且带有主观性，请谨慎阅读，并且留意文末的question部分。\n如果您想了解一下更快，集成度更高的xmake(基于.lua去描述工程)，您可以略微看一下xmake入门，构建项目原来可以如此简单。\ncmake 是一个用于组织 cpp 项目的工具，能够实现多个 cpp 文件的构建，找头文件的效率更高，并且我们以后要用的 ros 2 也使用 cmake 构建项目，有必要学习一下。\ncmake 下载地址：download | Cmake ，我们用 64 位的 windows 安装包。\n下滑找到 Windows x64 Installer（适用于 64 位系统），下载 .msi 文件。 之后的安装过程也没啥好说的，记着勾上环境变量： 再开个终端，试一下有没有： 这个样子就 ok 了。\n安装vscode 为什么将 vscode 放在最后面呢，这里想告诉大家的是，实际上使用什么IDE 并不是很重要，在之后我们将会有大量的时间直接在终端当中运行cmake，使用一个 IDE 仅仅用于提升我们的开发效率。vscode 和记事本没有什么本质区别，它只是附带了语法高亮、cmake 相关的插件工具，才使其有了 IDE 的性能，最重要的还是刚才搭建的编译工具链。如果有人只装了个 vscode，来问我为啥没法写代码，那我只能说十分甚至九分的若至了。\n官网下载：Visual studio code ,推荐 system installer 版本，获取管理员权限更容易。\n安装过程也没啥要说的，记得把添加环境变量勾上就行。\n虽然它只是个编辑器，不过还是要欢迎大家使用，它强大的插件功能足够我们使用它用各种语言编程，用到大学毕业不是问题。\n点击左边的四个框框图标，开始装插件。在上面的搜索栏搜索就行，目前需要的是这些插件，在左边那一列中显示。您也可以安装同义灵码、Trae和copliot 等一些AI插件。 这里就要介绍一下 vscode cmake 插件的用法了。按下ctrl+shift+p, 输入 cmake，选中cmake: quick start。\n之后您会看到包含CMakeLists.txt在内的项目文件。Cmakelists 就是用于管理 cmake 项目的工具，而 main. cpp 就是默认生成的实例代码。\n直接点击vscode下方状态栏的生成(build)（一个齿轮），会看到这样的结果： 三角符号就是运行，点击之后可以看到 hello 输出： 至此，cpp 开发与运行环境基本搞定，大家可以在此基础上学习 cmake脚本的编写以及 c++的语法知识了。\n??? question \u0026ldquo;按照教程并未成功怎么办?\u0026rdquo; 上述教程后的clangd和vscode部分开始显得简略,并且添加了很多具有主观色彩的内容,读者无法完全理解是很正常的.\n除了上述要点之外, 笔者发现配置 clangd 工具链似乎并没有那么容易, 因为你将会与你电脑原有配置继续打交道, 并且如果你的 system 中没有下载 LLVM、clangd 的话 (并不是指 vscode 的扩展), 你需要访问官网先下载安装它。vscode 中的 clangd 插件只是语言服务器（只做编辑器智能）, 归根到底依赖于你电脑上安装的 clangd 工具链。一个有用的链接是 [知乎-vscode+clang+llvm 搭建 C++ 编译环境（windows）](https://zhuanlan.zhihu.com/p/613922486)。如果你能够坚持下来, 相信一定很有能耐了, 做什么都会成功的。 ","date":"2025-06-25 15:00:00","updated":"2025-06-25 16:00:00"},{"objectID":"1748211480","permalink":"/post/rcserver/","title":"RC 网络仓库服务器","content":" RC 网络仓库服务介绍 Intro 服务是什么 本文档介绍的对象是一组部署在服务器上，用于RC视觉组共享与传承工作成果的Web服务。主要提供了私有远程git仓库服务(gogs)，文档与博客分享服务(hugo)，与文件下载服务，并最终通过 nginx (读作 Engine X) 集成到服务器的一个端口上。目前，该服务仅通过端口转发的形式，将运行在ROBOCON局域网下的服务器服务端口借由路由器（校园网域）暴露到一个校园网ip，每次路由器重启，校园网中的服务ip都会变化。\nAim 部署目的 私有远程git仓库服务（以下以 git-service 代称）：核心目的是用于收集视觉组各年工作项目，防止之前的方案随时间丢失。由于github，gitcode等网站的“组织”功能往往需要按时间付费，并且具有人数限制，因此采用 gogs 作为队内专用的git仓库。这个服务能够帮助团队协作开发（需要有git使用能力），跟踪各个组员进度。 文档与博客分享（以下以 doc-service 代称）：鼓励记录分享自己的经验，以及阅读他人的经验。采用 Docs 这一仓库，其可以将简单的markdown 文档生成美观的静态网站。 文件下载服务(以下以 file-service 代称)：除了保存资源文件，还可以把配置好的系统镜像，docker镜像放在里面，这样就可以免去配置环境的烦恼。现在采用的FileBrowser是一个充满bug的程序，打算换其他的。 Description 详细介绍 ssh 登录 从队里华为路由器登录界面（华为路由器默认局域网ip为192.168.3.1）可以看到，通过有线方式连接的 rc-server 记录其 ip 地址，可以在连接 ROBOCON 局域网的情况下访问服务器。主用户用户名是robocon，密码是qingchun，服务均部署在git用户下，git用户无法直接通过ssh登录，需要登录后切换。ssh 端口经过路由器转发到 22 端口，为了防止枚举用户名与密码破解，通过端口转发方式访问的连接都只能通过 public-key 方式进行登录认证，而无法使用密码登录。使用robocon和git用户登录服务器均需要公钥。\n另外，如果您想从校园网登上服务器，您可以在局域网条件下先查看路由器在校园网下的WAN IP，然后通过该IP登录服务器。\n# 从robocon用户切换 …","date":"2025-05-25 15:00:00","updated":"2025-05-25 16:00:00"},{"objectID":"1746137400","permalink":"/post/ai_system%E5%A4%8D%E4%B9%A0/","title":"2025XJTU AI系统复习","content":" 深度神经网络基础 早期的深度学习框架 主要用来CNN网络图像识别，由一些常用的layers组成。 主要特点就是通过.yaml这样的配置文件定义神经网络，可由一些常用的layer构成一个简单的图，支持多设备加速，代表框架是由UCB提出的Caffe。\n基于数据流图DAG的计算框架 基本数据结构是tensor 基本运算单元接收N个输入tensor，输出M个tensor。 tensorflow中有大于400个基本的operator 在数据流图中，节点表示operator，边表示tensor。有一些特殊的节点用来构建控制流，控制边用来表示节点之间的依赖关系。 静态数据流图TensorFlow 先定义后执行，静态图表示在编译时首先生成神经网络的结构，然后再执行对应的操作。\n静态图定义图后可以全局图优化 动态数据流图pytorch 边定义边运行，每次编译时都需要构建一个新的计算图。\n计算流图：引入中间变量将复杂的函数分解成一系列基本函数，构成计算流图。\n自动求导 前向计算并且保留计算结果，有个主要问题是需要保存大量的计算结果。在导数的计算也可以表示成数据流图。方便全局图优化与节省内存。\n现代大部分框架同时提供：\n自动求导系统，针对常见函数的组合 大量内置的Operators和与之对应的反向函数 为用户提供接口，自己提供反向函数。 图优化 先定义后执行的模式允许框架在计算前看到全图信息。数据流图作为深度学习框架中的高层中间表示，可以允许任何等价图优化Pass去化简计算流图或提高执行效率。\n图优化：DEMM自动融合 参考文章：深入浅出GPU优化系列：GEMM优化（一） - 知乎\n计算内核与多硬件支持 kernel定义了一个算子在某种具体设备的计算实现。\n每个operator都可以注册多个kernel，取决于数据类型、计算设备不同。runtime框架会自动根据operator的设备类型，数据类型和属性选择对应的kernel来执行。\n一段反向传播代码： $\\sum({x}*{y})+{z} = c$\nimport numpy as np N,D = 3,4 x = np.random.randn(N,D) y = np.random.randn(N,D) z = np.random.randn(N,D) a = x * y b = a + z c = np.sum(b) grad_c …","date":"2025-05-01 15:00:00","updated":"2025-05-02 16:00:00"},{"objectID":"1743545400","permalink":"/post/ai_system/","title":"2025XJTU AI系统实验","content":" XJTU AI system Experiments 2025 本仓库内容与Microsoft的AI System融合紧密，为其附属作业。这里有基本的作业项目Microsoft AI System Github、课程概述\n详情请见代码仓库AI System\nMenu assignment1 深度学习框架入门 assignment2 自定义pytorch算子 assignment3 NNI自动调参 assignment4 分布式训练 assignment5 容器化部署 TODO\u0026hellip; ","date":"2025-04-01 15:00:00","updated":"2025-04-02 16:00:00"},{"objectID":"1740348600","permalink":"/post/%E8%AE%A4%E7%9F%A5%E5%BF%83%E7%90%86%E5%AD%A6/","title":"认知心理学复习纲要","content":" “出题极其阴险。给人留下很不好的印象。”\n题型有 名词解释、成对概念分析、填空、判断对错、匹配连线、填图、实验分析、psychopy。\n认知心理学以研究黑箱方法为主，神经生物学以白箱研究为主，二者均启发计算神经工程。神经生物学为认知心理学提供了机理与证据。\nMental progress: Private psychological activities that include thinking, perceiving, and feeling.\n认知心理学研究的基本问题： 心理表征问题——心理表征的形成与对心理表征的加工。表征是指信息或知识在心理活动中的表现和记载的方式，是外部事物在心理活动中的内部表现。\n认知活动（心理表征及其加工）的意识水平：意识和无意识\n身心关系问题\n认知心理学的研究范式 信息加工范式 研究目的是确定认知操作的过程和结构，将外部信息转换为可操作的离散符号——心理表征 对信息的加工范式是序列(sequential)进行的 该模式可以回答自下而上的加工过程，却忽视了自上而下的加工过程。\n[信息加工的一般原理图] 感受器、效应器、信息加工系统 [对信息加工观点的批评图] 认知系统、调节系统、情绪系统、物理信号、运动和声音 联结主义范式 模拟神经网络的集成平行加工方式。\n信息表征是以神经网络的激活模式实现的，不同的激活模式表征不同信息，一个网络当中可以存储和表征不同的信息（一个网络有不同的激活模式）。信息是以非符号的分布式存储于神经网络中，存储具有非局部性；信息加工就是以一定模式在网络当中激活扩散，在空间上是平行分布式加工。 这种网络具有学习能力。 联结主义范式图他敢考？\n此外，认知心理学研究的生态学取向也日趋明显，强调人与环境的动态交互过程，从更为整体的观点认识人的认知过程。\n认知心理学的产生基础 哲学：\n柏拉图的理性主义（知识的基础是大脑的先天特征） VS 亚里士多德的经验主义（一切皆学习所得）\n认知心理学既依赖于理性主义研究，也依赖于经验主义研究。\n心理学：\n实验内省法：冯特主张以意识作为研究对象。\n行为主义：华生主张用纯粹客观的自然科学方法来研究，认为心理学应该研究similate-react。\n早期注重于研究行为主义，而托尔曼、班杜拉等行为主义者已开始注意行为的认知过程。\n格式塔学派也反对冯特的观点，但强调心理活动的整体性。“整体大于部分之和。”\n控制论 冯诺依曼提出自复制自动机理论，构造出了一种基于29状态的二维元胞自动机模型的自复制自动机的理论原型\n1948年，维纳发表的控制论《控制论——关于在动物和机器中控制和通讯的科学》提出核心思想——控制、反馈和人机交互。\n1956年，认知心理学正式诞生，1967年出版史上第一部《认知心理学》专著。\n感觉 什么是absolute threshold？ 能够被感知到的最小强度的刺激。在50%的时间里可以检测到的最小能量。 sensory adaptation？\n[感觉适应图]\n长时间暴露于不变的刺激下感觉能力的调整。 在大多数情况下，我们的感官会适应他们所经历的刺激水平。 敏感性的明显下降是由于感觉神经受体无法无限期地向大脑发送信息。 $$Z = \\frac{{f \\times d}}{{{x_{right}} - {x_{left}}}}$$ 对立过程理论 三套颜色感受器：黄Y-蓝B 红R-绿G 黑B-白W ，非此即彼。 虽然视网膜中有三种颜色受体，但他们传递的信息被视觉系统中的其他神经元编码为对手过程形式。\n视觉系统中的神经元对这些颜色对进行编码，并通过“对立”的方式进行信号传递。例如： 如果红色感受器被激活，则绿色感受器被抑制（或反之），这种对立关系帮助我们感知颜色的不同。 类似地，明亮与黑暗的对立（黑-白）也是通过神经元的对立过程来进行编码的。 这意味着在视觉神经传导过程中，同一颜色感受器的刺激不能同时表现出两个相对的颜色（比如红与绿）。当一个颜色对的一个元素被激活时，另一个颜色就会被抑制，这种机制帮助视觉系统识别和分辨颜色。 听觉位置理论: 人耳的听觉范围16~200Hz。基底膜的不同区域对不同的频率有分离的反应，大致可以分为三个区域。\n傅里叶级数 复指数信号 连续时间信号的傅里叶级数 嗅觉：设计用来模拟生物嗅觉的神经算法……成果有助于未来在未知背景气味的情境下识别特定气味。利用甲苯、氨、丙酮、一氧化碳和甲烷等对其进行气味训练。\n触觉：senses of touch,pressure,temperature and pain. skin senses play critial role in survival,making us aware of danger.\n知觉 概念 神经系统只会关注可能对决策产生影响的主要物体（知觉物体）。\n什么是刺激？ 产生感觉器官反应的能量。\n什么是感觉？感官刺激的体验。 感觉器官被物理能量源激活。\n知觉 (Perception) ： 从原始感觉信息中创建有意义模式的过程。 感觉信息在感觉器官和大脑之间进行分类、解释、分析和整合的过程。\n错觉 （important） 知觉错觉 知觉的欺骗。 知觉错觉主要依赖于我们自身的知觉过程，并且由于刺激包含误导性线索而发生。\n视觉错觉 当我们使用各种感觉线索来创造实际上并不存在的知觉体验时，就会发生视觉错觉。\n感觉≠知觉 错觉并非指出了我们知觉能力的缺陷，而是为我们提供了“知觉系统如何工作”更富洞察的启发。\n格式塔心理学 描述我们如何将零碎的信息组织成有意义的整体的一系列原则。\n邻近律 指邻近的元素更倾向于被分为一组。 相似律 指（形状、颜色、亮度等）相似的元素更倾向于被分为一组。 连续律 组合起来构成直线、平滑曲线、光滑表面的元素，往往被视为属于一组。 封闭律 组合成封闭图案的一组元素往往被认为成一组。 方向对知觉的影响 模式的自发组织是刺激本身的自然作用，与该物体过去的经验几乎没有关系（知觉的直接属性）\n典型视角 典型视角是格式塔心理学观点的拓展，指能对物体做出最佳表征的形象 对典型视角的一种理论解释是，我们对物体的日常经验可以发展出对该物体最具代表性形象的永久记忆。\n胶囊网络 胶囊网络(Capsule Networks)是深度学习三巨头之一的Geofrey Hinton 提出的一种全新的神经网络结构。\n胶囊就是将原有CNN神经网络中的个体神经元替换成了一组神经元组成的向量，这些神经元被包裹在一起，组成了一个胶囊。\n胶囊网络中的每层神经网络都包含了多个胶囊基本单元，这些胶囊与上层网络中的胶囊进行信息交互传递。\n两种对立的知觉理论 核心争议在于知觉是否需要知觉者已有内部心理表征的参与调节。内部表征是指知觉者已有的与知觉对象相关的知识经验、期望、动机和情绪等内部因素。\n知觉的假设考验说：建构主义的间接知觉理论  知觉需要已有内部表征的中介调节 认为感觉信息对知觉是不充分的强调自上而下概念驱动的加工，也包括强调自下而上数据驱动的加工 知觉的刺激物说：Gibson的直接知觉理论 知觉不需要内部表征的中介调节 强调自下而上数据驱动的加工能从环境中获得充分的感觉信息来完成知觉任务，形成直接知觉 强调生态学方法，知觉、行动和环境三者互动的动态知觉 Top-down \u0026amp; Bottom up Top-down processing（自上而下加工）：以更高层次的知识、经验、期望和动机为指导的感知 Bottom-up processing（自下而上加工）：感知，包括识别和处理有关刺激各个组成部分的信息 自下而上和自上而下加工的结合 知觉是自下而上的数据驱动加工与自上而下概念驱动加工两种成分综合的结果，两种成分相对比例的多少取决于知觉任务中的具体因素，随知觉任务的不同而不同 。\n单纯地依赖自下而上的数据驱动加工的知觉任务相对很少，大部分知觉任务是两种加工成分的综合，即知觉是现实刺激和已贮存知识经验相互作用的结果。0\n建构主义的听知觉实验 实验范式解析：\n句子的正确知觉率是音噪比的函数 ——验证了知觉的直接性质\n相同音噪比下： 正常句 \u0026gt; 异常句 \u0026gt; 非语法句 ——验证了知觉的间接性质 结论：\n人的已有语言知识对知觉具有作用 知觉既具有直接性质，也具有间接性质 整体加工与局部加工的争论 （很有可能出现） 对于一个客体（object），是先知觉其各部分，进而再知觉整体？还是先知觉整体，再由此知觉其各部分？\n格式塔心理学认为，整体是在其部分之前被知觉的。\nNavon（1977）的著名视听知觉实验研究证实了上述观点。 平行与序列加工 其他关于知觉的心理表征的争论还包括：平行加工与序列加工。\n模式识别 模式（Pattern） 有若干元素或者成分按照一定关系形成的某种刺激结构，也可以说模式是刺激的组合。 当人能够确认他所知觉的某个模式是什么，并能够将它与其他模式区分开来，这就是模式识别。 模式识别的基本过程 对当前知觉对象特征的知觉表征（特征提取） 记忆中与对象有关的表征在视觉系统中的激活（哈希检索） 当前对象的知觉表征与激活的记忆表征的比较（哈希检索） 决策过程：决定哪个长时记忆中的项目与当前对象有着最佳匹配（距离度量空间）\n模板说 在人的长时记忆中，贮存着许多各式各样的过去在生活中形成的外部模式的袖珍复本，称作模板。\n模板匹配（Template Matching）: 物体识别是基于对物体的知觉输入与记忆中的有关模版进行比较匹配的结果，这种匹配要求两者有最大程度的重叠。\n困难 如果模式在外形、大小、方位等某一方面有所变化，即识别不了。 预处理必不可少 需要在人的记忆中贮存不可计数的模板，增加了记忆负担，且与人的模式识别的高度灵活性不一致。 原型说 原型(prototype)：不是某个特定模式的内部复本，而是一类客体的内部表征，即一个类别或范畴的所有个体概括表征，反映一类客体具有的基本特征。\n原型说的基本观点 在模式识别中，外部刺激只需要与原型进行比较，由于原型是一种概括表征，因此不要求严格匹配，只需近似的匹配即可。当刺激与某一原型有最近似的匹配，即可将该刺激纳入此原型所代表的范畴，从而得到识别。 corr\n视知觉实验(1967) 原型说VS模板匹配说 原型说允许近似匹配，即使某一范畴的个体之间存在外形、大小等方面的差异，所有这些个体都可与原型近似匹配而得到识别； 原型说使人的模式识别更加灵活，更能适应环境，新的不熟悉的模式也可以识别 ；原型说可以大大减轻记忆负担。\n原型形成的两大理论 Centraltendency theory (趋中理论，Posner et al., 1967)：在概念上，原型代表了一组示例的平均值。 Attributefrequency theory (特征-频率理论，Solso and McCarthy, 1981)：原型代表最常见的属性组合模式，与一组模式的 \u0026ldquo;最佳范例 \u0026ldquo;同义。 特征说 特征（feature）：模式是由若干元素或成分按一定关系构成的，这些元素或成分可称为特征。\n外部刺激在人的长时记忆中是由特征符号的集合来表征的 模式识别首先要对刺激的特征进行分析，即抽取刺激的有关特征，然后将这些抽取的特征加以合并，再与长时记忆中的有关特征符号集合进行比较，一旦获得了最佳的匹配，外部刺激就被识别了 与模板匹配模型的关系：特征可以看做是一种局部的部件模板 但特征分析模型较模板匹配模型有如下优点： 更强的适应性，依据刺激的特征和关系进行识别，不管刺激的大小、多少等细节 同样的特征可以出现在不同的模式中，极大地减轻了记忆的负担 【字母搜索实验】验证了特征说，反驳了模板匹配说。\n【静止网像实验】 【幼年猫🐱的视觉皮层实验】 实验发现：某些细胞仅对水平形状有反应，而另一些仅对垂直形状有反应。\n实验结论：因幼年猫缺乏视觉经验，知觉形状的皮层编码是先天的。\n成分说 成分说又称作成分识别理论或几何子理论。\n基于简单三维 \u0026ldquo;几何子 \u0026ldquo;组合检测的感知能力 。\n根据视角不变特性定义的地线：即使从不同角度观察也能保持不变的特性\n几何子（geons）：24 个不同的形式，就像字母表中的字母一样，构成了一种系统类型\n模板说（模板匹配模型）——自下而上模型 原型说（原型匹配模型）——自下而上+自上而下模型 特征说（特征分析模型）——自下而上模型 成分说（几何子理论） ——自下而上+自上而下模型 结构优势效应 上下文效应。指整体的结构在模式识别中所起到的重要作用。\n字词优势效应实验（可能会出现） 句子优势效应 （可能会出现） 客体优势效应实验 解释是：\n存在两种知觉系统：特征系统——自底向上；客体系统——可被结构严谨的整体刺激激活 小结 以整体加工和局部加工为核心的假设，可以为上述各类结构优势效应给出统一的解释  视觉以外的其他感觉通道可能也存在着类似的效应  模式识别任务以外的其他的知觉活动可能也存在着类似的效应 注意 行为主义：否定注意的存在。格式塔心理学：注意完全融化于知觉之中。\n二战期间，工程心理学又开始重视注意的研究。 认知心理学将注意看做信息加工的重要机制。\n注意的定义 注意：是意识接收信息的过程，它是意识从同时呈现的几个对象或思维序列中选择一个对象并给予清晰和生动的关注的过程，意识集中与专注是注意的核心。\n注意的两个实质特征：选择性和改善心理加工的有效性。\n注意的模型 过滤器模型 单通道模型。过滤器至高级水平分析的通道只有一条。 衰减器模型 过滤器并不是按“有或无”的方式来工作的，不是只允许一个通道（追随耳）的信息通过， 而是既允许追随耳信息通过，又允许非追随耳信息通过，只是非追随耳的信号受到衰减，强度减弱了，但一些信息仍然可得到高级加工。\n过滤器VS衰减器模型 共同点\n根本出发点相同：高级分析水平容量有限，需要过滤器调节\n过滤器的位置相同：处于初级分析和高级分析之间\n过滤器的作用相同：选择一部分信息进入高级知觉分析，注意选择都是知觉性质的\n不同点：迟钝的耳朵与失聪的耳朵\n合并称为 Broadbent-Treisman 过滤器衰减器模型——注意的知觉选择模型。\n反应选择模型（新加） 又称为后期选择模型，该模型认为几个输入通道的信息均可以进入高级分析，得到全部知觉加工，注意不在于选择知觉刺激，而在于选择对刺激的反应。\n中枢的分析结构可以识别一切输入，单输出是按照重要性来安排的，对重要的信息作反应，而对不重要的信息不反应，注意是对反应的选择。尽管这是一种“不经济”的工作机制，心理学界仍未在两者间形成定论。 中枢能量理论（新加） 认为人们拥有一个容量有限的非特异的认知资源，这些认知资源可以被灵活的分配给人们面临的各种刺激和任务上。 \n他并没有设想一个瓶颈结构，也没有过滤器，而是将注意看成人能用于执行任务的数量有限的能量或者资源，用这种能量或资源的分配来解释注意。\n解释了常见的双作业操作。\n特征整合理论（新加） 大脑皮层的不同区域的特征地图对客体的不同空间属性进行了编码。\n在特征分析与特征整合两个相继进行的加工过程中，特征分析加工过程快速有效，而特征整合加工过程更慢而且效率不高。\n弹出效应 当奇异元素嵌入彼此相似，但在形状、颜色、大小、运动方向等某一特征截然不同的干扰物区域时，奇异元素很容易被直接识别到。 （奇异元素嵌入干扰物区域）\n计算机视觉显著性的研究方法 多尺度对比特征：在高斯图像金字塔上对比每像素邻域内的相似性，假设显著物体内部通常具有较高的像素相似性，而边缘相似性较低。\n中央-周围直方图特征：假设显著物体与其周围区域往往具有较大的像素差异。\n颜色空间分布特征：图像中所有颜色可以用高斯混合模型（GMM）来表征，据此可以衡量每个像素属于某个高斯元的概率。 这里假设显著物体的颜色一般较为单一。\n控制加工与自动化加工（概念辨析） 认知加工过程按受注意的控制调节程度可分为控制加工和自动加工\n控制加工（controlled process）需要注意力控制，以序列方式进行，相对较慢，但具有弹性 自动化加工（automatic process）很少或几乎不需要注意，以并行加工方式进行，相对较快，但缺少弹性 控制过程是容量有限的，并且在变化情境下可以灵活使用自动化过程没有容量限制，并且一旦掌握就很难改变。 shiffrin \u0026amp; schneider 视觉搜索实验 呈现识记项目，再现识记项目，被试判定是否见过。 stroop实验范式 实验结果：颜色的命名受到词汇语义的干扰，语义的自动识别很难抑制。\n意识 意识：大脑创建内外经验模型的过程\nNonconscious processes（无意识加工）：任何不涉及意识加工的大脑过程\nPreconscious memories（前意识）：目前不在意识中，但可以被唤起\nUnconscious（潜意识）：经典的弗洛伊德理论\n两方面：一是对环境的觉察，二是一个人对心里事件的认知——由记忆和自己的内在意识和自我意识产生的想法。\n潜意识 在弗洛伊德的经典理论中，这是心灵的一部分，它容纳了记忆、欲望和感受，如果这些记忆、欲望和感受被带入意识中，就会造成威胁。\n许多现代认知心理学家认为，无意识并不那么险恶，它只是在意识（知觉）之外运作的心理过程的集合，但通常不会压制信息，也不会与意识相抵触。\n意识的框架：AWAREness理论 该框架吸收了传统意识研究的要素，并提出了一些新的观点，集大成者\n注意（Attention） 觉醒（Wakefulness）：通过从睡眠到清醒的脑电，研究睡眠相关现象 构筑（Architecture）：研究决定意识加工的生理结构及其物理定位 知识回忆（Recall of knowledge）: 包括自我知识、世界知识、共情 情感（Emotion） 新异性（novelty）、浮现（emergence）、选择性（selectivity）、主观性（subjectivity） 新异性（novelty）：人和动物都有追求新异而有新信息刺激的倾向，即偏好“新”事物 浮现（emergence）：意识处理的是私有、内部的思想，是关于内部信息和自我反映的神经过程 选择性（selectivity）：人随时不断选择一小部分想法进行考虑，并频繁受到新想法的干扰，“探照灯”隐喻是其具象表现 主观性（subjectivity）：每个人的意识体验是独一无二的 知识回忆 自我觉察：知道自己就是自己，个人信息：可以即刻回忆起来而无需重新体验实际事件。\n世界知识：长时记忆中保存的所有关于外部世界的事实。\n共情：知道另一个的想法，共情敏感性有利于生存。\n觉醒——关于睡眠的研究 第 1 阶段：相对快速、低振幅 第 2 阶段：较低、更有规律的波形，睡眠纺锤 第 3 阶段：较低、较高的峰值和较低的谷值 第 4 阶段：更慢、更有规律，对外界刺激反应最小 快速眼动睡眠（REM sleep）（快速眼动）。 睡眠的特征 90 分钟一个周期，每晚睡眠 4~6 次\n最深睡眠出现在接近夜幕降临时\n快速眼动持续时间随着睡眠的进展而增加第一个周期只有 10 分钟，最后一个周期将近一个小时\n快速眼动 每90分钟出现一次，占成人总睡眠时间的20%，在闭眼状态下出现的眼球快速运动。\n会产生睡眠性麻痹，除了控制眼睛的肌肉外，其他任何自主肌肉都无法运动。\n与做梦有关。\n做梦 生存活动梦理论：梦源于大脑对白天吸收的信息的再处理，这些信息对有机体的生存很重要。 做梦可以增强我们对重要信息的记忆\n激活-合成理论：梦是各种记忆随机激活的结果，这些记忆在逻辑故事情节中交织在一起。\n白日梦：意识的一种常见变化，其中注意力转移到记忆、期望、欲望或幻想上，而远离眼前的情况。\n催眠 一种诱发的意识状态，通常以高度的暗示性、深度放松和高度集中的注意力为特征。\n冥想 一种意识状态，通常是通过专注于重复行为、采取某些身体姿势以及尽量减少外部刺激而引起的 冥想可以用来增强自我认识、幸福感和灵性。 降低新陈代谢率，降低心率和呼吸频率。 大脑活动类似于放松的清醒状态下的活动，伴随的血乳酸下降可以减轻压力。 Baars(1983)提出的综合工作平台理论（剧院模型）把意识看做是一套在整个大脑里传播信息的全局广播系统\n记忆 短时记忆存在的证据：自由回忆实验 自由回忆实验为两种记忆说提供了证据。\n记忆的多重结构 短时记忆、长时记忆、感觉记忆【又称为感觉登记、瞬时记忆，每一种感觉贮存保持的时间均非常短暂而且是感觉通道特异性的（即只局限于一种感觉通道）——ms为单位】。\n感觉记忆：视觉记忆、声象记忆（三耳人声象记忆）\n实验结果： 部份报告法正确率均优于全部报告法； 声象记忆的作用时间在4秒左右，显著高于视觉记忆的几百毫秒；声象记忆的容量为5个左右，而视觉记忆容量8~9个。\nAtkinson \u0026amp; Shiffrin 三级记忆模型（可能会出现） 简化的记忆信息三级加工模型： 记忆的加工水平理论 Craik \u0026amp; Lockhart（1972）对两种记忆说提出了尖锐的批评，提出了完全 相反的假设：即“信息加工——记忆”，区别于之前的“记忆——信息加工”\n存储是在编码深度这个维度上连续变化的。信息被存储的水平取决于被加工的深入程度。\n浅层加工：只涉及很少的对含义的注意  深层加工：涉及深层次的注意，专注于意义，并把它和其他事物关联 Craik 和 Tulving 的实验 不随意学习 短时记忆理论 短时记忆的信息量不是以信息论中的bit为单位，而是以组块（Chunk）为单位\n人利用贮存于长时记忆的知识，对进入短时记忆的信息进行合并，构成有意义的和熟悉的较大的单位\n分组 组块是有意义的，而即使无意义的组合，即分组，同样有利于短时记忆。（注意概念辨析）\n分组是时间、空间接近项目的合并；分组内部并不存在意义联系，也不构成一个熟悉的单位；分组可以增加短时记忆容纳的项目，但作用远小于组块。\n短期记忆信息的提取 短时记忆的提取是序列加工的，进一步是从头到尾进行扫描的，不会发生自我停止，即循环中不会发生break。 实验范式是相加因素法（相加罂粟法） 从头至尾扫描：类比于最优解（如 A星算法） 自我停止扫描：类比与满意解（如 A 算法）\n短时记忆的遗忘 探测法巧妙实现了两个因素间的解纠缠。 长时记忆理论 长时记忆分为陈述性记忆与隐形记忆。 陈述性记忆分为情景记忆与语义记忆。 隐形记忆分为启动效应和程序性记忆。 【长时记忆的神经生理学机制】 当一个刺激不断被重复时，突触产生结构改变，并导致激活频率的增加，这种激活频率的增加被称为“长时程增强效应”（long-term potentiation, LTP）。\n陈述性记忆 情景记忆是对个人在特定的时空背景下特定的经验或事件的记忆 语义记忆是个人关于世界的一般知识的记忆 语义记忆影响情景记忆 外显和内隐记忆 外显记忆受意识控制，测验时要求被试有意识地回忆早期学过的东西\n内隐记忆又叫自动的无意识记忆，测验时不要求有意识地去提取信息，专注眼前作业。\n启动效应（可能会考？）  先前信息潜在影响了后续任务的表现，并且人可能不曾意识到回忆过先前信息，这就是内隐记忆（Implicit memory），与外显记忆相对应。\n人几乎意识不到内隐记忆，它是启动效应研究的基础。\n剑桥大学的阈下启动实验 采用了LDT（词汇判断任务）实验设计范式，破坏视网膜上的视觉暂留，避免短时记忆的影响。\n阈下刺激：呈现时间非常短，被试甚至未察觉到刺激。\n程序性记忆 程序性记忆是针对“怎样做”或“如何做”事情的记忆，它以技巧性动作为基础，包括知觉技能、运动技能和认知技能的记忆。\n长时记忆的模型 层次网络模型的实验验证\n激活扩散模型\n激活扩散模型的验证——语义启动效应 情况1：说出一种水果名称是以A字母开头 情况2：说出一种以A字母开头的水果名称 结果解释：水果这个概念与其下级概念“Apple”等有紧密联系，扩散到“Apple”等结点的激活既多又快，接近其活动阈限，所以一旦接收到“A字母开头”就可很快出现激活交叉，说出“Apple”；但是，在情况2中，由于扇面效应，反应要慢；情况3中，因为增加了知识间的联系 ，可以克服扇面效应，如说出 “pineapple” 扇面效应 由于从一个给定的结点发出的激活总量是一定的，如与该结点相联的结点越多，则激活分配越分散，每个结点所得到的激活越少，因此提取就越慢和越困难，这就是扇面效应——符合能量守恒原理。\n特征模型 层次网络模型与激活扩散模型都属于网络模型范畴\n特征模型范畴主要包括以下两种： 1.集理论模型：概念由属性集或者特征集组成，诸特征同等重要，两个集之间的重叠程度越高，两个概念越接近——类比于汉明（Hamming）距离\n2.特征比较模型：将两个集的特征进一步细化为定义性特征（mandatory） 和特异性特征（optional），且特征按重要性排列，定义性特征高于特异性特征——类比于主成分分析（PCA）\n表征 表征的分类 意象表征 意象（Imagery）的定义：又被称为表象，是对在当前不被感知的事物形象的再现（记忆表象）或想象（想象表象），是一种心理上的类比表征。\n双重编码理论 人脑中同时存在两种信息编码和存储系统。\n表象系统对具体的事物或事件信息进行编码、存储、 转换和提取，其表征类似于知觉。\n言语符号系统主要用言语听觉、抽象概念或命题形式对信息进行加工。\n命题理论 意象表征 意象表征的理论模型 机能等价假设 认为视觉意象在功能上与视觉知觉相对等。\n证据支持：\n意象具有可操作性 定位实验 心理旋转、心理扫描实验 意象缩放实验 神经机能有重叠：脑成像脑损伤研究 【定位实验】 【心理旋转实验】180度时所需反应时最长；人的心理旋转速度约为180度/0.5s；\n【心理扫描实验】意象可以被扫描，扫描时间随距离而增加。\n【意象缩放】 评价主观意象较小的客体要难于较大的客体，这与知觉是相似的。 意象的功能：\n对学习记忆的促进作用：使用意义相近的名词进行成对的联想记忆学习。意象在字词识记中有中介作用，可以促进记忆学习。 对知觉的促进作用 对思维推理的促进作用 概念 认知心理学中概念研究的范畴：\n概念形成：也成为概念学习，是指个人掌握概念的过程，获得事物的概括表征 概念结构：概念的表征由哪些因素所构成，研究表征的内部组织 概念研究的早期阶段：\n刺激-反应原则：共同因素说（Hull，1920），共同中介说（Osgood，1953），强 调概念形成的被动性，忽略了人的主动性\n概念形成 假设-考验说：人在概念形成过程中，需要综合利用即时获得的、和已存贮的信息来主动提出一些可能的假设组成一个假设库，通过某种策略， 从记忆库中选取某种假设，并基于外界的反馈进行考验，直到形成某个正确的假设，形成概念。\n【人工概念的形成实验】\n被试的选择不是杂乱无章的，而是有着某种顺序；部分假设基于正实例的一个 属性建立未知概念的假设，而总体假设聚焦于正实例的所有属性\n策略选取 \n同时性扫描：同时进行多个概念 的假设和考验——记忆负担重  继时性扫描：一次只考验一个假 设——记忆负担轻但易重蹈覆辙  保守性聚焦：排除法，每次更换 一个焦点——优于上述两种策略  博弈性聚焦：一次更换两个以上 焦点——有可能快速发现概念 概念形成研究中的实验范式设计 渐进式还是阶跃式？ 【空白试验法】 概念结构 两种彼此对立的学说：特征表说（一类个体具有的共同重要特征来说明概念）；原型说（原型（最佳实例）表征出来的）\n特征表说 继承了层次网络模型，集理论模型、特征比较模型中对概念的语义特征表征方式。例如：鸟是动物与羽毛的合取。\n原型说 概念主要是以原型，即它的最佳实例表征的，人们能从最好说明一个概念的实例来理解该概念。\n最高等级的实例即为该概念的原型（最佳实例）\n原型的编码（很可能会考） Rosch 1975 匹配试验： 给被试同时呈现一对名词，要求被试尽快说出其范畴是否相同，记录反应时。 决策 贝叶斯推理和决策 人的推理方式是否遵循贝叶斯推理规则？Kahneman 和 Tversky（1972）却认为，人们的思维不符合概率理论，人们会忽略基础概率信息，而使用有偏差的启发式策略进行推理。\n决策框架 人们的决策会受到决策框架的影响 决策框架存在于每个人的头脑之中 问题表述 规范 习惯 个性 框架边界 必须始终明确决策的目标、必须突破老的边界的束缚。\n心理账户（理查德.塞勒） 制定理财计划 不同账户这一概念可以帮助制定理财计划。用于在心理上事先把这些钱一一归入了不同的账户，一般就不会产生挪用的念头\n政府制定政策 一个政府想通过减少税收的方法刺激消费，可有两种做法：\n减税，直接降低税收水平 退税，在一段时间后返还纳税人一部分税金 从金钱数额来看，减收5%的税和返还5%的税是一样的，但在刺激消费上的作用却大不一样 退还的税金对人们来说就如同一笔意外之财，刺激人们增加更多的消费。因此，对政府来说，退税政策比减税政策达到的效果要好得多。 参考点 在决策框架中参考点的作用就象一个坐标系中的原点。 \n参考点选择不同，同样一件事情该不该做，价值如何评价都会完全不同。\n框架标尺 在建立决策框架时，标尺选择不当，对决策的执行就可能失控。\n框架标尺的变化有时会对企业的发展起到导向的作用。\n不确定条件下的人类决策 丹尼尔·卡尼曼（Daniel Kahneman）： 他将认知心理学研究中得到的洞见整合进经济科学，尤其关注不确定条件下的人类判断与决策，阐明了人类决策如何系统地 偏离标准经济学的预测,奠定了一个新研究领域的基础。\n理查德· 塞勒（Richard Thaler）： 将心理上的现实假设纳入到经济决策分析中。通过探索有限理性，社会偏好和缺乏自我控制的后果，他展示了这些人格特质如何系统地影响个人决策以及市场成果。\n丹尼尔·卡尼曼前景理论的特色 与传统经济学理论的最大不同在于，前景理论在“有限理性”的基本假设上解释人类的决策行为。\n期望效用理论 在传统经济学中，冯·纽曼和摩根斯坦于1944年提出的期望效用理论（Expected Utility Theory，简称EU理论） 长期占据统治地位。  该理论认为，人类的决策行为总是期望使自己能够得到的效用为最大，因此，在做决策时，人们会使用自己的理性，根据自己掌握的所有信息做出最优的选择，即使在有风险的条件下依然如此——这就是“理性人”假设。  基于这个假设，期望效用理论认为，期望效用值最大的方案就是最佳决策方案。 有限理性和启发式 抛弃理性人假设，并不意味着人类没有理性，也不意味着人类不使用理性。 理性人假设的问题在于将人类理性的作用范围设定得非常大。 卡尼曼所依据的假设是“有限理性” 另一位诺贝尔经济学奖（1978年）的获得者赫尔伯特·西蒙（Herbert Simon）教授在1947年提出了“有限理性”这个概念。 【有限理性】\n任何动物的思维方式都有其认知局限性而且有赖于其生存的环境\n人的理性是有限的\n人们在做决策时，并不是去计算一个物品的真正价值，而是用某种比较容易评价的线索来判断\n满意原则 以最优为原则进行决策是理想人的专利。 真实人的决策无法坚持最优原则，而只能贯彻满意原则。 满意原则涉及四个基本问题： 有限目标 欲望水平 搜索方法：试探方法，随机方法，折衷方法 效益准则：在决策中尽可能以最少的代价获取满意的结果。 西蒙说：“效益准则指的是，在所用资源一定的情况下，选择能产生最大效益的备选方案。”\n经验和启发式 西蒙认为，由于人的信息加工能力是有限的，人不可能依据所能获得的全部信息做所谓完全“符合理性”的决策，而只能贯彻满意原则，即在决策中尽可能以最少的代价获取满意的结果，主要依靠的是经验和启发式（窍门）。\n著名的二八原则。\n启发式 几种常用的启发式：\n代表性启发式 指人们在决策中倾向于根据某种信息本身在一类别中的代表性，判断该信息属于 特定类别的概率。 易获得性启发式 一种认知捷径，指个体把他/她容易想象或回忆的事件视为与特定现象有关的实例，并基于此做决策。过去的经验误导决策。 锚定和调整策略（锚定-调整启发式） 指人们在获得新信息时，难以准确地修正他们对于事件的最初估计，其判断在很大程度上被“锚定”于事件的“初始值”。 前景理论 卡尼曼和特沃斯基还做了其他大量类似的认知心理学实验。他们的实验结果表明，在不确定条件下，人们所做的判断和决策系统地偏离了期望效用理论的预测，因此，人们并不是完全理性的决策者。\n前景理论的四个原理 大多数人在面临获得的时候是风险规避的 大多数人在面临损失的时候是风险偏爱的 人们对损失比对获得更敏感 参照依赖，多数人对得失的判断往往由参照点决定 【捐赠效应】\n生态理性 特沃斯基和卡尼曼的研究着重在理解人类思维能力本身的限制这个方面。\n当思维能力与环境合适地对应起来时，即使是有限的理性也会由于符合环境的要求而快速有效\n启发式的结构 启发式是由问题而决定的，用于解决不同的问题。\n共同的结构： 搜索规则（寻找环境中的信息和线索）\n停止规则（考虑到几条线索后停止搜索）\n决策规则（吃？跑？攻击？）\n四类借助直觉和常识的思维窍门 基于忽略的决策\n基于忽略的决策：忽略掉以前不曾遇到过的那个选项。 基于忽略的决策是最简单的决策方式，也最适用于限制条件极其严格的环境。 基于单原因的决策\n基于单原因的决策：做出选择的根据仅仅是一条信息。 因为要整合各种不同方面的信息就必须要将这些信息转换成一定数量的通货，然后才能比较这些信息的价值，并 且计算出行动结果的价值 基于多选项消除的决策\n有时没有任何一条评价标准适合于所有的选项。这时候人们就不能够仅用一条线索来衡量所有的选项。 在这样的情景下，多选项逐渐消除的决策方法，简单地说就是排除法，就可以发挥作用了。 基于满意原则的决策\n满意原则与前几类决策方式共同的一点是，它们都适用于同时遇到很多个选项的情况。 与它们不同的是，满意原则在各种选项按时间顺序依次出现时发挥作用。 心理捷径并不总是最好的选择\n一般来说，人们在有充足的时间时往往用复杂的推理 在紧迫情况下，人们用启发式 启发式在很广的范围内适用。\n关于窍门 在卡尼曼和特沃斯基看来，“窍门儿”是人类思维不够完善的标志，它们与人们常常会犯的偏误（Bias）联系在一起，因此他们用窍门儿来解释人们在推理中常常会发生与逻辑不一致的现象。\nGigerenzer 教授的研究显示出，对人类思维而言，窍门儿并不总是意味着偏误。尤其当我们考察发生在真实世界中的决策时，恰恰相反，窍门儿常常意味着用更少的时间，并且保证准确有效的思考。\n","date":"2025-02-23 15:00:00","updated":"2025-03-14 16:00:00"},{"objectID":"1740009600","permalink":"/post/daemon%E5%B0%8F%E8%AE%B0/","title":"daemon 与 服务","content":" 本文内容有待完善。\ndaemon，字面上意思为“守护神、恶魔”，通常没有 GUI 界面，是 Unix/Linux 环境的典型产物。具体表现为后台运行、不与终端交互的单个进程，是一种技术实现方式。 service，简单来说是系统为了实现某些功能必须要提供的一些服务，由系统服务管理器定义和管理的 entity，可以包含 daemon，具备依赖、失败处理等高级特性。 简言之：“所有 service 都有 daemon，但不一定所有 daemon 都是 service”。\n当然， 读者并不需要将daemon与service区分得如此细致。一般来说，在一个服务被建立之后，linux使用时，通常会在服务的名称之后加上d，例如atd，这个d代表daemon的意思。\nxixiboliya@laptop-tex4-of-boxing:~$ systemctl list-units --type=service --state=active --no-pager | grep \u0026#39;d\\.service\u0026#39; snapd.seeded.service loaded active exited Wait until snapd is fully seeded snapd.service loaded active running Snap Daemon systemd-journald.service loaded active running Journal Service systemd-logind.service loaded active running User Login Management systemd-resolved.service loaded active running Network Name Resolution systemd-udevd.service loaded active running Rule-based Manager for Device Events and Files 通过systemctl 查看单一服务 一般来说服务的启动有两个阶段，一个是开机的时候设置要不要启动这个服务，以及你现在要不要启动这个服务。查看服务树：systemctl status，找到其中一个服务进行解析：\nxixiboliya@laptop-tex4-of-boxing:/etc/init.d$ systemctl status system-getty.slice ● system-getty.slice - Slice /system/getty Loaded: loaded Active: active since Sat 2025-07-12 07:47:15 CST; 5h 47min ago Tasks: 1 Memory: 244.0K CPU: 2ms CGroup: /system.slice/system-getty.slice └─getty@tty1.service └─284 /sbin/agetty -o \u0026#34;-p -- \\\\u\u0026#34; --noclear tty1 linux Jul 12 07:47:15 laptop-tex4-of-boxing systemd[1]: Created slice Slice /system/getty. system-getty.slice是 agetty 程序运行起来的一个 登录终端服务实例，负责接收用户在 tty1 终端上的登录请求。\nLoaded：slice 单元已加载； Active：处于激活状态，表示 slice 当前是有效的； Tasks：这个 slice 下正运行的任务数量是 1； CGroup 路径：层级结构为 /system.slice/system-getty.slice/...，最后一行是 agetty 进程。 你可以通过systemctl stop xxx来结束服务。\nsystemctl list-units --type=service --all会列出所有的服务。\nxixiboliya@laptop-tex4-of-boxing:/etc/init.d$ systemctl list-units --type=service --all UNIT LOAD ACTIVE SUB DESCRIPTION \u0026gt; apparmor.service loaded inactive dead Load AppArmor profiles UNIT：项目的名称，包括各unit的类别 LOAD: 开机时是否会被加载，默认systemctl显示的是有加载的项目而已。 ACTIVE:目前的状态，需与后续的SUB搭配，就是我们用systemctl status查看的时候，active的项目，具体如下： 状态 含义 static 没有 [Install] 安装配置，无法被启用（enable），但可由依赖触发启动，如挂载点、socket 等。 masked 被“掩蔽”之后，其 unit 文件被链接到 /dev/null，无法被启动或启用，即使是依赖它的服务也无法调用，除非先 unmask 解锁 active (running) 服务正在运行中。 enabled 系统启动时会自动启动该服务。systemctl enable 命令创建软链接到目标 target 中。 disabled 不会自动启动；但可以手动启动或被其他服务触发启动。 failed 启动或执行过程中失败。 active (exited) 仅执行一次就正常结束的服务，目前不在运行。例如开机执行一次的quotaon功能。 active(waiting) 正在运行中，不过还需要等待其他事件发生才能正常进行。 题外话：什么是suspend？什么是休眠Hibernate？ Suspend：将系统状态（内存内容）保存到内存（RAM），其他硬件（如显示器、硬盘）断电。需要持续电力供给内存，才能保持当前运行的程序和文档。恢复速度快，几秒内可以回复到挂起前的状态。万一断电（如拔电源、耗尽电池）就会丢失未保存数据。 Hibernate（休眠）：将系统状态写入磁盘（swap 分区或 swap 文件），然后完全断电。不需任何电量亦可保持当前状态，适合长时间不使用时。恢复速度慢于挂起，需要读写磁盘才能恢复内存状态，但快过从头冷启动。通常恢复更安全，不会因断电而丢失数据。\n","date":"2025-02-20 00:00:00","updated":"2025-02-20 00:00:00"},{"objectID":"1737843480","permalink":"/post/proxylab/","title":"CMU Proxylab","content":"本文的所有配置、指令均以 Ubuntu 环境为例，而且假设你不具有桌面环境，只有纯命令行环境。\nPre-start 在工作目录下解压proxylab - handout.tar：\ntar -xvf proxylab-handout.tar -x：表示提取文件，也就是解压操作。 -v：用于显示详细的解压过程，方便你了解解压的进度和具体文件。 -f：指定要处理的文件名，后面紧跟要解压的 .tar 文件的名称。 以下是简要介绍，本文的根工作空间是proxylab-handout：\nproxylab-handout ├── Makefile ├── README ├── csapp.c |—— cache.c //自行编写的cache |—— cache.h //自行编写的chche |—— proxy.h ├── csapp.h ├── driver.sh //简单自动评分程序。进行基本的合理性检查。 ├── free-port.sh ├── nop-server.py ├── port-for-user.pl //给出偶数端口号，以便和Tiny web server 进行 testing。 ├── proxy.c //打印出一个特定的 HTTP `User-Agent` 头部信息到标准输出。用于标识客户端软件的类型和版本，服务器可以根据这个信息来提供不同的服务或内容。 └── tiny //tiny服务器 环境配置 配置linux 版本的chrome 和 chrome driver 。两者版本需对应，还有自动化测试工具Selenium，参考[Arthals\u0026amp;rsquo;ink环境配置](更适合北大宝宝体质的 Proxy Lab 踩坑记 • Arthals\u0026amp;rsquo; ink)\nwget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb sudo dpkg -i google-chrome-stable_current_amd64.deb rm google-chrome-stable_current_amd64.deb wget https://edgedl.me.gvt1.com/edgedl/chrome/chrome-for-testing/\u0026amp;lt;your …","date":"2025-01-25 15:00:00","updated":"2025-03-16 16:00:00"},{"objectID":"1737761400","permalink":"/post/ai%E6%A6%82%E8%AE%BA/","title":"人工智能概论复习笔记","content":" 导论部分 1956年的达特茅斯会议标志着AI诞生，图灵是人工智能之父。 机器智能的本质属性是自然性。 关于智能疑惑：多元智能理论、智能三元理论(分析、创造、实用)、智能发展理论\n==早期种子== ：\n逻辑与推理(符号学派) 自亚里士多德开始，是符号推理，并非所有智能行为都可调和为逻辑熟思，图灵第一次在纯数学的符号逻辑和实体世界间建立了联系。 图灵测试没有规定问题的范围和提问的标准，计算机能否在智力行为表现得和人无法区分 控制论(行为学派) 核心思想——控制、反馈和人机交互 ==三大学派==\n符号主义 观点：认知即计算(知识表达)，物理符号系统假设和有限合理性原理，人类认知和思维的基本单元是符号，认知过程就是符号的一种运算。自上而下 成果：知识回答，专家系统 、LISP表处理语言 连接主义 观点：认知即网络，人的智能是大量简单的人脑神经元细胞的复杂相互连接活动的结果，自下而上 。 成果：归纳学习、神经网络 行为主义 认知即反应(控制论)，智能行为的基础是基于“感知\u0026ndash;行动”的反应机制，系统与环境的交互作用，自下而上 蚁群算法、遗传算法、强化学习 三次爆发 突破(1956-1974) 推理期 符号主义盛行，专家系统发展很快 标志性基石：在统计方法中引入符号方法进行语义处理，出现了基于知识的方法。 出现了自然语言的相关程序：ELIZA、SHRDLU 1969年明斯基给机器学习连接学派致命一击：证明了感知机(第一代神经网络)不能学习任何问题。 寒冬：数学模型和手段有一定的局限性，并且计算复杂度指数级别增加。 (1980-1987) 知识期 进入知识阶段，连接主义盛行。多层神经元网络、反向传播算法 知识处理成为研究焦点。 寒冬： 缺乏实际应用，资助减少。 学习期(至今) 两大分类 符号智能，自顶而下，通过推理进行问题求解 计算智能，以数据为基础，通过训练建立联系 研究领域 机器学习：监督、无监督、强化(未标记数据集，但在执行一个或多个动作后，会向AI系统提供反馈) 深度学习 成功应用于Siri、Alexa等助手 视觉 llm Robotics 模糊逻辑系统 专家系统 self-driving cars 知识 知识的特性：相对正确性、不确定性、可表示性与可利用性 基于符号的知识表示方法：逻辑表示、语义网络表示、生产规则、框架表示 主要的知识表示方法有两种： 陈述性(静态特性，描述事物属性及其关系)，易于表示“做什么”，优点是形式简单、模块性好、可独立使用；缺点是不能直接执行。 过程性(知识的动态特性，表示推理和搜索)，描述规则和控制结构知识，易于表示“如何做 ”，优点是可以直接被计算机执行，易于表达启发性知识，缺点是不易表达大量知识、难于修改和理解。 谓词逻辑表示法(略) 优点：表达能力强，新旧知识逻辑一致性 一阶谓词具有完备的逻辑推理算法 缺点：难以表示过程和启发性知识 缺乏组织原则\n产生式表示法 确定性规则与不确定性规则的举例 如果动物会飞且动物会下蛋，则动物是鸟： IF 动物会飞 AND 动物会下蛋 THEN 动物是鸟。 如果发烧，就会感冒： IF 发烧 THEN 感冒 (0.6) 0.6是发烧的概率\n事实的表示 语言变量+关系+语言变量\n雪是白的 王五喜欢大交\n确定性事实的表示 一般使用三元组表示(对象，属性，值)或者(关系，对象1，对象2) 老张年龄45岁 =\u0026gt; ( Zhang , Age , 45 )\n老沈和老李是朋友 =\u0026gt; ( friend , shen , li )\n不确定性事实的表示 (对象，属性，值，置信度)或者(关系，对象1，对象2，置信度)\n老张年龄可能45岁 =\u0026gt; ( Zhang , Age , 45 , 0.8 ) 老沈和老李不太可能是朋友 =\u0026gt; ( friend , shen , li , 0.2 )\n一个生成式系统 语义网络表示法 语义基元(节点1，弧，节点2) 这个弧是有方向的。\n大脑\u0026mdash;\u0026mdash;\u0026ndash;part of\u0026mdash;\u0026mdash;-\u0026gt;人体 实例关系：ISA (is a) 泛化关系：AKO（A kind of） 成员关系：A-Menber-of 属性关系：AGE等 包含关系：Part-of 时间关系：before after 位置关系：Located-on 相近关系：similar to 推论关系：Reasoning to ==产生式表示法:if wang and li then friend== 知识图谱 框架表示法 状态空间表示法 ( S , O , $S_0$, G ) S是状态集合，O是状态转换集合，$S_0$是初始状态集合，G是目的状态集合，四元组。 ==传教士与野人问题==：过去时船上坐两人，回来时船上坐一人（不包括船夫），先考虑回来时船上坐一人，实在不行的话回来的时候船上也可以坐两人，注意行动不要与之前相违背。满足每一个状态的野人数量小于传教士数量。 ${S_0}(3,3,1)$，第一个3表示此岸的传教士数量，第二个3表示此岸的野人数量，1表示船是否停靠在此岸。 搜索求解 按照问题的表示方式可以分为：状态空间搜索、与或树搜索。 按照是否使用启发式信息可以分为盲目搜索和启发式搜索。\n状态空间搜索 很多搜索问题都可以转化成图搜索问题，状态空间图。 罗马尼亚旅行问题——搜索树\n盲目搜索 掌握==八数码问题==和==传教士与野人问题==的有限DFS和BFS，状态空间图是一样的。\n八数码的BFS也不是上来就写出那一层的所有接续状态。\nDFS是不完备搜索，不能保证找到最优解，可能会陷入死循环，所有限定深度强制进行回溯，存在搜索与回溯相交替出现的现象。\nBFS是完备的搜索，如果路径是非递减函数，则广度搜索是最优的，但是子节点较多的情况下，其消耗内存严重。\n图搜索包括穷举搜索和启发式搜索。\n属性 DFS BFS 完备性 不一定 完备（在分支因子b有限的前提下） 最优性 不具备 最优（路径是非递减函数） 时间复杂性 $b^m$ b是分支因子 $b^d$ $d$是解的深度 空间复杂度 $b^m$ $b^d$ ==掌握课堂练习：八数码问题==\n回溯 掌握N皇后问题。关键在于确定解空间树，建立递归的开始与结束条件，为了降低时间复杂度而剪枝，回溯要返回至问题未被修改的状态。 掌握罗马尼亚旅行问题。\n一致代价搜索 只考虑到当前节点的代价$g(n)$，挑最小的代价进行拓展。\n总是扩展路径消耗最小的节点N，N点的路径消耗等于前一节点N-1的路径消耗加上N-1到N的路径消耗。 在BFS上进行的拓展，使用优先队列并在边缘中的状态发现更小代价的路径时引入额外的检查，也称为代价一致搜索。 在搜索的时候每搜索一步，就在比较各个路径上的权重，来锚定下一次搜索。 掌握一致搜索的罗马尼亚旅行问题\n启发函数$h(n)$，其越小表明当前状态$n$越接近目标状态，\n评价函数 贪婪搜索 只依赖$h(n)$作为代价函数，不考虑到当前节点的代价$g(n)$。 仅依赖当前状态与目标状态间的剩余距离。是更聪明的“DFS”，因为有第三者信息告诉它每一个节点里目标还有多远，它只要选最小的那一个就行。\n==掌握罗马尼亚旅行问题的贪婪算法搜索树==\n贪婪最佳搜索不是最优搜索，启发函数代价最小化会对错误的起点比较敏感，比较依赖外部信息，是不完备搜索。 A 算法 ==掌握八数码的A算法==\n$f(n)=g(n)+h(n)$\n$g(n)$表示当前状态(节点)在深度树中的深度，$h(n)$表示当前状态(节点)中不在目标位置的数码个数。\nA* 搜索 最小化总的解决方案代价估计值的最佳优先搜索 $f^*(n)=g^*(n)+h^*(n)$ $g^*(n)$从起始点到节点n的路径最低代价 $h^*(n)$从节点n到目标节点的最低代价路径的代价\n掌握罗马尼亚的A* 搜索树 博弈搜索 在AI领域里的是指：有完整信息的，确定性的、轮流行动的，两个参与者的零和游戏。 博弈的基本要素：参加者、信息、策略、博弈次序、博弈收益。\n零和博弈，博弈方的利益始终对立，例如田忌赛马，剪刀石头布。\n囚徒困境不是零和博弈。 合作博弈 集体利益最大化 非合作博弈 个人利益最大化\n非合作博弈：完全（不完全）信息静态（动态）博弈\n问题规约的与或树 与树：把一个复杂问题分解成若干子问题的同时求解 或树：把一个复杂问题分解成若干与之等价的新问题的同时求解，这些新问题之间是“或”的关系 本原问题：不可能或者不需要再分解变换，并且可以直接解答的问题\n与或树求解代价计算示例 “按与点求和计算” “按与点最大值代价计算” 极小极大搜索 在有限的深度内使用深度优先搜索，利用递归回溯从可能的走法中选择对自己有利的走法，即对自己的收益最大、对手的收益最小。 或节点是max方，与节点是min方，我们站在max方思考问题，希望或（max）我们，与（min）他们。 极小极大搜索示例：井字棋搜索过程 每一种情况井字棋下面的等式是指，在该情况下，所有的剩下的格子全部填上对应的棋子，其中被减数是剩下格子全部填上x后，可以形成“三连”的个数，减数是填上o之后，可以形成的对于o的三连个数。\nAlpha-beta 剪枝 所谓Beta剪枝，是父节点是min节点的剪枝；Alpha剪枝，是父节点是max节点的剪枝。计算方法是，对于每一次由子节点（或者端点）回溯到父节点时，同时考虑父节点的父节点c（c的初始范围为无限制）的范围，若c的范围可以被更新，则不发生剪枝，反之发生剪枝。 这个蓝色的叉叉是……？ 参考列式： 囚徒困境：纳什均衡 每个人都是理性地追求自己的利益最大化，但得到的结果未必理性。\n智猪博弈和婆媳之争 注意2×2的表。 蒙特卡洛搜索 一边探索一边调整\n以增量和非对称方式构建树，每次迭代采用树策略。 树策略试图平衡考虑探索和利用 所选节点运行模拟并根据结果更新搜索树 每个搜索迭代分为四个不同的步骤: 树策略（选择，扩展）默认策略（模拟，回溯）每一个节点包括两个信息：收益值、次数。 搜索示例，中间省略去了扩展： 特点： 确定性推理 推理的基本概念：从已知事实出发，按照某种策略或者规则…… 推理必须依靠命题表达，推理有内容和形式两方面。\n推理的陈述与形式举例： 推理陈述：有些教师是女性，所以有些女性是教师 推理形式：有些P是S，所以有些S是P （所有M都是P，S是M，所以S是P） 推理的控制策略 推理方向 按照推理方向有正向、逆向、混合（先逆后正以及先正后逆）和双向推理。\n冲突消解策略 正向推理出现一条事实能与系统知识库中的多条知识匹配，或者多个事实能与同一条知识匹配；逆向推理中，同一个假设目标能与系统知识库中多条知识匹配，或多个假设目标能与同一条知识匹配。\n基本思想就是对匹配的知识或规则进行排序，以确定匹配知识规则的优先级别。\n常用的排序方法有： 就近原则排序 按知识特殊性排序，优先选择特殊性知识 按照上下文限制排序 按知识的新鲜性排序 按照知识的差异性排序 领域问题的特点排序 按照规则的次序排序 按前提条件的规模排序\n命题逻辑 悖论不是命题。 如果今天不封校，那么我去超市购物，除非我很累： $(\\neg Feng \\wedge \\neg Tired) \\to Shopping$\n掌握真值表、析取范式和合取范式（离散讲过了，故略） 但是复习还需要过一遍概念。例如：什么是二阶谓词？ 注意全称量词的消除。\n演绎推理 主要包括三段论、假言推理、选言推理等。从一般到个别 假言演绎推理： 三段法演绎推理 跟上述图片很像。。\n假言演绎推理 充分性条件假言推理： 判断标准：如果……那么……，若……则……，只要……就……。可以形象化记忆，前件在内。 必要性条件假言推理： 判断标准：只有……才……，不……不……。可以形象化记忆，后件在内。 完全归纳推理 从大量实例中总结出一般性结论的推理过程，是一种从个别到一般的推理，是自下而上的过程。前提所断定的知识范围和结论所断定的知识范围完全相同。\n男生都做了核酸检测，女生也都做了核酸检测，所以学生都做了核酸检测。 结果是必然的。 不完全归纳推理 例如：瑞雪兆丰年。\n枚举归纳推理 这样做的结论是或然的。 1）可靠程度是和事例数量相关的，得到的结果 肯定是正确的；2）效率低下，可能会造成时间崩溃；3）通常会涉及到求极值（ 如最大，最小，最重等）。\n演绎推理与归纳推理的区别：\n推理方向：演绎推理是从一般到个别，归纳推理从个别到一般。 结论断定范围：演绎推理的结论所得到的知识，没有超出前提所提供的知 识范围；而归纳推理的结论所得到的知识，却超出了前提所提供的知识范围。 演绎推理的前提数量是确定而有限的，归纳推理的前提数量通常不确定。 演绎推理是前提与结论之间有必然性联系（蕴含关系）的推理（即必然性推理）\n默认推理 在知识不完全的情况下作出的推理，在条件A已成立的情况下，如果没有足够的证据能证明条件B不成立， 则默认B是成立的，并在此默认的前提下进行推理，推导出某个结论。 自然演绎推理 归结推理 归结推理是对要证明为真公式取非，导出矛盾；而自然演绎推理是从已知为真的事实出发，运用经典逻辑的推理规则推出结论。\n反证法思想：把关于永真性的证明转化为关于不可满足性的证明，即要证明P→Q永真 ，可以转化为证明 $P \\wedge \\neg Q$是不可满足的。\n前束范式与谓词转换等 了解定理公式、辖域扩张、量词等价转换式……\nskolem范式 前缀仅含全称量词且辖域为母式全部 母式为合取范式，其中不含量词 有一种特定化的思想。 突然发现有点难看懂： 子句 原子命题公式 文字：原子谓词公式及其否定。 子句：任何文字的析取式，任何文字本身就是子句 空子句：不含任何文字的子句，不能被任何解释所满足，是永假，记为NIL 子句集：由子句或空子句构成的集合，其变元手全称量词约束，子句之间具有合取关系“与”。 $a \\leftrightarrow b \\Leftrightarrow (a \\wedge b) \\vee (\\neg a \\wedge \\neg b)$这是怎么推出来的…… 示例 子句集的子句间具有合取关系（“与“），各子句的变量实际上都是全称量词的 约束变量，且作用域只在子句范围内。\n为消除子句间不必要的交互作用，各子句可使用不同的变量名。\n在消去存在量词是所用的Skolem函数可以不同，化简后的标准子句集是不唯一的。\n当原谓词公式为非永假时，它与其标准子句集并不等价。\n当原谓词公式为永假（或不可满足）时，其标准子句集则一定是永假，即Skolem 化不影响原谓词公式的永假性。\n谓词公式永假《= =》子句集不可满足性\n海伯伦域 H域 将每次新增的项丢到下一次的迭代里，本例中没有个体常量。 鲁滨逊归结 谓词逻辑文字互补与置换 谓词逻辑的归结示例与原理 归结反演示例： 结果应该是一个NIL 归结反演记得写出子句集，子句集中相同变量应该进行换名处理。\n归结原理求解示例： 与归结反演不同的是，证明的命题不太具有“是否”的表达，例如：“小张的老师是谁”而不是“王是小张的老师” 解题上则是对待求解问题表达成否定，之后再与谓词Answer(x)构成析取式。 注意谓词表示。例如“如果x和y是同班同学，则上课时x的教室也是y的教室”。 往往不同的子句会推出不同的结论，子句的选取重要。\n思维导图 不确定性推理 贝叶斯公式，单证单论 ： 概率推理 多证多论： odd几率函数定义（获胜概率/落败概率）\n主观贝叶斯 $IF\\quad E \\quad THEN \\quad (LS,LN) \\quad H\\quad p(H)$ H代表一般性的结论，S代表所有证据的一部分，可以表示为我们观测到的数据现象，E代表所有的证据。$LS$ 、$LN$用于度量知识的不确定性，LS是充分性度量，LN是必要性度量。\n证据充分性的度量 p(H|E)=1。\n$$\\frac{{p(H|E)}}{{P(\\neg H|E)}} = \\frac{{p(E|H)}}{{p(E|\\neg H)}}\\frac{{p(H)}}{{p(\\neg H)}},LS = \\frac{{p(E|H)}}{{p(E|\\neg H)}}$$$$\\frac{{p(H|\\neg E)}}{{P(\\neg H|\\neg E)}} = \\frac{{p(\\neg E|H)}}{{p(\\neg E|\\neg H)}}\\frac{{p(H)}}{{p(\\neg H)}},LN = \\frac{{p(\\neg E|H)}}{{p(\\neg E|\\neg H)}}$$ 证据必要性的度量：$O(H|\\neg E) = 0$\n$LN = \\frac{{O(H|E)}}{{O(N)}}$,$LN = \\frac{{p(\\neg E|H)}}{{p(\\neg E|\\neg H)}}$ 杜达公式 带鱼胆固醇含量高。 $p(H|S) = p(H|E)p(E|S) + p(H|\\neg E)p(\\neg E|S)$ (100,0.01) 代表$LS$为100， $LN$为0.01. $O(H|{E_1},{E_2}) = O(H) \\times L{S_1} \\times L{S_2}$ 可以这样叠加。 先观察$P(E_1|S_1)$题目给的是否大于0.5，若大于0.5，则求$P(H_1|E_1)$。 杜达公式有概率考察，需要防备，但ppt上的推导略微简略。 ==掌握主观贝叶斯应用——天气预报==，这玩意有两种计算方法： 知识的不确定性表示：可信度因子(CF)模型 可信度因子的定义为信任与不信任的差 $CF(H,E)=MB(H,E)-MD(H,E)$ CF(H,E)$\\in$$\\rm{[ - 1,1]}$ MB (measure belief)信任度量：表示证据E对前提结论H的信任增长度 MD (measure disbelief) 不信任度量：表示证据E对前提结论H的不信任增长度\n若 CF(H,E)\u0026gt;0，CF(H,E)的值越大，则证据E支持结论H越真 若CF(H,E)\u0026lt;0 ，CF(H,E) 的值越小，则证据E支持结论H越假 若 CF(H,E)=0，则证据E的出现与否与H无关。 可信度CF是由领域专家题目提出的。 $CF(H|E) + CF(\\neg H|E) = 0$ 不确定性推理 $CF(H) = CF(H,E) \\times \\max \\{ 0,CF(E)\\}$\n结论不确定性的合成 重点：==掌握可信度计算示例== 先算出每个证据的可信度 $E_1(0.6)$ 这个代表的是证据的权重$w$，$E_6(0.8,0.75)$中，$0.8$是可信度，$0.75$是阈值。 先算$CF(E_6)和$$CF(E_7)$，再$\\frac{{0.7CF({E_6}) + 0.6CF({E_7})}}{{(0.7 + 0.3)}}$=$CF({\\bar E})$，$CF({\\bar E})$与阈值0.6进行比较发现$CF({\\bar E})$比0.6大，于是使用$CF({\\bar E})$。$R_3$那一句的$CF(R_3)=CF(H,E)$，再使用$CF(\\bar E)*CF(H,E)$，得到$CF(H)$。 证据理论 信任函数$Bel$（下限）与似然函数$Pl$（上限） $Bel({r,y})=m({r})+m({y})+m({r,y})$ $Pl({r})=m({r})+m({r,y})+m({r,y,g})$ 所有与r有关的m的求和。 $[Bel(A),Pl(A)]$表示信任区间。 概率分配函数正交和的示例，举一个例子就很好懂了。 四步走：\n先求出识别框架和m集合的可能取值，以及概率分配表。 求K 综合求出$m_1({h_1})$这样的，使用正交和公式 $m(\\{ {h_1}\\} ) = \\frac{1}{K}\\sum\\limits_{x \\cap y = \\{ {h_1}\\} } {{m_1}(x){m_2}(y)}$ 最后求$Bel({h_1})$等信任函数、似然函数$Pl({h_1})$，对此一定要参考识别框架。 中间跳过了一些。 笑话一则 与诸君共赏。 基于证据理论的不确定性推理 例题是这样的： Zadeh悖论 感觉很有特点，掌握一下，两组概率分配函数正交和。 答案可能有问题。 在自动驾驶时某个具体道路场景中无人车前方会有四种命题假设：（A）有障碍物，（B）无障碍物，（C）有障碍物或者无障碍物，（D）空集 （既不是有障碍物，也不是无障碍物，就是没法判断），使用2个车载传感器进行检测。 1）LiDAR作为证据源之一，在某个时刻对某个位置各个假设的分配概率分别为：A的概率是0.6，B的概率0.3，C的0.1，D的概率为0； 2）相机作为另一个证据源之一，在某个时刻对某 个位置各个假设的分配概率分别为：A的概率是 0.1，B的概率0.8，C的0.1，D的概率为0， 现要求融合2个传感器的障碍物检测数据，判断障碍物的存在情况。贴一个结果：\n模糊推理方法 在模糊逻辑中，一个命题不再非真即假，它可被认为是“部分的真” ，模糊逻辑取消二值之间非此即彼的对立，用隶属度表示二值间的过度状态。 zadeh表示法 模糊集合的表示包含该集合的元素、该元素属于这个集合的隶属度。 通常用“隶属度/元素”的形式表示模糊集合。 首先，确定论域{5，10，20，30，35} 其次，确定对应隶属度{0，0.33，1，1，0.5} 再者，求出隶属函数$m_A$： 模糊集合的基本运算 相等 在隶属函数在论域上相等 包含 隶属函数在论域上${m_A}(x) \\le {m_B}(x)x \\in U$ 并集 交集 补集（论域在(0,1)上的补集）\n$A \\oplus B$对应系数相加，与1相比用小的那一个。 经典集合关系和笛卡尔乘积 集合关系：不同集合元素间的关联，通常用笛卡尔乘积(Cartesian product)定义 用来求模糊集合A到B的隶属关系 $R = A \\times B = {\\bf{m}}_A^T \\times {\\bf{m}}_B$ $m_B,m_A$就是一个行向量就是其模糊函数的系数，按上图就是$[0.3,0.8,0.7,0.1]$\n模糊关系的合成，先合取再析取，乘法取min，加法取值max： 笛卡尔乘积。 模糊推理以及模糊决策： 智能体Agent 智能体的重要组件：传感器执行器效应器，环境收到效应器的影响，例如腿、屏幕。 分为理性智能体和全职智能体，理性是使理想效应最大化，使用的是到当前的感知序列。\n智能体与环境 PEAS表示 performance environment actuators sensors 请举例无人驾驶汽车的PEAS，掌握： 性能（P）：速度、驾驶安全（汽车和用户）、开车到特定地点的时间、用户的舒适度等 环境（E）：汽车行驶的道路、道路上的其他车辆、行人、十字路口、路标、交通信号等 执行器（A）：转向、油门、 刹车、信号、喇叭、音响等所有用于控制汽车的设备 传感器（S）：摄像头、GPS 、车速表、里程表、加速度计 、声纳等汽车通过其获得对周围环境的估计并从中得出某些感知的所有设备\nAgent的任务环境（了解即可） 完全可观察（象棋） vs 部分可观察（驾驶）（Fully Observable vs Partially Observable） 确定性（象棋） vs 随机性（驾驶）（Deterministic vs Stochastic） 竞争 vs 合作（Competitive vs Collaborative） 单智能体（单人迷宫） vs 多智能体（足球赛）（Single-agent vs Multi-agents）\n智能体的环境类型（Types of Environments） 静态 （空房子）vs 动态（过山车）（Static vs Dynamic） 离散 （象棋）vs 连续 （驾驶）（Discrete vs Continuous） 片段（问答机器人） vs 延续（网球） （Episodic vs Sequential）\n智能体与结构 行为 架构 函数 以感知历史作为输入 程序 以当前感知环境作为输入\n智能体的形式：人类智能体、机器人智能体、软件智能体\n智能体的特点：情境性、自主性、适应性、社交性\n智能体的类型（掌握） 简单反射智能体（simple reflex agents） ==仅根据当前感知采取行动。== 该智能体基于条件—动作规则工作，该规则将状态（即条件）映射到动作，如果 条件为真，则执行操作，否则不执行。 仅当环境完全可观察时，该智能体才会成功。\n基于模型的反射智能体（model-based reflex agents） 智能体可在部分可观测环境中工作，使用内部模型来确定动作的感知历史和效果， 并跟踪状态，该智能体的2个重要因素： 模型（model）：关于“世界事情如何发生的知识”。 内部状态（internal state）：基于感知历史的当前状态的表示。 智能体具有“哪个是世界知识”的模型，并基于此模型查找其条件与当前情况匹配的规则执行动作，通过使用此关于世界的模型来处理部分可观察的环境。 ==在无法完全观察的环境中仍可工作==，须跟踪由每个感知调整的内部状态，并依赖感知历史。\n随时更新内部状态信息 要求在Agent程序中加 入两种类型的知识： 知识一：世界是如何独立于Agent而发展的信息 知识二：Agent自身的行动如何影响世界 缺点：部分可观察环境中的Agent不能精准确定当前状态\n基于目标的智能体（goal-based agents） 特点 ： Agent 需要一个目标来了解期望达到什么状况。 随着达到目标所需要的动作数目的增多，问题越来越难求解。 支持它决策的知识被显示表现出来，且可以修改,虽然显得效率较低，但更灵活。 适合部分可观察、动态的、连续式的。 基于效用的智能体（utility-based agents） 推荐算法 学习智能体（learning agent） 所有Agent都可以通过学习来改进它们的性能。\n智能体的应用(略) 自动驾驶、医疗诊断等。。\n","date":"2025-01-24 15:20:00","updated":"2025-02-16 16:06:00"},{"objectID":"1737756600","permalink":"/post/%E4%BA%BA%E5%B7%A5%E6%99%BA%E6%85%A7%E4%B8%8E%E7%8E%B0%E4%BB%A3%E7%89%A9%E7%90%86i/","title":"人工智能与现代物理Ⅰ复习笔记","content":" 经典物理部分 本部分不做详尽说明。\n牛顿运动定律+微积分\n速度：$v(t) = \\frac{{dr(t)}}{{dt}}$\n加速度：$a(t) = \\frac{{dv(t)}}{{dt}}$\n冲量定理：$Fdt = d(mv)$\n角动量定理 掌握如何计算刚体转动惯量\n$M = \\frac{{dL}}{{dt}} = I\\frac{{d\\omega }}{{dt}}$\nM为力矩，L为动量矩（角动量），I为转动惯量。\n$\\int {{r^2}dm = I}$ ${L_0} = J\\omega$ ${{\\bf{L}}_0} = m{\\bf{r}}\\times v$ ${\\bf{M}} = {\\bf{r}} \\times {\\bf{F}}$\n对于动量矩定理而言， 质点系对一点（或一轴）的角动量对时间的导数等于外力系对此点（或此轴）的主矩，广泛用于处理刚体定点（或轴）转动问题。角动量定理的微分形式为dL/dt=M。\n简谐波 $$y(x,t) = \\cos (\\omega t - \\frac{{\\omega x}}{u} + {\\varphi _0})$$$$y(x,t) = \\cos (\\omega t - \\frac{{2\\pi x}}{\\lambda } + {\\varphi _0})$$ $u$是传播速度，$\\lambda$是波长。\n弹簧振子的能量和势能、总机械能。\n波的干涉、叠加 两个同频同方向简谐振动的合成：合振动仍为简谐振动，合振动的振幅取决于两个分振动的振幅以及相位差，即$A = \\sqrt {A_1^2 + A_2^2 + 2{A_1}{A_2}\\cos ({\\varphi _2} - {\\varphi _1})}$。\n两列波在空间各点相遇后叠加的振幅仅依赖于所在位置而不随时间变化的谐振动分布，这种波叠加现象为相干叠加。\n什么是相干叠加条件 ：两列简谐波频率相同、振动方向相同（一致）、相位差恒定。\n考察两个同方向的振动：${x_1} = A\\cos ({\\omega _1}t + {\\varphi _1})$和${x_2} = A\\cos ({\\omega _2}t + {\\varphi _2})$。 什么是拍现象：对于两个同方向的波，两个分振动频率不相同但是相差不大，即$|{\\omega _1} - {\\omega _2}| \u003c \u003c \\frac{{{\\omega _1} + {\\omega _2}}}{2}$，将会变成一种特殊的振动称为拍现象，表达式为 $x = {A'}\\cos (\\frac{{{\\omega _1} + {\\omega _2}}}{2}t)$ 。其中 $A' = 2A\\cos (\\frac{{{\\omega _1} - {\\omega _2}}}{2}t)$ 。拍的特点是合振动以与分振动相近的频率振动，振幅不再是一个常数，而是在缓慢的变化。\n热力学四大定律 热力学四大定律都是什么？ 第零定律：若两个热力学系统均与第三个系统处于热平衡状态，此两个系统也必互相处于热平衡。\n第一定律：物体内能的增加等于物体吸收的热量和对物体所做的功的总和 。$\\Delta U = Q - W$。能量不能凭空消失或者销毁，只能从一个系统转移到另一个系统。但是在转换过程中，能量的总值保持不变。其推广和本质就是著名的能量守恒定律。\n第二定理：说明一个孤立系统不可能朝低熵的状态发展，即不会变得有序。\n第三定理：绝对零度不能被达到。\n能量按自由度均分定理 $$\\overline \\varepsilon = \\frac{1}{2}(t + r + s){k_b}T$$ ${k_b}$是玻尔兹曼常数，单原子分子为 $\\overline \\varepsilon = \\frac{3}{2}{k_b}T$ ，双原子分子为 $\\overline \\varepsilon = \\frac{5}{2}{k_b}T$ ，多原子分子为 $\\overline \\varepsilon = 3{k_b}T$ 。单原子分子的平动自由度为3，转动自由度和振动自由度为0。双原子分子的有3个平动自由度，又有2个转动自由度，总共有5个自由度 i = t + r =3 + 2 = 5。理想情况下s都是0.\n气体的平均动能仅与温度有关，温度相同则相同。$\\frac{1}{2}m{v^2} = \\lambda {k_b}T$。理想气体的内能仅与温度有关。对于理想气体，其内能满足$\\Delta U = {C_v}\\Delta T$。理想气体内能的积分表达式：$U = \\int {{C_v}dT + {U_0}}$。\n理想气体内能 如何计算理想气体的内能？\n$$\\Delta U = \\frac{i}{2}nR \\Delta T$$ 其中单原子分子取$i=3$，双原子分子取$i=5$，多原子分子取$i=6$。\n$$\\Delta W = p\\Delta V = nR\\Delta T$$$$\\Delta U = \\frac{i}{2}W,Q = \\Delta U + W = \\frac{{i + 2}}{2}W$$ 可以求出吸热多少。\n高斯定理 $$\\mathop{{\\int\\!\\!\\!\\!\\!\\int}\\mkern-21mu \\bigcirc} {{\\bf{E}} \\bullet d{\\bf{S}}} = \\frac{1}{{{\\varepsilon _0}}}\\sum {{q_i}}$$ $\\sum {{q_i}}$为封闭曲面S所包围的所有电荷电量的代数和。\n对于一个半径为R的带点球面，我们取半径为r的高斯面包住球体，我们需要求高斯面上某一点的电场强度E。\n黑体辐射 辐射出度：单位时间单位表面积发射的各波长总辐射能。\n黑体辐射的单色吸收比：是指一个物体在某一特定波长下的吸收能力，通常用 $\\alpha(\\lambda)$ 表示，其中 $\\lambda$ 是波长。黑体的单色吸收比在任何波长上都是 1，意味着它在任何波长下都完全吸收辐射。而对于非黑体物体，吸收比$\\alpha(\\lambda)$的值可能小于 1，表示该物体在该波长下并未完全吸收辐射。\n理想黑体可以吸收所有照射到它表面的电磁辐射，并将这些辐射转化为热辐射，其光谱特征仅与该黑体的温度有关，与黑体的材质无关。理想的黑体辐射模型有$\\alpha(\\lambda,T)=1$，可以视作在容器上开一个小孔。\n$$U = \\frac{{4\\sigma }}{c}{T^4}$$ 上式可以用来求温度T。U代表了黑体的辐射能量密度。$\\sigma$是常数为$5.67 \\times 10^{-6}W/m^2 * K^4$。\n光电效应 存在截止频率，光的频率低于某一个特定频率，将无法产生光电效应。 $E = hv$，$p = \\frac{h}{\\lambda }$。\n三个特点：当光的频率小于特定频率时将不会产生光电效应；瞬时性；电子的最大初动能和光照频率呈线性关系。\n为什么经典的电磁理论解释不了光电效应？ 第一，不能解释为什么存在截止频率，且不随光强变化。 按照波动光学的观点，无论频率是多少，只要光强大，时间长，电子就能获得足够的动能脱离阴极。 第二，不能解释为什么存在截止电压，且只随频率变化。 按照波动光学的观点，脱离阴极的电子的动能应该正比于正比于光强和照射时间，因此电子动能上限应随着光强和照射时间而变化。也就是截止电压会随着光强变化。 第三，即使光很弱，光电效应的反应时间还是很快，而且不随光强变化。 按照波动光学的观点，在特定截止电压下，产生光电效应的时间应该与光强成反比，但是无论何光强，只要满足截止频率和截止电压的要求，光电效应的产生时间都在10e-14s量级。 爱因斯坦光电效应与光量子:\n$\\frac{1}{2}m{v^2} = hv - W_0$，其中$W_0$为逸出功。\n截止电压：$U=(hv -W_0)/e$，即在金属板上施加反向U的电压会让光电子刚好无法脱离金属板。\n狭义相对论 基本原理 狭义相对性原理：任何真实的物理规律在所有惯性系中应形式不变。\n光速不变原理：任意一个惯性系中的观测者所测得的真空中的光速恒为c。\n推论 时空观\n由两条基本原理可严格地导出惯性系之间时空坐标变换的方程组，即洛伦兹变换。与伽利略变换不同：\n（1）相对地面静止的S惯性系观测到的同时事件在相对地面匀速运动的S’系看来是不同时的，即同时的相对性。\n（2）同一根尺子，相对尺匀速运动的观测者比相对尺静止的观测者测量的杆长要短，即尺缩效应。\n$$ t = \\frac{{t'}}{{\\sqrt {1 - v_0^2/{c^2}} }},L = L_0\\sqrt {1 - v_0^2/{c^2}} $$ $t'$称为原有的时间，$t$是观测者测量的时间。$L_0$为原有的长度，L是测得的长度。我们要知道，比如有两个惯性系，发生了相对运动，当相对速度趋于零的时候，尺缩效应会消失。（助教说的）\n某以宇航员想去距离地球5光年的星球旅行，如果他希望将这一路程缩短为3光年，则他所乘的火箭相对于地球的速度应是：0.8c\n$3 = 5\\sqrt {1 - \\frac{{{v_0}^2}}{{{c^2}}}}$ ，解得0.8c.\n广义相对论 广义相对性原理：物理规律对于所有参考性具有协变性。\n这意味着，无论你选择哪个坐标系统（惯性参考系或非惯性参考系），物理定律的形式应该是相同的。 等效原理：物体的惯性质量和引力质量相等。\n$$d{s^2} = {g_{\\mu v}}d{x_\\mu }d{x_v}$$ 其中，$ds^2$是时空中的间隔（或称“度量”），$g_{μν}$​ 是度规张量，引力场的性质主要取决于度规张量的函数。$dx_μ$ 和 $dx_ν$是在坐标系中两个点之间的微小位移。这个公式提供了一种计算两点之间“距离”的方式，重要的是，这个“距离”并不一定是直觉中的欧几里得距离，尤其是在弯曲时空中。度规张量（Metric Tensor）以及它的本质 - 知乎。\n$$d{s^2} = {\\left( \\begin{array}{l} d{X_1}\\\\ d{X_2} \\end{array} \\right)^T}\\left( {\\begin{array}{*{20}{c}} {{g_{11}}}\u0026{{g_{12}}}\\\\ {{g_{21}}}\u0026{{g_{22}}} \\end{array}} \\right)\\left( \\begin{array}{l} d{X_1}\\\\ d{X_2} \\end{array} \\right)$$ 在 平直时空（即没有引力场的时空）中，时空是完全平坦的。最著名的例子是 闵可夫斯基时空，它描述了特殊相对论中的平直四维时空。\n在平直时空中，度规张量​$g_{μν}$ 的形式，其他位置都是0。但是查阅发现： 助教给的是：diag={1 -1 -1 -1}。我们依照助教给的进行分析。 现代物理 量子波动理论 量子力学中的 波动理论（Wave Theory）是理解粒子行为的核心思想之一。它主要来源于 波粒二象性（Wave-Particle Duality），即粒子既可以表现为粒子，又可以表现为波动。这一理论为量子力学的基础之一，它解释了粒子如何在某些情况下表现为波动现象，尤其是在干涉和衍射等现象中。\n波粒二象性是量子力学中的一个基本概念，它由路易·德布罗意（Louis de Broglie）提出，指出所有物质粒子都具有波动性质，粒子不仅表现出粒子的特性（如碰撞和局部化），同时也具备波动的性质（如干涉和衍射）。\n德布罗意假设：每个粒子都有与其动量 $p$ 相关的波长 $\\lambda$，其关系由 德布罗意波长公式给出： $\\lambda = \\frac{h}{p} = \\frac{h}{mv}$​\n其中，$h$ 是普朗克常数，$p$ 是粒子的动量，$m$ 是粒子的质量，$v$ 是粒子的速度。\n这意味着不仅光子（电磁波）具有波动性质，任何具有动量的粒子（如电子、质子等）也都可以展现出波动性。\n量子波的相干叠加性、衍射 量子波的相干叠加是量子力学中一个至关重要的概念，它揭示了量子系统可以同时处于多个状态，并且这些状态可以相互叠加。这个现象并不是经典物理所能解释的，且是量子力学的一大特点。量子波的相干叠加性与经典物理中的叠加（如合力叠加）有着本质的不同，通常通过波动函数来描述。\n量子力学中的粒子（例如电子、光子等）并不简单地像经典粒子那样具有固定的轨迹，而是以波的形式存在，描述其位置和动量的不确定性。这些波通常由波函数 $\\psi (x,t)$ 来表示，它是描述量子态的数学工具，具有如下性质：\n波函数的模平方 $|\\psi (x,t){|^2}$ 代表粒子在某一位置 $x$处被测量到的概率密度。 波函数本身是一个复数，包含振幅（与概率有关）和相位信息（与干涉效应和相干性有关）。 量子波的相干叠加性最著名的实验之一是双缝实验。在这个实验中，一个粒子（例如电子或光子）通过两个狭缝时，可以同时通过两个缝隙，其波函数是两个波的叠加。当它们在屏幕上干涉时，形成了典型的干涉图样。这表明粒子在通过两个缝隙时并不是选择其中一个，而是以波的形式同时通过两个缝隙，这种相干叠加现象使得干涉成为可能。\n在这个实验中，粒子的波函数 $\\psi (x,t)$ 由于叠加效应，在屏幕上形成了明暗相间的干涉图样，代表着不同路径的波动相位发生了干涉。\n提问：\u0026quot;什么实验装置会满足量子干涉和量子衍射以及量子波的条纹是如何形成的\u0026quot;\n对于电子的物质波衍射实验，戴维逊认识到之前所作的电子的散射实验很可能就是电子衍射的结果。如此成功地验证了电子具有波动性。 乔治汤姆逊发表了电子波存在的进一步实验，用加速后的电子束打到很薄的铂金属表面，形成了环状电子波衍射图样。\n更具有波动特征的电子波双缝干涉实验在1961年完成。电子是一个一个经过双缝而发生的干涉，说明干涉条纹或者说电子的波动性，并不是产生于不同电子之间“干扰”或者相互作用，而是电子自相干的性质或者电子自有的特征。\n物质波是概率波的理论由伯恩提出。对于波函数形式为$\\psi ({\\bf{r}},t) = {\\psi _0}{e^{i(kr - \\omega t)}}$的粒子，$|\\psi ({\\bf{r}},t){|^2} = \\rho ({\\bf{r}},t)$表示粒子的概率分布，而且由概率的归一化性质有${\\int {|\\psi ({\\bf{r}},t)|} ^2}dV = 1$。波函数是概率波，满足连续性（求解一维无限深势井）、归一化的性质。\n物质波的相干叠加 $$\\psi = \\sum {{a_i}} {\\psi _i}$$其中 $\\sum {{a_i}} = 1$。一个粒子，可以同时处于空间上可能被分开的物质波的状态。\n薛定谔方程 角动量的量子化必须满足驻波的条件，轨道长度必须是波长的整数倍。 算符的基本运算 $$\\overline x = \\int_{ - \\infty }^{ + \\infty } {|\\psi (x,t){|^2}xdx}$$$${\\overline p _x} = \\int_{ - \\infty }^{ + \\infty } {{\\psi ^*}(x,t)} ( - i\\hbar \\frac{d}{{dx}})\\psi (x,t)dx$$$$(\\phi ,\\widehat O\\psi ) = \\int {{\\phi ^*}\\widehat O\\psi d\\tau }$$ 加法运算 $$(\\widehat {{O_1}} + \\widehat {{O_2}})\\psi = \\widehat {{O_1}}\\psi + \\widehat {{O_2}}\\psi $$ 乘法运算 不能交换次序$\\widehat {{O_1}}\\widehat {{O_2}} \\ne \\widehat {{O_2}}\\widehat {{O_1}}$。\n定义两个算符的对易形式： $[\\hat{A}, \\hat{B}] = \\hat{A} \\hat{B} - \\hat{B} \\hat{A}=i\\hat{c}$ 。如果$\\hat{c}$为0，则是互易。\n位置和动量算符对易证明： 逆运算 $${\\widehat O^{ - 1}}\\psi = \\varphi $$ 算符的函数 $$f(x) = \\sum\\limits_{n = 0}^\\infty {{{{f^{(n)}}(0)} \\over {n!}}{{\\hat O}^n}} $$ 算符的转置运算 $$(\\phi ,\\hat O\\psi ) = \\int {{\\phi ^*}\\hat O\\psi d\\tau = } \\int {\\psi \\widetilde {\\widehat O}{\\phi ^*}d\\tau = } ({\\psi ^*},\\widetilde {\\widehat O}{\\phi ^*})$$ $(A,B)$算符运算要求在积分中，对A进行复共轭。\n厄米算符 $${\\widehat O^ + } = \\widehat O \\equiv {\\widehat {\\widetilde O}^*}$$$$\\widehat O = {\\widehat O_ + } + i{\\widehat O_ - }$$ 其中${\\widehat O_ + } = {1 \\over 2}(\\widehat O + {\\widehat O^ + })$,${\\widehat O_ - } = {1 \\over {2i}}(\\widehat O - {\\widehat O^ + })$都是厄米算符。\n本征函数的正交性和完备性 $$({\\psi _m},{\\psi _n}) = {\\delta _{mn}}$$$$\\sum\\limits_{n = 1}^N {|{\\psi _n}{|^2}} = 1$$这个条件说明了算符${\\widehat O }$的本征函数${\\psi _n}$具有完备性，任意的位置空间中的波函数（归一化）都可以用$\\psi_n$作为基矢进行展开：$\\sum\\limits_{n = 1}^N {{c_n}{\\psi _n}} = \\psi$。其中$\\sum\\limits_{n = 1}^N {|{c _n}{|^2}} = 1$，${c_n} = ({\\psi _n}^*,\\psi )$。\n狄拉克符号 掌握两个矢量的内积的定义。 正交矢量的表示和归一化条件。 $\\left| {} \\right\\rangle$用来表示希尔伯特空间中的态矢量，$\\left\\langle {} \\right|$用来表示右矢的共轭矢量。具体的，右矢往往对应于列矢量，左矢往往对应于行矢量。本征函数加上狄拉克符号变为本征态。\n右矢的厄米共轭${\\left| a \\right\\rangle ^ + }: = \\left\\langle a \\right|$ 算符A乘算符B的厄米共轭：${({O_1}{O_2})^ + } = {O_2}^ + {O_1}^ +$\n厄米算符的本征值是实数，有$\\widehat O\\left| \\psi \\right\\rangle = \\lambda \\left| \\psi \\right\\rangle$。 厄米算符的本征态是正交的。\u0026lt;$\\psi$|$\\psi$\u0026gt;=0 本征态可以归一化。\u0026lt;$\\psi$|$\\psi$\u0026gt;=1 \u0026lt;$\\psi$|$\\psi$\u0026gt; 称为内积，可以看作行向量乘列向量：$\\left( {{a_1} \\ldots {a_n}} \\right)$$\\left( \\begin{array}{l}{a_1}\\\\\\vdots \\\\{a_n}\\end{array} \\right)=1$. 内积也可以表示为:$$\u003c\\psi|\\varphi\u003e =\\int {{\\psi ^*}\\varphi d\\tau}$$ |$\\psi$\u0026gt; \u0026lt;$\\psi$|叫做外积。 ==两个矢量带算符的内积为==： \u0026lt;$\\psi$|A|$\\psi$\u0026gt;:=\u0026lt;$\\psi$|$\\cdot$ (A|$\\psi$\u0026gt;)=(\u0026lt;$\\psi$|A)$\\cdot$ |$\\psi$\u0026gt;=$\\int {{\\psi ^*}A\\psi d \\tau}$。\n$$\\left\\langle {{O_m}|\\left. {{O_n}} \\right\\rangle } \\right. = {\\delta _{mn}}$$$$\\sum {\\left| {{O_n}} \\right\\rangle } \\left\\langle {{O_n}} \\right| = 1$$注意下面的计算：\n$\\left| \\psi \\right\\rangle = \\alpha \\left| 0 \\right\\rangle + \\beta \\left| 1 \\right\\rangle + \\gamma \\left| 2 \\right\\rangle$\n$\\left\\langle \\psi \\right| = {\\alpha ^*}\\left\\langle 0 \\right| + {\\beta ^*}\\left\\langle 1 \\right| + {\\gamma ^*}\\left\\langle 2 \\right|$\n\u0026lt;$\\psi$|$\\psi$\u0026gt;=${\\alpha ^*}\\alpha\u003c0|0\u003e$ +${\\beta ^*}\\beta\u003c1|1\u003e$+${\\gamma ^*}\\gamma \u003c2|2\u003e$=1\n回顾性质：$\\left\\langle {{O_m}|\\left. {{O_n}} \\right\\rangle } \\right. = {\\delta _{mn}}$ $m=n$时 $\\delta _{mn} = 1$\n即：${\\left| \\alpha \\right|^2} + {\\left| \\beta \\right|^2} + {\\left| \\gamma \\right|^2} = 1$\n这确保了量子的规范性。\n量子信息比特 这里深入了解信息比特：\n量子信息导论(Introduction to Quantum Information)笔记 - 知乎\n量子信息理论笔记：量子态 密度矩阵 相干性 退相干演化 纠缠 缠结度\u0026amp;负熵 （Updating\u0026hellip;） - 知乎\n对于著名的Bell态或称之为EPR关联对为$\\frac{1}{{\\sqrt 2 }}(\\left| {00} \\right\\rangle + \\left| {11} \\right\\rangle )$，即当${a_{01}} = {a_{10}} = 0$且${a_{00}} = {a_{11}} =\\frac{1}{{\\sqrt 2 }}$时，Bell态表示，比特1和比特2或者同时处于$\\left| {00} \\right\\rangle$态，或者同时处于$\\left| {11} \\right\\rangle$态；而同时测量一个比特的状态，将会等概率的处于$\\left| 0 \\right\\rangle$或者$\\left| 1 \\right\\rangle$的其中之一。\n不可克隆性及其证明 由于量子体系的波动性，量子态的实际内涵表示的是量子体系处于某个状态的概率分布。只有通过大量测量，量子体系处于某些本征状态的概率分布才能被知道。我们想要克隆大量量子，以便进行多次测量。\n能否对量子态进行克隆？我们定义一个一个克隆操$\\widehat U$，这个克隆操作是一个幺正操作。\n==证明如下==：\n$U = {e^{ - i\\widehat O}}$ ，${\\widehat O}$是厄米算符。幺正操作满足$\\widehat U{\\widehat U^ + } = I$ 、 ${\\widehat U^ + }\\widehat U = I$。幺正算符的特征值是单位模$|\\lambda|=1$。\n$\\exists \\left| \\psi \\right\\rangle , \\left| \\varphi \\right\\rangle , \\left| e \\right\\rangle$ ，其中$\\left| e \\right\\rangle$是辅助态。\n$\\widehat U(\\left| \\varphi \\right\\rangle \\otimes \\left| e \\right\\rangle ) = \\left| \\varphi \\right\\rangle \\otimes \\left| \\varphi \\right\\rangle$，其中$\\left| \\varphi \\right\\rangle \\otimes \\left| e \\right\\rangle$表示第一个比特和第二个比特分别处于$\\left| \\varphi \\right\\rangle$和$\\left| e \\right\\rangle$的测量状态。\n同理，$\\widehat U(\\left| \\psi \\right\\rangle \\otimes \\left| e \\right\\rangle ) = \\left| \\psi \\right\\rangle \\otimes \\left| \\psi \\right\\rangle$。\n因为我们是对于任意量子态$\\left| \\varphi \\right\\rangle \\left| \\psi \\right\\rangle$，一般不相等，所以$\u003c \\psi |\\varphi \u003e \\ne 1$。\n$\u003c \\varphi |\\psi \u003e = (\\left\\langle \\varphi \\right| \\otimes \\left\\langle e \\right|){U^ + }U(\\left| \\psi \\right\\rangle \\otimes \\left| e \\right\\rangle )$\n$= (\\left\\langle \\varphi \\right| \\otimes \\left\\langle \\varphi \\right|)(\\left| \\psi \\right\\rangle \\otimes \\left| \\psi \\right\\rangle )$\n$= {( \u003c \\varphi |\\psi \u003e )^2}$\n则：若$\u003c \\varphi |\\psi \u003e=0$，那么这两个本征态正交，若$\u003c \\varphi |\\psi \u003e=1$，则说明$|\\varphi\u003e$和 $|\\psi\u003e$相同。\n只能满足上述特定条件下才成立，故量子具有不可克隆性。\n","date":"2025-01-24 15:00:00","updated":"2025-02-15 16:00:00"},{"objectID":"1737670200","permalink":"/post/%E5%A5%87%E6%80%AA%E5%B0%8F%E6%8A%80%E5%B7%A7/","title":"一些奇怪小技巧","content":" Shields.io徽章制作 在浏览 GitHub 时，你可能发现很多项目都有很漂亮的徽章。这些徽章可以用来显示项目版本、进度条、star 数量、fork 数量\u0026hellip;.，那么这些徽章是如何生成的呢？\n准确的说，这种 badges 是可以在任何地方使用的，但是一般来说还是在 Github 里面见到的会多一些，所以干脆就在描述中添加一个 Github 的前缀。\n其实这些徽章大多都出于一个网站 shields，里面不仅可以生成静态的徽章，也可以生成动态显示stars的徽章。\n在Shields.io 网站中，进去默认展开的是静态徽章Static Badge。 在右侧可以看到四个内容，分别是：\ntitle：badge 的文字描述。 color：badge 的背景色，使用 hex 编码表示（不包括 #）。 logoname：badge 的 logo 名称。 logocolor：logo 的颜色，使用 hex 编码表示（不包括 #）。 在下图中，logo需要严格按照simple icon中的名字规定，#FCC624规定了徽章的背景色。比如，我找到了微信的图标，只需在simple icon的“logo”栏输入“WeChat”，即可让微信的图标出现在徽章上。 在badgeContent中，一般的输入可以是label-(optional)message-color，即【第一段内容】-【第二段内容】-【颜色】 ，中间使用-隔离。\n在badgeContent要输入空格或者下划线等内容可以参考下面：\nURL input Badge output Underscore _ or %20 Space Double underscore __ Underscore _ Double dash -- Dash - 例如输入python-\u0026gt;=3.10.0-blue: 与此同时，Shields.io也会生成对应的markdown供你使用。 在这里建议将 logo 颜色设置为白色，然后背景色设置为网页中推荐的那个 logo 的配色，会比正常设置要有质感一些，比如说显示 vitepress，就可以使用：\n![](https://img.shields.io/badge/vitepress-5C73E7?style=for-the-badge\u0026amp;logo=vitepress\u0026amp;logoColor=FFFFFF) 应用举例 例如，我需要obsidian的图标： 其中，#7C3AED来自simple icon的obsidian图标,复制之后填在badgeContent中的color字段中即可。 windows 中需要管理员权限才能删除文件夹 遇到错误： 在 Windows 中以管理员权限删除文件夹时，若遇到 “你需要管理员权限” 或 “Access denied” 等提示，通常是因为当前用户或 UAC 权限不足、或目标文件夹仍归系统/TrustedInstaller 所有。以下是建议操作步骤和对应命令方法：\n实际上意思是：即便你当前账号是管理员，但 Windows 判断你缺少对该文件夹的所有权或控制权（ownership/control），导致即便是你本人也无法删除。这类问题非常常见，以下是解决方案。\n1. 以管理员身份打开命令提示符或 PowerShell 在开始菜单搜索 cmd 或 PowerShell，右键选择 以管理员身份运行，确保具有足够权限\n2. 接管文件夹所有权与权限控制 若文件夹归 TrustedInstaller 或非当前用户所有，需先接管其所有权并授权：\n运行以下命令：\ntakeown /F \u0026#34;C:\\路径\\目标文件夹\u0026#34; /R /D Y icacls \u0026#34;C:\\路径\\目标文件夹\u0026#34; /grant administrators:F /T icacls \u0026#34;C:\\路径\\目标文件夹\u0026#34; /reset /T takeown 用于接管目标资源的所有权\nicacls /grant 将管理员组授予完全控制权限\nicacls /reset 重置访问控制列表使权限生效\n3. 删除文件夹 Remove-Item -LiteralPath \u0026#34;E:\\mywebsite2\\目标文件夹\u0026#34; -Recurse -Force Recurse：递归删除所有子项；\nForce：删除只读文件、隐藏文件等；\nLiteralPath：处理路径中存在特殊字符或空格的文件夹名称\n","date":"2025-01-23 15:00:00","updated":"2025-07-14 16:00:00"},{"objectID":"1737331200","permalink":"/post/bomblab/","title":"CMU CSAPP bomblab phase1 ~ phase5 解答","content":" 写在前面 贴一个下载链接CS:APP3e, Bryant and O\u0026rsquo;Hallaron (cmu.edu)，点击Self-Study Handout下载lab。\n/* Do all sorts of secret stuff that makes the bomb harder to defuse. */ initialize_bomb(); printf(\u0026#34;Welcome to my fiendish little bomb. You have 6 phases with\\n\u0026#34;); printf(\u0026#34;which to blow yourself up. Have a nice day!\\n\u0026#34;); /* Hmm... Six phases must be more secure than one phase! */ input = read_line(); /* Get input */ phase_1(input); /* Run the phase */ phase_defused(); /* Drat! They figured it out! 在进入到phase_1之前，对于input = read_line()函数，我们查看一下input变量的地址，使用gdb bomb命令进入gdb调试阶段，再通过查看反汇编代码确定input = read_line()函数return时的栈顶指针%rsp所指向的内容，先设置断点，为了方便，使用touch ~/.gdbinit命令创建一个默认配置，具体可以参考这个链接。\n在x86-64架构中，返回值会通过特定的寄存器传递。在此架构中，返回值通常存放在 RAX 寄存器中。因此，当你的函数执行到 ret 指令时，返回值会放入 RAX 寄存器，建议在phase_1之前输入p $rax查看寄存器rax的值。\n下图描述了进入explode_bomb()的gdb调试界面，代表这个炸弹即将爆炸： gdb调试命令 gdb //命令 step //步进 layout regs //寄存器变量视图 p/d $rdi //十进制查看变量%rdi的值 x/s $esi //以c风格查看%esi的字符串 x/2d $rsp //十进制查看$rsp开始的两个单位，栈指针 info registers //打印所有寄存器的值 info breakpoints // 打印所有断点的信息 // %rip 储存下一条指令的地址 调试命令示例： 可以看到，在返回read_line 函数后，%rax寄存器的值被保存到了%rdi中，%rdi的值是6305664，%rsp是栈顶指针。\nstring_length复现 if (rdi != 0) { rdx = rdi; rdx = rdx + 1; eax = rdx; rax = rdi if (rdx != 0) 则跳到 rdx = rdx + 1; } 接下来一起解答。\nPhase_1 mov $0x402500, %edi ; 假设这是第二个字符串的地址，放入 %edi call 401338 \u0026lt;strings_not_equal\u0026gt; ; 调用函数比较两个字符串 传入\u0026lt;strings_not_equal\u0026gt;的参数有两个%esi和%rdi\n%esi：通常用来传递第一个指针或地址类型的参数给函数。在字符串操作函数中，它经常被用来传递源字符串的地址。 %edi：通常用来传递第二个指针或地址类型的参数给函数。在字符串操作函数中，它经常被用来传递目标字符串的地址。 Linux遵循System V AMD64 ABI 调用约定，具体来说，函数传参的时候前六个整数或指针参数通常分别通过寄存器 RDI, RSI, RDX, RCX, R8, R9 传递。 也就是说，我们只需要查看%esi的值就行了，在0x400ee9设置断点，输入x/s $esi得到： 于是我们返回到psol.txt中写下这句话，注意不要漏了标点。 Phase_2 第一步，通读代码了解跳转结构，\u0026lt;read_six_numbers \u0026gt;函数告诉我们应该在psol.txt文件下写入6个数字。 接着，我们可以在0x400f0e、0x400f1e、0x400f3a处设置断点(主要是前面两个)，这三处都是跳转语句。对于(%rbx)，使用x/d $rbx或者x/2d $rbx查看十进制的值，对于%eax，可以使用p/d查看十进制的值。\u0026lt;read_six_numbers \u0026gt;的返回结果先存在于%rsp中，随后第一位数字被“吃掉”，剩下的数字放在了(%rbx)中。 接着： 接下来，当gdb每一次在0x400f1e处停下时，我们可以通过p/d $eax查看%eax的值，修改对应的%rbx的值就可以了，最后答案是1 2 4 8 16 32。\nphase_3 首先观察代码结构，凭借个人经验在je、ja、jmp处打上breakpoints，很明显phase_3的代码有switch关键字。 在sscanf函数之前添加断点，使用(gdb) x/s $esi可以看到两个%d %d，这提醒我们输入十进制的两个数字。在400f6a处提醒我们输入的第一个数字应当小于7，我这里输入的是7。在400fb9和400fbe可以看到第二个数字应该等于0x137,也就是327。\n解开答案，调试界面输出： phase_4 我们注意到了这一句话，结合上一题的经验，很有可能在提醒我们应该有两个输入。 于是我们在psol.txt中写下：999 666。 continue!\nphase_4 step1 我们在调试时发现： 这意味着输入的第一个数字应该小于等于14。\nphase_4 step2 在调试时，遇到了难点\u0026lt;func4\u0026gt;它是一个递归函数，我们需要让其返回值%rax的值等于0，这样才不会触发0x40104f的跳转： func4 这段代码类似于二分查找，发现其有极高的对称性。当输入的rdi(应该是rdi)为1时，func4函数返回值为0。\nphase_4 step3 0x401051启示我们输入的第二个参数为0。 因此答案：1 0 phase_5 先标好跳转结构： 看到函数string_length和cmp $0x6 %eax输入应该是长为6的字符串，于是我们在psol.txt中写下：\n\u0026#39;xjtu\u0026#39; 在0x4010bd处，我们发现： 'xjtu' -\u0026gt; snoies, snoies作为输入时，$rsp+0x10的值是就变成了snoies=\u0026gt;uylfeu。我们需要某六个数字，使得变换之后的结果是flyers。这究竟是什么样的映射呢？ 这个过程不可谓不离奇曲折，但是当我们知道了具体的过程之后，就可以很容易地得到答案了。\n首先，我们先去维基百科找来一张 ASCII 码表： 分析 在0x4010778处， xor %eax,%eax执行异或操作，将EAX寄存器与自身进行异或。由于任何数与自身进行异或的结果都是0，这条指令通常用于将EAX寄存器的值快速清零。\nmovzbl 指令是一个数据传送指令，从内存地址 %rdx + 0x4024b0 处读取一个字节（8位）的值，将这个字节值移动到EDX寄存器的最低位字节，之后将EDX寄存器的高位24位填充为零。\n在0x40108b到0x4010ac，我们可以看到一个循环，直到%rax的值满6方能离开，但是这个循环中的代码十分难懂。\n以输入'xjtu'为例，在循环中我们发现寄存器%rcx的变化，分别是115=》110=》111=》105=》101=》115，分别对应 snoies的acsii码，而读取'xjtu'的寄存器%rcx，值分别是39=\u0026gt;120=\u0026gt;106=\u0026gt;116=\u0026gt;117=\u0026gt;39，在下面语句设置断点发现%rdx的值就此变化：\n401099: 0f b6 92 b0 24 40 00 movzbl 0x4024b0(%rdx),%edx 4010a0: 88 54 04 10 mov %dl,0x10(%rsp,%rax,1) 我们尝试破解它，在循环任意一处打上断点后，我们对movzbl 0x4024b0(%rdx),%edx进行探索，它将0x4024b0作为地址偏移量，读取一个字符，将其转换为无符号32位整数值放入$edx，接着%edx的最低八位寄存器%dl将字符入栈。现在调整地址偏移量看看： 以'xjtu'的输入中的'为例子，在0x401099处： 以'xjtu'的输入中的x为例子，在0x401099处(%rdx未变化)： 以'xjtu'的输入中的j为例子，在0x401099处： 以'xjtu'的输入中的t为例子，在0x401099处： 以'xjtu'的输入中的u为例子，在0x401099处： 结合下面指令会发现取了%rcx的低位为%rdx寄存器的初始值。\n401096: 83 e2 0f and $0xf,%edx 于是会发现一个很奇怪的字符串aduiersnfotvbyl，第七个是s，第八个是n，与%rdx初值刚好相等。至此，在psol.txt中输入:ionefw即可，答案不唯一。 这代表我们 ：Success！\nphase_6 (已烂尾) 看来又是读入六个数字，0x401121及其附近告诉我们第一个数应该小于等于5。 %rbx寄存着读入数字的个数。\n未完待续……\n","date":"2025-01-20 00:00:00","updated":"2025-01-20 00:00:00"},{"objectID":"1737331200","permalink":"/post/docker/","title":"docker与dev container插件的使用","content":" 本文侧重1.讲解docker的插件使用。2.视觉consimulation项目的跨环境迁移\n基础配置 安装vscode。 在vscode安装 Docker 插件与ms-vscode-remote.remote-containers插件。 Docker 学习 这里可以参考：阮一峰docker教程、菜鸟教程docker、雪雁docker\n容器container是镜像image的实例化。\n生成 dockerfile 一种途径是自行编写dockerfile，另一种途径是使用插件自动生成再进行修改。\ndockerfile的编写：知乎、CSDN\n无论是自行编写还是自动生成，需要知道的是，镜像image是由多个“层”组成的。每一层都是镜像构建过程中的一个步骤，每次 Docker 执行一个命令（例如 RUN、COPY、ADD 等）时，都会生成一个新的层。这些层共同构成了 Docker 镜像的内容。就使用dev container而言，dockerfile应该仅包含环境配置，不应该包含对应的项目功能代码包。\n自动生成示例：\n使用Docker扩展可以非常方便的从VisualStudio Code构建，管理和部署容器化应用程序，可以自动生成dockerfile、docker-compose.yml和.dockerignore文件（按F1并搜索Docker：将Docker文件添加到Workspace） Add Docker Files to Workspace用于生成一个单独的 Docker 配置文件（Dockerfile）和与之配套的基础配置文件。可能还会生成与应用环境相关的文件，例如 .dockerignore。 Add Docker Compose Files to Workspace 用于生成支持多服务编排的 Docker Compose 配置文件（docker-compose.yml）。如果你的项目需要多个服务（例如后端服务、数据库服务、缓存服务）共同运行，这是更适合的选项。 接着：根据项目选择基本配置，由于不同项目需要配置不同，跟着导引选择。 ASP.NET Core 是用于构建 Web 应用程序的跨平台框架，适用于构建现代化的 Web 服务和应用。它支持 HTTP 请求处理、Web API、WebSocket、以及其他网络相关的功能。 Console 应用是一个基于命令行界面的应用程序，通常用于执行后台任务、处理批量操作、定时任务等。 这些信息自行GPT即可。\nbuild 上面步骤完成之后，你的项目会有dockerfile和.dockerignore，或许会有docker-compose.debug.yml、docker-compose.yml。\n在资源管理器中选中dockerfile并且右键点击，找到build image..选项，接着输入\u0026lt;镜像名\u0026gt;:\u0026lt;标签\u0026gt; 这一步相当于:docker build -t \u0026lt;your-image-name\u0026gt;:\u0026lt;your-tag\u0026gt; .\n-t your-image-name:your-tag：这里你可以指定镜像的名称和标签。例如，your-image-name 是镜像的名称，your-tag 是标签（如 latest 或 v1.0）。 .：表示 Docker 构建上下文是当前目录，这意味着 Docker 会在当前目录下查找 Dockerfile。 接着等待结果。注意保持网络畅通无阻，在git clone into..这一步很容易Failed to connect to github.com port 443: Timed out 。 这样就算构建image成功了： 这时候你将在docker插件页面的左侧中见到刚刚 build 的 consimulation:2.0.0，如下图。registeries可以连接到dockerhub和github账号，不过本人dockerhub的状态一直是fetch failed。\n可以在终端输入docker images查看已经构建的images。docker container ps则可以查看目前正在运行的容器的CONTAINER ID、镜像名称、端口映射等等状态。 右键点击刚刚build的image，可以看到run和run interactive两个选项:\nRun 是直接启动容器并执行指定的命令。这通常用于容器启动后不需要用户干预的场景。容器在后台运行，不会直接打开交互式终端，适合用于以下情况： Run Interactive 则是以交互模式启动容器，并附加到容器的终端。这意味着你可以与容器内部进行交互，通常是进入容器的命令行（shell）进行操作。 此时也可以在终端输入docker run -it --rm \u0026lt;image_name\u0026gt;:\u0026lt;tag\u0026gt; /bin/zsh。这里的/bin/zsh是启动容器时执行的命令，也可以是/bin/bash等等，取决于dockerfile的配置。-it中 -i 表示以交互模式运行容器，-t 会为容器分配一个伪终端（terminal），这使得你能够与容器进行交互。--rm代表容器在退出后会被自动删除。这意味着容器停止后会被清除，不会留下任何痕迹。\n启动示例： 在vscode中下载dev container插件，ctrl+shift+p选择rebuild and reopen in container。\n接着会发现，我们的image实例化之后的容器虽然在build时没有包含代码功能包，但我们是可以发现存在于本地项目下的代码功能包却在dockercontainer开发容器中。这样就可以对已经构建的容器进行测试了。。\n.devcontainer文件 当你build好image之后，这时你的的image还在本地，本机可以作为宿主机。\nVisual Studio Code Dev Containers扩展允许您使用Docker 容器作为功能齐全的开发环境。项目中的文件告诉 VS Code 如何使用定义良好的工具和运行时堆栈devcontainer.json访问（或创建） Dev Containers 。该VS Code 的容器配置存储在devcontainer.json文件中。该文件类似于用于launch.json调试配置的文件，但用于启动（或附加到） Dev Containers 。\n这一部分可以参考：vscode 文档、一起学docker \u0026lt;=讲的挺好的\n使用docker插件自动生成: 按下F1，输入add development container configuration files... 选择：来自dockerfile。\n选择配置：\n编写流程：\n1、在 Command Palette 中，使用 Remote-Containers: Add Development Container Configuration Files 命令开始配置开发容器\n2、按需编辑 .devcontainer 文件夹的内容\n3、使用 Remote-Containers: Reopen in Container 来验证自己的配置是否可行\n4、如果看到错误，在弹出的对话框中选择 Open Folder Locally\n5、在窗口重新加载之后，控制台中会出现一份 build log （构建日志），以便查找问题点。再次按需编辑 .devcontainer 文件夹的内容。（如果你把构建日志关闭了以后，又想再看一下的话，可以使用 Remote-Containers: Open Log File 命令再次打开）\n6、运行 Remote-Containers: Rebuild and Reopen in Container 命令，如果需要，回到第 4 步。如此反复。\n如果你已经成功构建了容器，仍旧可以在连上容器以后，按需编辑 .devcontainer 文件夹里面的内容。之后在 Command Palette 中，选中 Remote-Containers: Rebuild Container 命令，让修改的内容生效。\n编写好.devcontainer/devcontainer.json文件之后，就能畅通无阻使用ctrl+shift+p在开发容器玩耍了。\ncon_simulation视觉代码 由于dockerhub难以连接上(蚌埠住了)，假设原镜像有n层，本人build的n+1层镜像无法push到dockerhub，因此使用母镜像，经过测试确实能够使用，只不过镜像并不是本人的：\ndocker pull lihanchen2004/pb_rm_simulation:1.0.0 接着在rcgogs代码仓库git clone consimulation代码，用vscode打开，ctrl+shift+p，输入并点击 Dev Containers:Rebuild and Reopen in Container。\n示例： 附上json文件：\n{ \u0026#34;name\u0026#34;: \u0026#34;con_simulation\u0026#34;, //本次的容器名称 \u0026#34;image\u0026#34;: \u0026#34;lihanchen2004/pb_rm_simulation:1.0.0\u0026#34;, // dev container 连接到的本地镜像名，可以用docker images命令找到对应的名字 \u0026#34;runArgs\u0026#34;: [ \u0026#34;--init\u0026#34;, \u0026#34;--gpus=all\u0026#34;, \u0026#34;--privileged\u0026#34;, \u0026#34;--env=NVIDIA_DRIVER_CAPABILITIES=all\u0026#34;, \u0026#34;--env=DISPLAY=${localEnv:DISPLAY}\u0026#34;, \u0026#34;--env=QT_X11_NO_MITSHM=1\u0026#34;, \u0026#34;--volume=/tmp/.X11-unix:/tmp/.X11-unix\u0026#34;, \u0026#34;--network=host\u0026#34; ], \u0026#34;customizations\u0026#34;: { \u0026#34;vscode\u0026#34;: { \u0026#34;extensions\u0026#34;: [ \u0026#34;llvm-vs-code-extensions.vscode-clangd\u0026#34;, \u0026#34;vadimcn.vscode-lldb\u0026#34;, \u0026#34;xaver.clang-format\u0026#34;, \u0026#34;ms-python.python\u0026#34;, \u0026#34;ms-iot.vscode-ros\u0026#34;, \u0026#34;ms-vscode.cmake-tools\u0026#34;, \u0026#34;usernamehw.errorlens\u0026#34; //拓展名，具体怎么来的可以参考上面的[一起学docker]链接。 ] } } } ","date":"2025-01-20 00:00:00","updated":"2025-01-20 00:00:00"},{"objectID":"1737072000","permalink":"/post/%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E5%9F%BA%E7%A1%80/","title":"存储系统基础","content":"存储系统分为四类：\n单机存储 File-system Key-Value 单机数据库 关系型和非关系型 分布式存储 分布式文件系统GFS HDFS等 对象存储TOS 分布式数据库：关系型(MySQL Oracle)和非关系型数据库 分布式存储选型 在TOS中，所有的数据都存储在“桶”中。桶是容器，可以理解为用于组织存储对象的命名空间。每个桶都具有唯一的名字，并可以设置权限来控制谁可以访问。 存储对象使用 先在TOS上申请一个Bucket，里面可以存放很多objects。此外，TOS提供了丰富的RESTful API，可以实现文件的上传、下载、删除、查询等操作。\n对象存储对外提供的一般都是Restful风格的接口。\nrestful风格：[参考链接1](https://zhuanlan.zhihu.com/p/334809573)、[参考链接2](https://www.runoob.com/w3cnote/restful-architecture.html) 以资源为基础 ：资源可以是一个图片、音乐、一个XML格式、HTML格式或者JSON格式等网络上的一个实体，除了一些二进制的资源外普通的文本资源更多以JSON为载体、面向用户的一组数据(通常从数据库中查询而得到)。RESTful风格的API则要求在URL上都以名词的方式出现，从几种请求方式上就可以看出想要进行的操作，这点与非RESTful风格的API形成鲜明对比。 统一接口: 对资源的操作包括获取、创建、修改和删除，这些操作正好对应HTTP协议提供的GET、POST、PUT和DELETE方法。换言而知，使用RESTful风格的接口但从接口上你可能只能定位其资源，但是无法知晓它具体进行了什么操作，需要具体了解其发生了什么操作动作要从其HTTP请求方法类型上进行判断。具体的HTTP方法和方法含义如下： - GET（SELECT）：从服务器取出资源（一项或多项）。 - POST（CREATE）：在服务器新建一个资源。 - PUT（UPDATE）：在服务器更新资源（客户端提供完整资源数据）。 - PATCH（UPDATE）：在服务器更新资源（客户端提供需要修改的资源数据）。 - DELETE（DELETE）：从服务器删除资源。 @PutMapping(\u0026#34;/dogs/{id}\u0026#34;) //`@PutMapping(\u0026#34;/dogs/{id}\u0026#34;)`：这是Spring注解，它将HTTP请求（路径为`/dogs/{id}`的PUT请求）与 `updateDog()` 方法绑定。 public ResponseEntity\u0026lt;String\u0026gt; updateDog(@PathVariable int id, @RequestBody Dog dog) { dog.setId(id); // 设置ID boolean isSuccess = dogMapper.updateDog(dog); if (isSuccess) { return new ResponseEntity\u0026lt;\u0026gt;(\u0026#34;Dog updated successfully\u0026#34;, HttpStatus.OK); } return new ResponseEntity\u0026lt;\u0026gt;(\u0026#34;Failed to update dog\u0026#34;, HttpStatus.BAD_REQUEST); } MultiUpload 接口 对于GB数据大对象： Web应用：允许用户一次上传多个文件，如在照片库中上传多个图片文件。 云存储服务：例如AWS S3、Google Cloud Storage等支持批量上传文件。 实现 前端：通过HTML表单的\u0026lt;input type=\u0026quot;file\u0026quot; multiple\u0026gt;属性允许选择多个文件。\n\u0026lt;form action=\u0026#34;/upload\u0026#34; method=\u0026#34;POST\u0026#34; enctype=\u0026#34;multipart/form-data\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;files\u0026#34; multiple\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;Upload\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; 后端：\n@PostMapping(\u0026#34;/upload\u0026#34;) public ResponseEntity\u0026lt;String\u0026gt; handleMultiFileUpload(@RequestParam(\u0026#34;files\u0026#34;) MultipartFile[] files) { for (MultipartFile file : files) { System.out.println(\u0026#34;Uploading: \u0026#34; + file.getOriginalFilename()); } return ResponseEntity.ok(\u0026#34;Files uploaded successfully!\u0026#34;); } Listprefix接口 list-prefix（列出前缀）通常出现在云存储服务中，指的是根据特定前缀筛选文件或对象的功能。在大多数云存储服务中，文件或对象被组织在一个“桶”或“容器”中，而prefix可以帮助你只列出符合特定前缀的文件。 分页列举接口： 实现： 假设我们在AWS S3存储了多个文件，其中有一些文件的键以photos/开始，使用Prefix参数可以列出这些文件。\nAmazonS3 s3Client = AmazonS3Client.builder().build(); ListObjectsV2Request listObjectsRequest = new ListObjectsV2Request() .withBucketName(\u0026#34;my-bucket\u0026#34;) .withPrefix(\u0026#34;photos/\u0026#34;); ListObjectsV2Response response = s3Client.listObjectsV2(listObjectsRequest); for (S3ObjectSummary objectSummary : response.contents()) { System.out.println(objectSummary.getKey()); } ","date":"2025-01-17 00:00:00","updated":"2025-01-17 00:00:00"},{"objectID":"1736899200","permalink":"/post/git%E7%9B%B8%E5%85%B3/","title":"Git 相关","content":"本文前半部分较为基础，后半部分对.git目录下进行了相关的解释。\n基本命令 cd : 改变目录 cd .. 退回到上级目录 cd (filename)进入文件夹 pwd 显示当前目录 clear 清屏 ls 显示当前目录下的所有文件 touch （文件名.后缀） 新建一个文件 rm （文件名.后缀） 删除一个文件 mkdir test 建立一个test目录 rm -r test 删除test mv index.txt test 移动index至test中 history 查看历史命令 help 帮助 exit 退出 git项目基础 cd /path/to/your/project # 进入项目目录 git init # 初始化 Git 仓库 git add . # 添加所有文件到暂存区 git commit -m \u0026#34;initial commit\u0026#34; # 提交文件 git remote add origin https://github.com/your_username/your_repository.git # 添加远程仓库 git branch -M main 将本地主分支设置为main git checkout -b new-branch # 创建并切换到新分支 git push -u origin new-branch # 推送到新分支 内容过于基础，不再赘述。 .git /config --global、--system、--local 存在于.git/config中。高级别的设置会覆盖低级别的设置\ninstead of 配置 : git config --global url.git@github.com:.insteadOf https://github.com/ git 别名配置 git config --global alias.cin \u0026quot;commit --amend --no-edit\u0026quot;用cin代替。git commit --amend --no-edit 命令可以修改上一次提交的变更内容。 git config -l 当前项目下的配置 git config --system --list 查看系统的配置 git config --global --list 查看用户的配置 名字 邮箱等等 就是c盘用户目录下的.gitconfig 文件 git config --global user.name 进行更改 cat .git/config输出 git/objects git cat-file -p \u0026lt;commit hash\u0026gt; 这里的\u0026lt;commit hash\u0026gt;是在.git目录下的object的hash码，在项目根目录下使用tree .git可以看到。commit/tree/blob统一称为objects。\nblob 存储文件的内容 Tree存储文件的目录信息 commit存储提交信息，一个commit可以对应唯一版本的代码。 串联起来 通过commit寻找到Tree信息，每个commit都会存储对应的Tree ID。输入git log查看版本历史提交。如下：\ncommit 440c02148f899929c2faa3cbf5ca42f3f8785296 Author: utopia-x \u0026lt;your-email@linboxi123@163.com\u0026gt; Date: Sat Jan 4 16:29:19 2025 +0800 接着， 通过Tree找到对应的目录树信息：\nxixiboliya@laptop-tex4-of-boxing MINGW64 /e/mywebsite/Bertsin\u0026#39;s web (main) $ git cat-file -p 440c02148f899929c2faa3cbf5ca42f3f8785296 tree 91af69bb0a1bb9c836d9c57177cddfe1cd7da56b author utopia-x \u0026lt;your-email@linboxi123@163.com\u0026gt; 1735979359 +0800 committer utopia-x \u0026lt;your-email@linboxi123@163.com\u0026gt; 1735979359 +0800 first commit 通过Tree中获得blob的ID，通过blob获取对应的文件内容。 输入$git cat-file -p 91af69bb0a1bb9c836d9c57177cddfe1cd7da56b有： .git/refs head 分支名字存储在rref/heads文件夹下面。\nxixiboliya@laptop-tex4-of-boxing MINGW64 /e/mywebsite/Bertsin\u0026#39;s web (main) $ cat .git/refs/heads/main 156836544ef549d2a6af0774c7304eda45266672 tag refs文件存储的内容就是对应的commit ID，因此把ref当作指针，指向对应的commit来表示当前ref对应的版本。\ngit tag v0.0.1 annotation tag git -a v0.0.2 -m \u0026#34;add feature 1\u0026#34; cat .git/refs/tags/v0.0.2`输出object的hash值 git cat-file -p [hash] 输出相关信息 其中就有annotation tag。\n回溯历史版本代码 通过ref指向的commit可以获取唯一的代码版本。\ncommit --amend修改最近的一次commit信息，修改之后commit id 会变化。 rebase通过git rebase -i HEAD~3可以实现对最近三个commit的修改。\n合并commit 修改具体的commit message 删除某一个commit git gc 可以删除一些不需要的object以及会对object进行一些打包也锁来减少仓库的体积。\ngit gc --prune=now指定修剪多久之前的对象，默认是两周前。\nreflog reflog是用于记录操作日志，防止误操作后数据丢失。通过reflog来找到丢失的数据，手动将日志设置为过期。\ngit reflog expire --expire=\u0026#34;2.weeks.ago\u0026#34; --all clone与fetch git fetch将远端某些分支最新代码拉取到本地，不会进行merge操作。会修改refs/remote内的分支信息，如果需要和本地代码合并需要手动操作。\npull等于上述clone 和fetch的综合。不知道远端的修改建议先fetch在进行rebase。\n","date":"2025-01-15 00:00:00","updated":"2025-01-15 00:00:00"},{"objectID":"1735510200","permalink":"/post/%E6%88%91%E7%9A%842024%E6%80%BB%E7%BB%93/","title":"my 2024 summary","content":" 我的2024总结 当敲下‘my 2024 summary’这行标题开始本文的写作时，我正身处z128号列车归乡途中。z128是连接东西的大动脉之一，从西北到东南，从古都到蛮夷之地，从兰州、西安到福建，缓缓东迁、南开。今天没有下雨，车窗漏过的阳光着实令人欣慰，这在西安并不常见，当然也可能是北方都不常见，西安碑林区冬天的阳光几乎令人感觉不到温度。\n尽管是临近除夕，确切而言，西安的年味并不浓厚。尽管政府在西安城墙、交大兴庆宫等古迹处加上了各种璀璨且卷出新高度的花灯，但明显体感的人口返乡外流、每晚零下凛然的室外寒风着实令人感到荒芜与漂泊。常常感到自己的抉择一定意义上都落向了漂泊，就像波函数向的某种定态的坍缩一般，只不过在十多年前是北漂，如今之后可能是南漂。\n2024年年初还残留着一些博览古今的幻想。一年前的这段时间，借着复旦的一个全国性活动的名义，我正在研读跟专业毫不搭噶的斯多葛学派的哲学著作，寒假在家里面坐牢一点一点地憋了快20天才磨出来一篇巨型学术缝合作品《具身治疗》。这意义不大，但当初为什么会这样做很大程度上是因为笔者才大一，可以允许自己盲目探索一会儿。最大的收获是加了一位2021级pku学长的微信——这是一位个人感觉人格张力拉满的同学：学的是协和八年制临床，但在朋友圈表达过不想做研究型的学者，与此同时是pku学生合唱团成员，不仅有指挥经历，还有与中央多名艺术家同台或者受指导的经历。那位同学同时是一个e人，尽管他平时经常抽烟。笔者文笔功底有限，只能用有趣来形容这样的同学。上图中有fdu的星空咖啡馆、子彬院的会议厅照片。在答辩完之后笔者认识到fdu那些学问建树颇为丰硕的学者也不过是某一细分领域的学者专家，因为一个人的精力实在无法广博通闻诸多领域的诸多事。但话说回来，放在人生的维度上，笔者还是希望自己能够有趣一些。 是的，能够在个人擅长的技能上探索是一件有趣的事。但何谓擅长，你会发现大多人一生都不知所云，大多者只是浑噩地从事一份工作罢了。正如笔者在县城的时候辅导过课业的几位学生。成绩确实不够好，但一天天的披星戴月，不挑餐食又照顾妹妹关心家长，平时老实不去花里胡哨地玩，家长一想确实找不到理由训斥他。只是说不擅长读书罢了，不太能够实现阶级跃迁罢了，但这又如何能言呢？在其他方面笔者确实自愧不如。对于有趣而言，笔者曾认为自己在讲话方面挺擅长的，于是在4月份5月份背宣讲稿子希望加入西迁博物馆宣讲团。那时二十页A4纸左右的讲稿，笔者自己吸收内化，磕磕绊绊地背了将近一学期，但最后试讲的结果并没有很好，宣讲的语言过于平白。或许笔者擅长的只是像讲课那样侃侃而谈无所拘束的讲话，背讲稿、背台词的工作一直是笔者吃力的领域，于是这方面的时间和精力投入便变成了沉没成本。这是笔者所做出的探索。\n自2月的年初开始，笔者对从事硬件控制的幻想逐步被戳破。那时找了北极熊学姐加入了robocup的一个组，做的是工程竞技项目，说白了是一个很无聊的工作——在一个迭代成熟的项目下教会机器人走路。现在以浅薄的分析，似乎可以手调RL，但对于本科生而言难度疑似略大。这个项目采用的自制板和舵机经常是出现了问题难以排查。这里接触不良，那里电压不够……可能是笔者较菜，硬件的debug、PCB板与黑商的交涉总是让人头疼。于是在五月份六月份已然属于灰心的状态，当时遇上考试周，这令笔者感到些许压抑。直到期末考之后才已然发现做这个项目的大部分的时间效果甚微。是这样的，比赛是这样的，我所能作的是这样的。到六月份那时，这个项目逐渐被笔者不看好因而处于淡淡然然的状态。七月份参加了robocup的省赛是省二，但已经看到了机械结构的不足，接着是10月份的国赛，成绩并不好。或许吧，是这样的。\n笔者作为南方人第一次摸爬滚打地尝试了滑雪、为了满足占有欲用暑假辅导的收入购置了一个运动相机、勇闯了西安银泰社交coser拍照、不定时打卡了的家乡风味、摸摸碰碰跑通了RC livox lidar的代码、一刷与带mesome二刷了的华山之旅，还有糖蒜铺子的脱口秀experience（或许笔者更擅长这个？但是笔者实在不会叙述故事）、因为失落没人陪独自到青龙寺用周易算了命结果是上签而一时怀疑算命先生作祟、接任了唐仲英爱心社的某个小部长的职位、去了一次再也不会去的兵马俑骊山、参加了令人失落的发展对象答辩、下学期拿到了（？混进了）XJTU RC队伍 、回家再次品尝许久未吃的永安粿条和沙县小吃、元宵错失了家乡刚申请非物质文化遗产板凳龙的大型巡演……某种意义上是这样的，笔者与自己在某种意义上达到了和解——摆摆烂烂的，尽管许多时候感到无力与尽力、压抑与不知所措。 相当一部分繁忙事务的原因是自己在给自己层层加码，但转念一想繁忙某种意义上是精神世界的反衬。\n有人思来想去扪心自问却仍未选择，有人稀里糊涂不知不觉却已经在路上。\n编辑此行时正值2025春节元宵，笔者正在东航MU从福州长乐机场飞往西安咸阳的客机上。年味即将散去，往往令人沮丧，但新的一年希望保持心情、希望有所取舍、希望认识更多的人、希望有所进取与收获。笔者与正在阅读此文的你，共勉。\n我还是很喜欢家乡味道的。\n","date":"2024-12-29 15:00:00","updated":"2024-12-29 16:00:00"},{"objectID":"1735063200","permalink":"/post/doxygencommit/","title":"Doxygen 与 commit规范","content":" 开始之前 首先推荐大家在vscode中下载插件==通灵译码==或者==GitHub complie==，能极大偷懒提升效率。 示例： 什么是Doxygen Doxygen 是一种文档生成工具，常用于整个项目的Doxyfile的生成，主要用于从源代码中提取注释，并生成技术文档。它广泛用于 C++、C、Java、Python 等多种编程语言中，帮助开发者自动生成文档，从而提高代码的可读性和维护性。\n具体功能： 从代码注释中生成文档：Doxygen 通过解析源代码中的特殊注释格式，将其转换成 HTML、LaTeX、XML 等多种格式的文档。\n支持多种编程语言：除了 C 和 C++，Doxygen 还支持 Java、Python、PHP 等许多其他语言。\n交叉引用代码和文档：Doxygen 可以生成类结构、函数调用图等内容，使得文档与代码紧密结合，便于开发者理解代码的架构。\n可生成不同格式的输出：例如 HTML 文档可以方便地作为在线帮助系统，LaTeX 格式可以用于打印高质量的 PDF 文档。\n下载与使用 vscode插件 在扩展商店里搜索并安装如下扩展\nDoxygen Documentation Generator 接着按下ctrl+shift+p，输入settings.json，打开工作区设置，可以设置快捷键和默认样式\n{ // 触发快捷键 \u0026#34;doxdocgen.c.triggerSequence\u0026#34;: \u0026#34;///\u0026#34; //在函数名前插入 `///`+回车，触发函数注释 } 进一步也可以：\n{ // 起始行样式 \u0026#34;doxdocgen.c.firstLine\u0026#34;: \u0026#34;/*!\u0026#34;, // 模版文件样式 \u0026#34;doxdocgen.cpp.tparamTemplate\u0026#34;: \u0026#34;@tparam{indent:15}{param}\u0026#34;, // 文件头注释样式 \u0026#34;doxdocgen.file.fileTemplate\u0026#34;: \u0026#34;@file{indent:15}{name}\u0026#34;, // 函数注释样式 \u0026#34;doxdocgen.generic.useGitUserName\u0026#34;: true, \u0026#34;doxdocgen.generic.authorTag\u0026#34;: \u0026#34;@author{indent:15}{author}\u0026#34;, \u0026#34;doxdocgen.generic.briefTemplate\u0026#34;: \u0026#34;@brief{indent:15}{text}\u0026#34;, \u0026#34;doxdocgen.generic.dateTemplate\u0026#34;: \u0026#34;@date{indent:15}{date}\u0026#34;, \u0026#34;doxdocgen.generic.paramTemplate\u0026#34;: \u0026#34;@param{indent:15}{param}\u0026#34;, \u0026#34;doxdocgen.generic.returnTemplate\u0026#34;: \u0026#34;@return{indent:15}{type}\u0026#34;, // 自定义标签、顺序 \u0026#34;doxdocgen.file.fileOrder\u0026#34;: [\u0026#34;file\u0026#34;, \u0026#34;author\u0026#34;, \u0026#34;date\u0026#34;], \u0026#34;doxdocgen.generic.customTags\u0026#34;: [\u0026#34;@attention\u0026#34;] } Windows下载doxygen 打开开始菜单，查找“Doxygen”。如果未找到，说明你需要下载并安装 Doxygen。 访问 Doxygen 官方下载页面，下载适用于 Windows 的 Doxygen 安装包。 安装完成后，重新打开 VSCode 尝试运行 doxygen。 Ubuntu / Linux sudo apt-get install doxygen 打开终端，编辑 .bashrc 文件:\nvim ~/.bashrc # 对于 Bash Shell 添加以下内容：\nexport PATH=\u0026#34;/usr/local/bin:$PATH\u0026#34; 保存文件并刷新终端配置：\nsource ~/.bashrc # 使用 Bash 使用 文件头 这部分包括license、版权声明注释、文件描述注释。 函数 接着在函数名前、#include前输入/***/或者///并且分行，便可以使用Doxygen。 将鼠标hover在函数上会出现如下信息： 生成Doxyfile 打开当前工作目录，在终端中输入:\ndoxygen -g // g是generate，用于生成默认的 `Doxyfile` 配置文件。 此时你的项目下会多一个Doxyfile。 如果你想进一步，可以：\ndoxygen 你的项目下会生成html和latex文件夹。\n语法 文件 @file： 文件名 @brief：文件一句话介绍 @author：文件作者 @date：修改日期 @see：额外的一些参考信息，比如有用过的链接 @addtogroup ：创建函数分组 ，@{ 和 @} 表示分组的开始和结束 /** @addtogroup DOXYGEN_API * @brief Doxygen api example. * * Detailed api description. * * @{ */ /** * @brief A sample function in the API group. * * This function demonstrates a typical API function. * * @param a Input parameter. * @return Result of some computation. */ int sample_function(int a) { return a * 2; } /** @} */ 结果在doxygen Doxyfile中：\nAPI Groups: - DOXYGEN_API - sample_function (A sample function in the API group) 变量前的注释 /** * @brief Use brief, otherwise the index won\u0026#39;t have a brief explanation. * Detailed explanation. */ typedef struct BoxStruct { int a; /**\u0026lt; Some documentation for the member BoxStruct#a. */ int b; /**\u0026lt; Some documentation for the member BoxStruct#b. */ double c; /**\u0026lt; Etc. */ } tBoxStruct; API 函数注释样例 /* GLOBAL FUNCTIONS */ /** * @brief Example showing how to document a function with Doxygen. * * Description of what the function does. This part may refer to the parameters * of the function, like @p param1 or @p param2. A word of code can also be * inserted like @c this which is equivalent to \u0026lt;tt\u0026gt;this\u0026lt;/tt\u0026gt; and can be useful * to say that the function returns a @c void or an @c int. If you want to have * more than one word in typewriter font, then just use @\u0026lt;tt@\u0026gt;. * @param [in] param1 Description of the first parameter of the function. * @param [out] param2 The second one, which follows @p param1, and represents output. //变量 * * @return Describe what the function returns. * @retval XXX_OK if successful. * @see doxygen_theSecondFunction * @see Box_The_Last_One * @see \u0026lt;http://website/\u0026gt; * @note Something to note. * @warning Warning. */ int doxygen_theFirstFunction(int param1, int param2); @param：标记变量 [in] [out]表示输入输出方向 @return：返回值描述 @retval：具体返回值及其含义 @see：link信息 @note：备注信息 @warning：需要函数使用者注意的信息，比如：功能未经完全验证 commit规范 1.示例 2. 提交标题（Subject Line） 动词时态：使用 祈使句（动词原型），描述这次提交所做的工作。比如：\nAdd login feature（添加登录功能） Fix button alignment issue（修复按钮对齐问题） Update README for installation instructions（更新 README，添加安装说明） 3. 常见的提交类型 为了规范化提交标题中的描述，项目或团队会使用特定的前缀来标记提交的类型。这些前缀可以帮助人们快速了解提交的目的。例如：\nfeat：引入新功能（feature）。 feat: add user login functionality fix：修复 bug。 fix: resolve password hashing issue docs：仅更新文档。 docs: update API documentation style：代码风格的调整（不涉及功能或逻辑变化），如格式化、空格调整等。 style: reformat code with prettier refactor：重构代码，通常是改善代码结构，但没有新功能或 bug 修复。 refactor: optimize login function test：添加或修改测试。 test: add tests for user authentication chore：不影响源代码的其他更改，如构建过程、依赖管理等。 chore: update npm dependencies perf：性能优化。 perf: improve database query performance 4.参考资料 具体可以参考这篇文档 如何规范你的Git commit？ - 知乎 (zhihu.com)\n","date":"2024-12-24 11:00:00","updated":"2024-12-24 11:00:00"},{"objectID":"1734991800","permalink":"/post/%E7%BD%AE%E8%BA%AB%E4%BA%8B%E5%86%85/","title":"《置身事内》读后记","content":" 《置身事内》 本文作为全书内容的大体回顾会更好一些。\n这是一本关于中国政府与经济发展的书，政府不仅参与公共服务，也深刻影响着资源与分配。 先姑且描述一下各个章节的内容：\n第一章讨论的事权划分的三种理论：公共服务的规模经济与边界、信息复杂性、激励相容。 第二章通过对改开初期以来的分税制改革和土地财政的招商税收，初步概述了土地作为杠杆撬动信贷和各类资金的作用，也为政府债务、融投资埋下伏笔。 第三章重点讲述政府投融资与债务，加快的城镇化建设催生城投债与城投公司的兴起，当然土地投资有成功也有失败，引申出地方债的治理与改革。至于为何投资，涉及到官员激励与腐败的方面。本章使用金融财政学的术语较多，阅读起来需要一些耐心。 第四章讲述政府在工业化进程中的角色，书中举了京东方光电显示产业链和光伏发电从成本高用量少的研发阶段到平价市场化的过程来阐释。并介绍了居住土地和工业用地的定价逻辑以及政府引导基金建立的动机历程。 第五章阐述城市化进程中居民贫富差距的不平衡问题。房价房债、按揭贷款、土地流转以及户籍改革在本章被探讨，重视工业生产将转向重居民重民生，这是作者对服务型转向的一些看法。 对“防范化解重大风险”的讨论，第六章探讨中国政府的债务与风险，从四万亿计划到货币化“棚改”等等，本章聚焦于地方政府融资平台和国企、债主银行的债务。债务根源于我国经济发展的模式与结构，在降债务的过程中必然伴随着一系列深层次结构性改革。 我国经济结构最失衡的特点是消费不足。地方政府重生产重投资导致10年初我国制造业的巨大产能对外输出，进而引发贸易冲突。我国居民拥有高储蓄率但收入占比过低，重扩张的优点是能快速扩大投资和对外贸易，利用全球化的契机拉动经济快速增长，尽管缺点是经济结构上失衡。 本书一共讲述了七章，第五章开始讲述了宏观的经济现象。第八章则是对前述的总结，纵横捭阖颇为精彩。采用市场经济的理论研究中国经济，此二者之间的张力为研究分配制度、改革措施以及发展历程提供了良好的入口。不同“假想”、不同“标准”对于完善市场经济各有判断标准，换一套标准的政策制定可能完全不同。哈佛大学经济学家申克龙的话：“一套严格的概念框架无疑有助于理清问题，但也经常让人错把问题当成答案。社会科学总渴望发现一套‘放之四海而皆准’的方法和规律，这种心态需要成熟起来。不要低估经济现实的复杂性，也不要高估科学工具的质量。”\n这里还有一段精彩的论述：\n经济落后的国家之所以落后，正是因为它缺乏发达国家的很多硬件或软件资源，缺乏完善的市场竞争机制。在推进现代化的进程中， 落后国家所采用的组织和动员资源的方式，注定与发达国家不同。落后国家能否赶超，关键在于能否找到一套适合国情的组织和动 用资源的方式，持续不断地推动经济发展。所谓“市场在资源配置中起到决定性作用”，站在今天的角度上看是未来的趋势之一，但 往后看市场的经济状况也是几十年来经济、政府、社会协同发展和建设的结果。 我国曾在二十世纪六七十年代进行过工业体系的分散化，当时是叫做“三线建设”的开展。以一个全国整合工业资源的角度看确实不妥。这种先分散后整合的方式被解释为能够带动地方农民向工人阶级的转变，为二十一世纪工业加速提供了愿意外出闯荡的大量劳动力，也为地方政府“官场+市场”的竞争和属地管理提供了地区经济的推动力。\n常谈道发展中国家各自的发展模式不尽相同，我国发展中各个省的发展路径和发展方式也不尽相同。社会现实决定了经济发展的政策边界。例如工业化城市化的进程，微观而言则是农民到工人的演变问题，落到个人身上是观念的剧变。作者提到我国可行的政策空间和演变路径受三大制度约束：农村集体所有制、城市土地公有制、户籍制度。因而中国的工业化才离不开乡镇企业的发展，离不开“土地财政”和“土地金融”。政策的制定伴随着利益的约束，研究发展过程的经济学还讨论了发展顺序和发展节奏，政策的路径和步骤、激进与否都有利益冲突，这种必然指引着一种“渐进式改革”的兴起：允许拖低效率的资源错配，建立缓冲机制，因为人需要花时间去适应。\n作者认为，经济学的主要作用仍是发现和提出问题，解决问题仍然只能在摸索中产生——这需要权衡取舍、调整改进、需要魄力。发现和提出好的问题是解决问题的第一步，“提问”本身也是一门艺术，切中要害的问题一定是对于现实具有深刻的理解。“具体问题具体分析”的道理是不会过时的精神。\n推荐书目 冯军旗 《中县干部》 周黎安 《转型中的地方政府：官员激励与治理》\n耶鲁大学哥顿《银行的秘密：现代金融生存启示录》\n保尔森《与中国打交道：亲历一个新经济大国的崛起》\n潘功胜《大行蝶变：中国大型商业银行复兴之路》\n哈佛大学 傅高义 《邓小平时代》\n复旦大学历史地理学家葛剑雄《统一与分裂：中国历史的启示》\n复旦大学陈明明、中山大学肖滨《当代中国政府与政治》\n","date":"2024-12-23 15:00:00","updated":"2024-12-23 16:00:00"},{"objectID":"1732298400","permalink":"/post/datalab/","title":"CMU Datalab","content":" 没得满分是因为在isAsciiDigit中使用了\u0026gt;\u0026gt;违规符号。没有用\u0026gt;\u0026gt;感觉不会写……请求各位大佬对此出谋划策，感谢！\n写在前面 这部分内容参考Arthals\u0026rsquo; ink。 btest：用于测试你的函数是否正确。仅在一个小的测试集上进行测试，不能完全保证你的函数是正确的。\n# 编译并运行 make \u0026amp;\u0026amp; ./btest # 对某个函数进行单元测试 make \u0026amp;\u0026amp; ./btest -f bitXnor # 对某个函数进行单元测试，且指定测试用例，以 -1 指定第一个参数，依次类推 make \u0026amp;\u0026amp; ./btest -f bitXnor -1 7 -2 0xf dlc：用于检查你的代码是否符合规范。\n# 检查是否符合编码规范 ./dlc bits.c driver.pl：用于评分，检查你的函数是否符合规范且正确。\n./driver.pl BitXor int temp = ~(x \u0026amp; y)这一步计算的是 x 和 y 各位同时为1的位置的反，即 temp 中的每个位都代表 x 和 y 对应位不同时为1。换句话说，它标记了 x 和 y 中至少有一个位为0的位置。 int a = ~(x \u0026amp; temp)这里使用 x \u0026amp; temp 获取 x 中与 temp 相应位都为1的位。由于 temp 已经标记了 x 和 y 中不同时为1的位置，x \u0026amp; temp 表示 x 是1且 y 是0的位置。~(x \u0026amp; temp) 则将这些位置置为0，其他位置置为1。 int b = ~(y \u0026amp; temp)类似于上面的 a，这里计算的是 y 中与 temp 相应位都为1的位，即 y 是1而 x 是0的位置。~(y \u0026amp; temp) 将这些位置置为0，其他位置置为1。 return ~(a \u0026amp; b);此步骤中，a \u0026amp; b 会在 x 和 y 中同时为0或同时为1的位上返回1（因为只有这两种情况下，a 和 b 的对应位同时为0，取反后为1）。因此，~(a \u0026amp; b) 将这些位置反转，从而得到 x 和 y 的按位异或结果，即只有当 x 和 y 的某位不同时，该位才为1。 int bitXor(int x, int y) { int temp = ~(x\u0026amp;y); int a = ~(x\u0026amp;temp); int b = ~(y\u0026amp;temp); return ~(a\u0026amp;b); } allOddBits int allOddBits(int x) { int mask0 = 0xAA; int mask1 = mask0 \u0026lt;\u0026lt; 8; int mask2 = mask0 \u0026lt;\u0026lt; 16; int mask3 = mask0 \u0026lt;\u0026lt; 24; int mask = mask0 | mask1 | mask2 | mask3; return !((x\u0026amp;mask)^mask); // ((x|mask)^mask)结果为零的话则说明所有的偶数位均为0 } Tmax answer1 int isTmax(int x) { return !((x+1)^(~x) \u0026amp; ((x+1)\u0026gt;\u0026gt;31)) ; } answer2 当 x 是 Tmax (0x7FFFFFFF):x + 1 会变成 Tmin (0x80000000)，并且 y ^ (~x) 会是0，!!y 会是1，因此返回1。 当 x 不是 Tmax: 如果 x 是其他数，y ^ (~x) 会是非零值，或者 y 为0（针对 x = -1 的情况），结果返回0。\nint isTmax(int x) { //return ( (!((x+1)^(~x))) \u0026amp; ((x+1)\u0026gt;\u0026gt;31) ); int y = x + 1; return !(y ^ (~x)) \u0026amp; !!y; } isMax 我有些违规。。\nint isTmax(int x) { return ( (!((x+1)^(~x))) \u0026amp; ((x+1)\u0026gt;\u0026gt;31) ); //int isTmax(int x) { //int y = x + 1; //return !(y ^ (~x)) \u0026amp; !!y; } } Tmin int tmin(void) { return 1\u0026lt;\u0026lt;31; } negate 返回 -x。这个运用书上的结论就好。。\nint negate(int x) { return ~x+1; } isAsciiDigit 0x30 是 0011 0000，0x39是0011 1001。也就是满足第五位和第六位都是1的前提下，第四位如果是零，则剩下三位怎么取都可以。第四位如果是1，剩下的2、3位只能是0，第1位随意。others是用来检测剩下其它位到底是不是1，因为在make \u0026amp;\u0026amp; ./btest时，对于-1853013669[0x918d415b]出错了。\nint isAsciiDigit(int x) { int others = !(x \u0026gt;\u0026gt; 6); int x6 = (x \u0026amp; 0x30)\u0026gt;\u0026gt;5; int x5 = (x \u0026amp; 0x10)\u0026gt;\u0026gt;4; int x4 = (x \u0026amp; 0x08)\u0026gt;\u0026gt;3; int x23 = !(x \u0026amp; 0x06); //x is \u0026#39;~00~\u0026#39;, then x23 is 1;it\u0026#39;s good. return others \u0026amp; x6 \u0026amp; x5 \u0026amp; ((x4 \u0026amp; x23) | !x4); // 0011 1010 } conditional 本题要求实现same as x ? y : z . Example: conditional(2,4,5) ，使用!!将数映射到{0,1}，如果~x+1的结果全为1的话，使用 \u0026amp;可以保留y的性征，同理z。\nint conditional(int x, int y, int z) { x = !!x; x = ~x+1; return (x \u0026amp; y) | (~x \u0026amp; z) ; } logicalNeg 只有0与它的补码（它自己）的|的最高位为0。\nint logicalNeg(int x) { return !((x | (~x+1)) \u0026gt;\u0026gt; 31); } Floatscale2 通过按位与操作提取符号位、指数位和尾数位：\ns：最高位（第31位）为符号位，决定浮点数是正数还是负数。 exp：指数位（第23到30位），决定浮点数的数量级。 frac：尾数位（第0到22位），决定浮点数的小数部分。 处理非归一化数（exp == 0 的情况） 如果尾数的最高有效位（第22位）为 1，则此时需要将指数加 1，表示进入归一化数状态，同时将尾数左移一位。否则，直接将尾数左移一位，表示乘以 2。 处理归一化数（exp != 0 且 exp != 0x7F800000 的情况）： 正常情况下，指数加 1，表示乘以 2。如果指数加 1 后变为全 1，则表示结果为无穷大，尾数置为 0。 最后没想到是要写!(exp ^ 0x7F800000)，写成!(~(exp \u0026amp; 0x7F800000 ))不行！？ unsigned floatScale2(unsigned uf) { int s = uf \u0026amp; 0x80000000; int exp = uf \u0026amp; 0x7F800000; int frac = uf \u0026amp; 0x007FFFFF; if (exp == 0) { if (frac \u0026amp; 0x00400000) { exp += 0x00800000; frac = (frac\u0026lt;\u0026lt;1) \u0026amp; 0x007FFFFF; } else { frac = frac \u0026lt;\u0026lt;1; } } else if (!(exp ^ 0x7F800000)){ // wu qiong return uf; } else { exp += 0x00800000; //如果 `exp == 0x7F800000`，即指数全为 1，表示无穷大或 NaN，直接返回原数值。 if (exp==0x7F800000){ frac = 0; } return s | exp | frac; // 最后将符号位、指数位、尾数位重新组合为一个无符号整数返回 } floatPower2 unsigned floatPower2(int x) { int exp = x \u0026amp; 0x7F800000; int ret; exp = exp \u0026gt;\u0026gt; 23; if (x\u0026gt;127) return (0xFF\u0026lt;\u0026lt;23); if (x\u0026lt;-149) return 0; if(x \u0026lt; -126) return 0x1 \u0026lt;\u0026lt; (x + 149); exp = x + 127; ret = exp \u0026lt;\u0026lt; 23; return ret; } howMantBits 最具有难度的一个。 (b16 + b8 + b4 + b2 + b1 + x + 1) 正负数都是因为x -\u0026gt; |x| -1 才要补上1的。\nint howManyBits(int x) { int s = x\u0026gt;\u0026gt;31; int b16,b8,b4,b2,b1; x = x ^ s; //calculate right shift 这里无形中是算术右移，s=0xFFFFFFFF //result is x -\u0026gt; |x| -1 b16 = !!(x\u0026gt;\u0026gt;16) \u0026lt;\u0026lt;4;/* 0000 0000 0000 1000 0000 0000 0000 0000 */ x = x \u0026gt;\u0026gt; b16; b8 = !!(x\u0026gt;\u0026gt;8) \u0026lt;\u0026lt; 3; x = x \u0026gt;\u0026gt; b8; b4 = !!(x \u0026gt;\u0026gt; 4) \u0026lt;\u0026lt; 2; x = x \u0026gt;\u0026gt; b4; b2 = !!(x \u0026gt;\u0026gt; 2) \u0026lt;\u0026lt; 1; x = x \u0026gt;\u0026gt; b2; b1 = !!(x \u0026gt;\u0026gt; 1) \u0026lt;\u0026lt; 0; x = x \u0026gt;\u0026gt; b1; return (b16 + b8 + b4 + b2 + b1 + x + 1); } 至此，完成。\n","date":"2024-11-22 11:00:00","updated":"2024-12-20 11:00:00"},{"objectID":"1731542400","permalink":"/post/vpn%E6%95%99%E7%A8%8B/","title":"Linux/ubuntu VPN教程","content":" Ubuntu 22.04 VPN配置教程 ubuntu版本不同其实差别不是很大。\n步骤一：建立clash文件夹并导入安装包 mkdir clash cd clash 之后在本仓库下载clashpremium-release-linux-amd64.s1lSU-Ho.tar.gz导入到~/clash/路径下，换言之，就是将安装包放置在clash文件夹里面，之后解压该文件，并修改命名为clash\nbash tar -xzvf clashpremium-release-linux-amd64.s1lSU-Ho.tar.gz.tar.gz 步骤二：配置VPN参数文件 wget -O config.yaml \u0026#34;https://cqd4w.no-mad-world.club/link/JMdr9H6ofZOHDvJO?clash=3\u0026#34; 步骤三：执行配置命令实现启动clash和VPN代理 chmod +x clash ./clash -d . 执行效果图如下所示： 步骤四：购买机场提供的稳定VPN,并修改设置网络参数 机场链接IKUUU VPN\n在这个机场里面选择VPN网络包,效果如下图所示 以 Ubuntu 20.04 为例，打开系统设置，选择网络，点击网络代理右边的设置按钮，选择手动，填写 HTTP 和 HTTPS 代理为 127.0.0.1:7890，填写 Socks 主机为 127.0.0.1:7891，即可启用系统代理\n修改图如下所示\n之后点击clash链接clash board\nclash界面如下图所示\n点击确定，之后便可享用VPN了\n最终clash效果图如下所示：\n外网游行\u0026ndash;Youtube展示:\n平日开启VPN的方法 在终端中cd到clash的文件夹下，输入./clash -d .启动clash，启动完之后一般不要使用ctrl+c或ctrl+z打断运行，否则再次输入./clash -d .运行会出现端口占用，如果打断了就只能：\npa aux | grep clash kill -9 [端口号] 在浏览器中打开ikuuu的dashboard，里面可以配置代理和节点。\n","date":"2024-11-14 00:00:00","updated":"2024-11-14 00:00:00"},{"objectID":"1725667200","permalink":"/post/sshremotessh/","title":"ssh与remote ssh的使用","content":" ssh简介 ssh是一个多义词。\nSSH（Secure Shell，安全外壳）是一种网络安全协议。SSH协议通过对网络数据进行加密和验证，在不安全的网络环境中提供了安全的网络服务。作为Telnet和其他不安全远程shell协议的安全替代方案，目前SSH协议已经被全世界广泛使用，大多数设备都支持SSH功能。关于ssh协议的更多内容\nssh是通过SSH协议提供远程终端(壳shell)访问（远程命令行登入）的计算机服务。其分为客户端与服务端，其中客户端预装在几乎每一台windows与linux上，而服务端需要手动安装，以防止被攻击破解。在客户端登录服务端后，默认情况下，客户端的命令行指令会被发送到服务端，服务端的指令执行结果也会发回客户端，其效果如同直接使用服务端的命令行一样（即远程终端）；通过重定向程序的输入输出流到ssh服务，也可以达到为明文流量加密的作用;ssh的其他应用还包括端口转发，代理等，堪称万能的网络工具。\nJava三大框架。（显然不是这个）\nssh使用入门 在服务器安装ssh服务端 ssh服务由多个软件提供，其中Linux上openSSH是开源免费的，可以通过下列命令直接安装\nsudo apt update sudo apt install openssh-server 上述命令的显示样式在markdown中被称为\u0026quot;代码块\u0026quot;，代码块中的代码会根据注释中指明的计算机语言被高亮与上色。不作说明的情况下，其中的shell命令都需要被执行。\n在官方文档中，每行shell命令的开头往往会加上$，从而将多个命令与对应的输出之间做区分。但是为了方便读者观看与直接复制使用命令，本文档约定命令的输出应当尽量以图片的形式进行展示，因循此例。\n获取服务器ip地址 sudo apt install net-tools ifconfig 观察输出，其中第一项eth0是一个以太网网关，本机地址为172.22.44.10(wsl2的默认地址)，第二项lo是本地环回地址(localhost 127.0.0.1)。通过同样的方法，在其他网络中也可以分辨出你想通过哪一个网络访问该服务器，以及该服务器在网络中的ip地址是什么。\n登入 ssh支持两种最常见的登录方法，一是密码验证，另一种是利用数字签名算法进行身份验证。\n密码验证 在终端(Bash或powershell)输入以下命令\nssh ${UserName}@${IPaddress} ${UserName}与${IPaddress}是Bash中引用变量的方式，在此处分别指代：服务器上想要登录的账户的用户名，服务器地址。比如你需要访问的服务器的ip是172.22.44.10，用户名是rc，那么应该输入ssh rc@172.22.44.10 实际上${IPaddress}的位置还可以填写主机名 如果是第一次登录，成功进入登录验证阶段\n此时输入yes（注意不能是缩写y,Y,(Enter)），会提示输入密码，正确与不正确均有反馈，遵循提示即可\n如果未成功进入登录验证阶段\nip地址/主机名输错，超时\n登录的主机ip地址与之前登录过的不同主机的ip地址恰好相同\n参考解决方案：问题解决——SSH时出现WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!\n秘钥验证 首先生成非对称加密算法的密钥对 ssh-keygen Ubuntu上的输出结果 Windows上的输出结果 接下来会弹出一堆选项，要求你确认一堆东西或者设置密码之类的，为了方便，一直按Enter直到完成设置。\n生成的密钥对会保存为${HOME}/.ssh/${KeyType}（私钥）与${HOME}/.ssh/${KeyType}.pub（公钥），其中公钥用于在分发到别的计算机上，私钥则需要妥善保存。\nUbuntu上的${HOME}是/home/${UserName}，Windows上的${HOME}是C:\\Users\\${UserName},打开相应的文件夹可以看到生成的文件。\n服务端设置 先复制当前电脑的公钥文件${HOME}/.ssh/${KeyType}.pub的内容到剪切板，利用文件资源管理器打开文件夹，然后右键选择以记事本打开。\n然后通过ssh密码登录方式连接上服务端\n创建文件${HOME}/.ssh/authorized_keys，并且将剪切板的内容复制到文件的第一行\n以下命令中的${PubKey}的内容是剪切板上粘贴下来的公钥内容。\n注意，你不能直接使用代码，而是应当将${PubKey}的内容改为自己剪切板上的公钥，然后再使用这一行代码\nmkdir ${HOME}/.ssh PubKey=\u0026#34;ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDWI1RPA1wttlKyW+RhVBv+2rpOy5EnvZOhalihTFuXdwlMujzNyyjDVH9RUm7Ya3fzUFNADgCK3sJhYsEfVBzQqFTmNyklD8AefJaSEFlCpy/u1JWdnSsPClYw7lkzcPTaOFxzYQH1UhKrkC9CCuqZdODRSJKTkVb9WSxdKcfn9Sawbs0dvscvbj7iIkmoNKJZV6XR7yDuJDBDK6EJnnEjmAOwj/n7VF8+hXkGtealmheWfrJDHtliQLgxRBqu4gd3iltVNx8bJkMMI5niziaCmeqpf1JWblXlvAv2gqXzPJezYPuYPpXhP9SNk84fKby6zYbI6AMTniW7T0u0WZTWQn7Ky6iX+AnkAiVAr9E3e90iz6XaVYfLzQ0AMSJbLysK4Cu6KnBFazHXk0bZ5Txy2CdnYSbA3tRCGcyDXuoo+9KaqGcCaUB7yg1wi7m0uHHHNE9fgmvknSS0Is6GzG9f0DSgZjgwUPSutujV6pCgc0Eb9qdKx5H+4PY6H36E9w8= pyh@LAPTOP-FKJURK83\u0026#34; echo $PubKey\u0026gt; ${HOME}/.ssh/authorized_keys 之后每一次登录都无需密码\nVSCode 插件 Remote ssh的使用 安装vscode后，在扩展商店中输入remote development，进行安装\n安装完成后，侧边会出现远程连接的扩展菜单，点击进入扩展后，将其上方的框中选中远程(隧道/ssh)，可以展开所有配置好的远程ssh选项，如图所示。但是由于还没有配置过，所以应该是空的。\n将光标放置在SSH一栏上，会出现符号，如图\n点击设置符号，更改配置文件，选择第一个文件\n文件中的一个配置项的简单示例如下，可以隔一行增加另一个配置项\nHost RC_xjtu HostName 115.154.175.254 User rc Host WSL HostName 172.22.44.10 User pyh 必要字段 解释 Host 指的是会在远程连接菜单中显示的名称（自己取的），比如第一个配置项会生成 HostName 指地址或者是主机名，上文ssh命令中的${HostName} User 指远程连接中的用户名，上文ssh命令中的${UserName} 其他字段可以在ssh配置文件手册中找到具体的含义\n配置完成后，即可通过进行远程连接。\nTips:\n注意，这一步需要命令行ssh能够正常连接的情况下才能成功，如果没有配置公钥，则要求输入密码，弹出来的提示框比较小，并且在连接过程中会弹出多次，注意别看漏了。 如果不小心点到其他地方让输入框消失了，会被认为进行了取消了输入密码的操作，导致远程连接失败，需要再发起一次连接或者点击retry\n远程连接后得到的窗口是一个空的，没有打开任何文件夹的窗口，查看状态栏（VSCode最下面那一条）的最左边标识会显示出当前窗口是一个远程连接窗口。\n在窗口左上角 文件-\u0026gt;打开文件夹，可以选择对应的文件夹进行开发工作。\n\u0026mdash; 这里是结束的分割线 \u0026mdash;\n","date":"2024-09-07 00:00:00","updated":"2024-09-07 00:00:00"},{"objectID":"1719180600","permalink":"/post/%E6%96%AF%E5%A4%9A%E8%91%9B%E7%9A%84%E5%85%B7%E8%BA%AB%E6%B2%BB%E7%96%97/","title":"具身治疗：斯多葛派“印象”训练","content":" 【摘要】 斯多葛是古希腊思潮中影响深远的流派，其偏重于建立一种唯理基础的伦理学，对个体因“印象”而产生的“激情”采用内心改观，通过哲学训练参与检视“印象”的恰当性，进而达到“不动心”的稳定状态。具体而言，一是通过理性的“赞同”将“印象”隶属于“不动心”范畴中，二是通过冥想、预演对“印象”运用加以归化，然而大多人预演死亡会产生恐惧与焦虑。尽管斯多葛派的修身哲学点明了上达自然的完满状态，但消除激情、上达自然并非仅仅是理想描摹，换言之，斯多葛派略去了具体印象训练的可行性。于此结合“双脑决策”与“恐惧管理理论”对斯多葛“印象”训练可行性进行的尝试与补充，最终为“印象”克制“激情”指明了认知和践履的两条进路。\n【关键词】印象；训练；斯多葛派；具身治疗\n【正文】 一、引言 斯多葛学派是古希腊晚期哲学最著名的哲学派系之一，因其学说与当时社会历史的发展高度契合而得以广泛传播，从御座上威风凛凛的皇帝到作为阶下囚的内敛谦卑的奴隶都是斯多葛学派的拥趸。芝诺、奥勒留、塞涅卡以及爱比克泰德都是斯多葛学派的典型代表。芝诺主张要过一种合乎自然的生活，合乎自然的生活就是一种德性的生活，德性是自然引导我们所趋向的目标。塞涅卡则认为，哲学的目的在于把人引向德性，而德性就是要尊重自然，顺从神意，要按照自然的规范进行生活才能获得真正的幸福。罗马皇帝奥勒留被称为“御座上的哲学家”，在他看来，宇宙万物是一个由神决定其内在秩序的整体，人也是这一整体所统治的一部分，只有顺应这一整体的生活才是值得一过的。爱比克泰德本来是奴隶后来获得自由，他主张一切东西都是神创造的，神就是善，人应该尊从神意、顺从命运不要做与自然不相符合的无谓的挣扎。纵观斯多葛学派的理论，我们不难发现他们都主张存在着一个不为人的主观意志所转移的自然法，这一自然法或自然规则是社会历史发展的决定性力量，个人面对命运的决定性时所作的挣扎都是无用的，唯有“不动心”才能获得真正的幸福，“不动心”才是真正的德性。\n在斯多葛学派的理论中，“理性”和“自然”等概念被多次提及，斯多葛派作将其解释为“逻各斯（logos）”，所谓“逻各斯”就是“主观内化为理性，外在客观为规则，它是神的法律，是自然和人类所共有的法则，具有普遍性和永恒性”，或多或少基于个体命运和动荡的背景因素，斯多葛派将哲学矢的更多放置于哲学实践，通过哲学实践减少个体情绪对理性的冲击进而达到不动心的境界。在斯多葛派的伦理实践中，其强调对灵魂自我修身的哲学训练，具体而言则是聚焦于治疗灵魂冲动的疾病：激情，以保持“不动心”内心境界。在斯多葛学派的哲学实践中对“印象”进行了系统的探讨，他们希望通过“印象”训练达到态度改观并且着重于减少因印象而引发的“激情”冲动，从而获得完满、宁静而愉悦的内心根性。\n至于如何进行“印象”训练，斯多葛学派不同的代表人物提出的看法不尽相同。芝诺主张以理性为本性之人必须克服非理性的激情的观点，克里西普斯道出了更为详细的解释：“灵魂的一种长期疾病是个性的一种稳定状况，这种状况就在于接受一个价值判断，而只要有了这样一个判断，一个人就很容易受到激情的影响。”这里“价值判断”并非认知事物最初的表象呈现，而是带有自我意志的“印象”彰显。进而言之，克里西普斯试图以印象改观的维度入手哲学训练，即通过“注意”并加以理性规范，从而塑造、变动隶属于个体自我的观念。自我观念在斯多葛中的凸显使真正的个体性在自在选择中成为人趋向德性的进路。通过运用这种修身技艺，能够以极大限度的定夺“印象”的范围或者规训“印象”，从而减少激情。例如盗窃外卖行为固然可耻，然而以慨叹其人生活之难处视之，如此何尝不是原先“印象”的温和改观。激情极大关联于“印象”处理，而如此亦是“自我技艺”的训练。斯多葛学派遵循自然理性，试图驾驭激情与冲动的“自我技艺”训练，始于“印象再造”。\n二、印象再造 印象包括各种流变与当下的情感、臆想以及所有回忆，它们都来源于知觉体验。斯多葛学派最著名的代表爱比克泰德对印象认知的瞬间性与自在属性进行了阐释：“人的意识在事物第一次出现时就立即被它所影响，这种表象是不服从人的意志的，也不受人的控制，而只是通过它们自身的力量把自身映入到人们的注意力上。”在爱比克泰德看来，此瞬间发生在主客体相关领域的认识活动，无论是否抛去先天认知形式条件，直观印象均无法为个体控制，因为印象完全来自于物体的“自在精神”，正如康德在《纯粹理性批判》提到的“通过感性一个对象被给予”而为印象，所给予仅仅是经验对象，是未凭借知性范畴的感官直观，仍无法形成知识理念，需要通过“知性对象被思维”，换言之是知性所为“印象再造”。因而流变直观的印象并非属于“由己性”的范畴，是认知主体所无法控制的，而在此时与心灵本性相抵触下产生的感性冲动的消解也绝非易事。\n但在爱比克泰德看来，尽管印象初次出现独立于个体理性的统治部分，但可经内在理性的归化使印象融合于自在意志而具有“由己性”。而以一种易于理解地方式概括爱比克泰德的思想，可称为“印象加工”。个体凭借自身的“赞同”占有了原来之印象，此时印象便服从于人的意志，进而具有了“由己性”，成为克制激情的有效工具。然而“赞同”能力具有两相性，斯多葛认为值得追求的愿景是将印象隶属于“不动心”之下而不是“激情”之下，“不动心”部分的印象是德性对具体技艺要求的应有之义。更进一步，二者限界范畴的框定有赖于宇宙整体的自然法的定夺，即合乎宇宙整体利益的赞同应被纳入“不动心”之下，具体而言则是个体控制范围的定夺：对能控制之物则顺应本性，反之对不可控制之物则依凭自然整体的理性，进而人更应该凭依本性“注意”的是可控制之物的印象。然而理性进行如此驳杂的区分并不容易，无疑是对内在本性向自然理性的上达认知提出了更高要求。\n爱比克泰德认为对于首次出现的表象的“赞同”恰当与否有赖于“把握性概念”的运用程度。类似于伊壁鸠鲁率先提出的“前识概念和感情”，似乎可以解释为先天印象与共有本性的结合，无论是源于理性还是感性。也可借助康德的解释：“一般而言的对象的概念就作为先天条件成为所有经验知识的基础。”因此“先在性”概念能够为认知确立一个明晰的起点。可尽管如此，意识并运用“把握性概念”并不容易，可行的维度是基于自然整体而为的“赞同”训练，凭借来源于理性思考的知识并对此加以演绎推理，排除感性冲动对理性的影响，进而使理性居于支配地位，减少不当的印象，其归根结底便是斯多葛学派在动乱中治疗内心的生存哲学，是退守内心的韧性与忍耐。\n三.印象运用 克利西波斯用一个巧妙的奔跑者比喻解释了“冲动过度”（excess of impluse）：一旦开始阔步前进，便很难停下来。当理性生命在认知刺激下形成印象，那么印象将会推动事物运动。因而首先是持续发挥作用的印象，其次是赞同和思想，再者是决策与运用。一部分事物印象随个体认知活动的进行和接收相近反馈的增加而逐步稳定，另一部分因个体接收的反馈与先前印象拒斥而亟待理性重新“赞同”。印象是完全属于个体的唯一的印象，认知活动是由个体之印象真实地表述的，但是个体未再经思考的、习以为常的印象运用未必合乎哲学训练的要求。爱比克泰德对此巧妙地解释到：尽管包括阿伽门农(Agamemnon)和阿基里斯(Achilles)在内的所有人都对圣洁(holiness)有着相同的“把握性概念”，但他们仍然对“应不应该将克里西斯(Chryseis)送还给她父亲”存在分歧。例如即使他者并没有夺走什么，我们听到医生“身体的有点抱恙”的话语时仍然有些许担心和忧虑。因而印象是个体的把握性印象，治疗印象并非因为印象错误，而是运用途径不得当。如此“印象”扰乱了灵魂的宁静，那么如何让灵魂重归宁静？基于此维度，“自我技艺”的哲学训练便落脚于对印象运用是否得当或正确。\n斯多葛学派认为印象正确运用的可行之路有依赖于后置沉思的有意识调整。他们的理论和现代心理学家与决策理论家丹尼尔·卡内曼（Daniel Kahneman)提出大脑有两个系统的假设相契合：当我们清醒之时，两个系统都处于活跃状态。系统1自主运行，做出几乎不包含自主性的控制决策，依赖情感、经验和感觉直观迅速应激判断，不断为系统2提供印象、直觉和感觉等信息；而系统2通常处于放松状态，运行时只有部分参与，其思考需要调动专注力和理性，因此在重要场合机遇的决策当中，它将耗费更多功夫。正如丹尼尔·卡内曼所言，我们“思考时快时慢”。基于快速思考而使本能性反应支配认知行动，归根到底是直觉感受的当下之物契合了原先存在的已经经过一次或多次“赞同”的“印象”的结果，并且随无意识的“赞同”次数积累，快速思考调用印象愈发得不假思索。爱比克泰德曾在《哲学谈话录》中指出了类似的观点：“习惯是一种强大的力量，我们自己习惯于将我们的欲求和回避指向外部事物时……我们就必须在哪里把我们的训练当成是一种抵消它的力量。”如此看来，对于如何克服习惯自身对思考的偏置，爱比克泰德的确在尽力地运用系统2进行自我“印象”的规训。当然，基于经验直观的快速思考并非应当弃置，正确的印象运用更重要的是适当运用直观与决定的间隔，尤其是自在理性意识到印象正在或将要编织出一幅错误的认知图景之时。反之不恰当地运用印象以及迅速思考让我们受身于不理智的恐惧之中，未再思省的思维活动因冲动而难以克制，继而需要个体不断调动内在理性对已然或未然进行思省与扬弃。\n四.印象训练 （一）冥想沉思 冥想沉思注重于对已然反应的反省，某种意义上斯多葛派确实在尽力进行自我反对。塞涅卡在给卢西留斯的《道德书简》提出：“认识错误是拯救自己的第一步……你要首先当原告，然后作法官，最后才作辩护律师。有时候必须对自己严厉些”，借法庭审判为喻道出沉思并审视记忆中印象的流程范式。尽管斯多葛对于宇宙流变的解释聚焦于“只有把握当下”，但其仍承认记忆的稳定性，因而内心得以审视记忆，进行自我剖析，基于此维度思考特定行为是否是基于快速判断的应激反应（印象运用得当与否）、是否合乎自然整体的利益（自然法的规定）、是否可以上达整体而降低激情的纷扰。尽管生活应当是没有一刻“注意力不存在于其上”的生活，但不久后当激情被理性一旦捕捉时，个体会发现自己正处于怠惰、松懈并且越陷越深——毕竟大多数凭借迅速判断而做出的决策的反馈因为符合自身因先前印象的预演结果而极易被忽视。“各方面都不犯错可能吗？不，在实践上不可能。”但如果可以因此而免去一些错误判断，“我们也会有理由感到满足了。”\n沉思为了更好察觉运用的印象，严格的审视自身必须承载着一种对心灵习惯的“认知”和“注意”，并注重“抽离”表象和审判“印象”的“自我技艺”，最终服从于以德性为最高善好的修身训练。塞涅卡在睡前冥想回顾当天活动，深夜召唤心灵“对自身作交代”，“不对自己隐瞒任何东西，也不忽视任何东西”，并考虑如何在未来做得更好。这样践行冥想有强烈的认知性，包含着恪守与进取，并且要求心灵忙碌地工作。师从爱比克泰德的马可奥勒留每日傍晚在日耳曼战争中的军帐下写下“让你的灵魂中那一指导和支配的部分不受肉体活动的纷扰吧……而是让它限定它自己”。正如马克奥勒留通过冥想总结强化印象浮现的正确与否，斯多葛派承认自我意志能够思考其自身，从而理性将限定理性自身的决策使其逐渐定向化，基于反思的审视约束，通过理性对印象进行训练、规训，以期减少激情的纷扰达到灵魂的宁静，进而达到“不动心”的伦理境界。\n虽然斯多葛与东方宗教都注重内心摆脱焦虑的宁静无忧之自由，但不同于东方式冥想，例如佛教的解脱超度冥想，斯多葛不寻求超脱自我意识而清心寡欲，寻求的是自我审判，是内心深邃罅隙中的和解。塞涅卡主张“养成习惯与持久的注视”，屡次从客观性和整体性解释自身哲学实践是否恰当，如此减少那些近乎自动的反应。斯多葛派的冥想要求全神贯注投入精力而专注，与理性交涉，因此内心将忙碌于上达德性的自我剖析。至于激情的治疗则有关于理性运用，辩证的冥想朝向自我印象的改观，对于你接收了什么，注重或忽略了什么，“先在性”概念对印象的影响程度怎样诸如此类反思，哪怕极细微的改观，只要出更恰当印象的见解，那么对于印象运用便是有了新范式的参照。毕竟斯多葛派的圣哲们作为“进步者”也仍在趋向至上德性的路上。“别要求我应该是最好的，只要求我比最坏的好。如果我每天能减少自己恶行的数量，并且纠正我的错误，这对我来说就足够了。”\n（二）死亡预演 死亡对人类而言是一个永恒的话题，柏拉图在《斐多篇》中曾明确指出“哲学的本质在于训练死亡”。斯多葛派哲学训练落脚于此的逻辑可以归纳为预演：提前想象惧怕之事发生，那么如此已然发生之后又有什么最坏情况将发生。无论个体如何下意识地跳脱，在经过如此反复发问之后，问题都将微妙地围绕于死亡而归结，因而如何预演死亡使“印象”复属于“不动心”之下便是其哲学思想的落脚点之一。\n预演未来可能逆境的训练方法是斯多葛派广为人知的训练方式，通过对未来困境情况进行极不幸的预想，倘若不幸发生则能降低突如其来苦楚的激情纷扰，反之未发生则感谢自然整体分配事件时的眷顾。颇有宿命论意味的是，对于必然到来的死亡，尽管斯多葛派以自然流变的维度叙述了预演结果，即将个体死亡看作对自然整体规律的皈依，符合本性地生活，但在可行性上模糊了进行死亡预演哲学训练的实践维度与普遍意义下关于死亡的“意见”。事实上，倘若将预演注意力集中于负面的认知角度，未然的悲痛定然会以当下的悲痛分摊为代价，正如我们反复琢磨死去时孤单与虚无，却不知内心已被不幸与损失的“激情”牢牢占据。塞涅卡在《致玛姬娅的劝慰书》中承认即使是最决绝的圣人也会深感一阵哀伤，并给予“自然”的悲伤以理解，因为理性动物本能未经赞同的前印象便是苦楚的“痉挛”。\n斯多葛派通过死亡预演而对印象进行的训练类似于现代社会心理学中的“恐惧管理理论”。作为其基本观点基于每个个体对死亡的恐惧而共同创立了文化世界观而进行心理防御，赋予其秩序、价值理念和意义。进而于此的文化价值感赋予人象征性超越死亡的方式与意义，即人的意志主观依附于体系价值的继存一定程度消解了对死亡的恐惧。换言之，个体对主观价值体系下的意义认同分配“管理”了注意力的恐惧认知，即当死亡充斥个体意识时，恐惧使其不自觉抑制如此想法，转而分散注意力。而对于“使人们变得聪明而忧伤”的死亡，与恐惧管理理论相契合，博尔赫斯在《永生》也希望表达一种精神依旧长存于荒诞的毅力。无独有偶，合乎自然整体的精神力量在意识或无意识的斯多葛式预演死亡下也被“注意”，因其能够赋予合乎个体主观追求的价值依存而被斯多葛派珍重，具体体现为其热爱自然、热爱人类、趋向至善的入世哲学思想，这为淡化死亡印象提供了德性引导的可行途径。有着属于自然的共同本性的每个人渺小地属于宇宙整体，生前死后均是组成自然的原子，应当珍视自身存在依德性而择善而行，更需要履行社会联结的公共义务，包括联系邻里、开导他人，更加充分发挥本性的博爱。\n如此斯多葛对死亡印象的预想消解的范式可从注意力分配的价值体系得到解释，在这里“注意力分配”被解释为接收印象的范式，通过主张接收更高层次的价值模式作为意识的依存空间，来克制对威胁印象的不合适接收。对于斯多葛将死亡列入中性之物的价值判断的原因，更确切而言是向宇宙并非个体给予注意，偏重自然整体之价值而哲学训练的结果。而对于判定何者对于“注意”分配合适或不合适、以及何者为中性的原因，斯多葛派“价值三分法”指明了很好的方向，即通过判断该事物是否处于自由意志领域之内以划分是否是中性，进而对于自由意志之内的事物判断善好与败坏。爱比克泰德对此举例道，无论是一个温雅的女人、执政官的职位还是一个孩子的死亡，运用你的准则，其均是自由意志之外、经不起检验的中性之物。尽管斯多葛关于善好理念的价值模式与当下大致相契合，确切而言应当归属于一种“无需理性的纯粹机制”，是一 种没有“理性外衣”的本能呈现，但对我们在情境中所专注的事物之印象预演和暴露训练，从而减少激情是有先见之明的。\n五、总结 上述对激情根源以及如何修正的讨论指明出两条进路：一是对于印象赞同的不恰当，对应“先在性”应作为一切经验知识的前提条件，具有调和经验论与唯理论的色彩；二则是印象使用不妥当而催生激情，对应训练冥想和预演对其纠正以维持心灵宁静自然，进而感知“激情”并在接收直觉与“冲动”预发之间预留后置判断的空间。尽管前者倾向认知论与先验主义，后者更着重自身践履的训练维度，但从时序逻辑观点出发，二者的关联能具有很好的统一性：即外物于人瞬间的“表象”是个体直观在认知领域内受物体“自在精神”的不可控“印象”，唯契合于“不动心”的恰当赞同将印象具化为合乎个体本性的印象，同时自我意识中的印象亦不可冲动地显露，否则激情纷扰灵魂趋向德性的进路。现代心理学理论为依据，如此般的归纳论证了斯多葛学派关于“印象”从感知到赞同进而通过冥想、死亡预演而训练的合理性。当然，斯多葛派的冥想、预演的哲学训练并非怀疑主义对表象“悬置判断”而有意避之，其修身哲学聚焦于内心改观的“自我技艺”，对激情的治疗进行了十分深远的探索与尝试。\n哲学训练作为一种旷日持久的精神操习，被斯多葛派哲学家重视为改变并提升自己的手段。无论是苏格拉底式的辩证法、柏拉图式的文学操练，还是马可·奥勒留在多瑙河畔黄昏的帐下独思，指向的是自我以及存在的提升，一种对具身以及其外延物的恰当处理，从崇高德性出发，面向身体而“修身”，提升到“获致自我意识洞观世界内在平和以及自由的本真‘状态’”斯多葛派之哲学训练在外路与内在中选择了后者，确切而言是内心的印象改观对个体践履的驱动。无论是切换态度以治疗焦虑的方法还是顺应自然的宁静，抑或是与他人和谐联系并以善待，斯多葛伦理学与当代价值体系的社会认同相契合，其以本性体悟整体理性法则的意旨，以整体与部分内在利益一致的驱动中进行的认知改观，为个体从容处世的看法提供凭依；而聚焦内心则是根除激情的“印象”运用，无论是已然冥想或未然预演，斯多葛派的治疗哲学不啻为“逻辑解药”，更是带有逆遇色彩而聚焦于内心完满的温和改观。\n【参考文献】 [1]马克·奥勒留:沉思录[M].北京时代华文书局,2017.\n[2]于江霞:技艺与身体:斯多亚派修身哲学研究，北京：北京大学出版社，2021年.7-15,152,256-263\n[3]（阿）豪·路·博尔赫斯:博尔赫斯小说集[M].王永年、陈泉译.浙江：浙江文艺出版社，2005.p.123\n[4]（美）大卫·菲德勒作；与塞涅卡共进早餐-斯多葛哲学的人生艺术[M].谭新木，王蕾译.上海:上海社会科学院出版社,2022\n[5]（美）丹尼尔·卡尼曼著；思考，快与慢[M].胡晓姣，李爱民，何梦莹译.中信出版集团,2021,8-9\n[6] 章雪富.斯多亚主义的治疗性哲学和自我的观念[J].现代哲学杂志,2009,(2): 85-90，38\n[7]陈群志.阿道与福柯的修身哲学之争[J].世界哲学,2015,(6): 85-92\n[8] 张志伟.康德哲学视野下的心灵与世界 ——兼论《纯粹理性批判》中的经验概念[J].现代哲学,2023,(1): 62-68\n[9] FOUCAUIT M. L’Herméneutique du sujet: Cours au Collège de France (1981 — 1982) [M]. Paris: Seuil/Gallimard, 2001\n[10]奥利金:《论首要原理》(石敏敏译),第三卷第l至2章，道风书社.2002年\n[11]吴欲波，曹欢荣.爱比克泰德论治疗对象与哲学治疗[J].湖北社会科学,2010,(5): 103-106\n[12]（意）马西莫·匹格里奇：哲学的指引：斯多葛哲学的生活知道,崔知名译，北京,北京联合出版公司，2023\n[13] （古罗马）塞涅卡著.哲学的治疗 塞涅卡伦理文选之二[M].吴欲波译，包利民校，北京：中国社会科学出版社,2007\n[14]（古希腊）爱比克泰德著.爱比克泰德论说集[M].北京：商务印书馆,2009\n[15]（古希腊）柏拉图等编；（美）查尔斯·艾略特主编；张春，朱亚兰译.哈佛百年经典：柏拉图对话录：申辩篇、支利同篇、斐多篇爱比克泰德金言录 22卷[M].北京：北京理工大学出版社,2014,67-69\n","date":"2024-06-23 15:00:00","updated":"2024-06-25 16:00:00"},{"objectID":"1716502200","permalink":"/post/%E5%81%A5%E5%BA%B7%E7%9A%84%E6%96%AF%E5%A4%9A%E8%91%9B%E4%B8%BB%E4%B9%89/","title":"一种健康的现代斯多葛主义","content":" 一次最意外的考验 “骑行者vs.小鹿”——这是护士递给我的医学报告的标题。在我正为这本书写结尾时，我迎来了一场最终的考验，而这恰是我未曾预演的事情。我先生马歇尔那时正在离家不远的岩溪公园（Rock Greek Park）骑车，他碰到了一只拿不定主意该如何过马路的鹿。它起初选择了一个方向，已经快要到达马路的另一边了，但是看到一辆车开过来，它立即转身返回，然后又再次尝试过马路。我先生和那只鹿发生了碰撞。那只鹿毫发无伤地逃走了，而留给我先生的是：七根断了的肋骨、肺萎陷和肩膀脱臼。急诊室医生告诉我，他“遭遇了惨烈的撞击”，我听到这个消息之后一度昏厥。“我们将不得不把他送到华盛顿特区的一家创伤中心。”医生说。\n新型冠状病毒正在我们的城市肆虐。我和先生已经采取了全部的防护措施并且基本上在封锁中度过了5个月的时间，而现在我们要去一家大的城市医院。\n作为一个斯多葛主义者，我此时应该如何思考问题？爱比克泰德在我耳边轻语道：“那只是他的躯体而已。”\n你一定是在开玩笑，我想。他的大脑就在他的躯体中。我有些朋友是当医生的，他们帮我理解了“连枷胸”（flailed chests）、肺炎、肺部功能、神经学问题以及应当在认知的层面上注意什么。他们让我做到的事情是否有认知上的谬误呢？“那真的只是他的躯体吗？”斯托克代尔曾是一名海军飞行员，他在战争中被击落，落入敌军手中，他的腿可能就是在此期间被打伤的，后来成为战俘的他又被敌军折磨了超过7年的时间。他在爱比克泰德那里找到了救命稻草。爱比克泰德是一个曾遭奴役的斯多葛思想家，同样是个瘸子。然而我的先生却不是战俘。最近一直让我忧虑的敌人是一种恶性病毒，我们正在尽最大努力巧妙地跟它斗争。但我没想过他会被一头犹豫不决的鹿撞到。\n“惨烈的撞击”在我脑中反复盘旋。我已经花了整整一周的时间来专门思考罗马奴隶们遭受的残酷殴打和斯多葛式的评论。斯多葛学派看轻身体上的痛苦，这一点众所周知。但因运气不好而遭受的苦难与因他人的非正义行为所遭受的苦难之间的界线也被他们磨平了。如果你是个谨慎并且负责的骑行者，那么被鹿撞到是源于运气不好，然而被当成奴隶严刑拷打就是源于非正义的行为。\n塞内卡抨击了施加在罗马奴隶身上的残酷行为。但是这更多的是一种利己性的考量而不是为人性所做的辩护：被奴役者可能背叛奴役他的人；让奴隶们感到感激总比让他们感到害怕要好；对他们施以恩惠，他们也许会以恩惠回报，比如代你赴死：“假设我告诉你，有人不顾自己的安危也要保护主人，伤痕累累，抛头颅洒热血，以自己的生命为代价为他的主人争取逃脱的时间。”\n这里所说的道德上的教益在于，被奴役之人也能表达仁慈。而这一点在政治上为塞内卡的目标受众（即精英阶层）带来的教益则在于，当你想鞭打仆人时，对你盛怒的情绪加以控制是有好处的。而肉体、肉体的完整性和肉体痛苦，还有人以及他因其人性而应得的尊重，都不在这些道德和政治上的教益范围中。\n斯多葛学派教导我们，我们都为外在的权力所奴役。但他们也教导我们，我们中的有些人却比别人拥有更多的世俗权力。道德是一回事，而合法性和社会现实则是另外一回事。斯多葛学派从来都不挑战奴役制度。\n这也就为我们将要做出的最后思考奠定了基础。我们要如何在古希腊和古罗马文化的基础上建立起一种健康的现代斯多葛主义呢？在当下的“取消主义文化”盛行以及对前代典范全盘推翻的背景下，为什么还要与那些不仅纵容奴隶制，而且还将内在自由赞美为最神圣的解放的古代哲学家为伍呢？\n犬儒者第欧根尼是斯多葛主义极具代表性的人物，他穿着异性的服装，在公众面前炫耀自己的身体部位，他还排斥婚姻，认为这只是一种习俗，但不论他在多大程度上与传统习俗相背离，他都没有反对过奴役的传统，即使他自己就是个奴隶。他在追求一种别样的自由与掌控。因此，他在拍卖台上指着人群中的一个科林斯人厚着脸皮打趣道：“快把我卖给这个人吧，他需要一个主人。”\n内在的主宰才是真正的解放。最负盛名的被奴役的斯多葛思想家爱比克泰德成了一位受过良好教育的老师，他的追随者不计其数，其中还包括一位君主。但他从来没有抨击过奴隶制度。如果说鞭打被奴役者会在道德上遭到反对，那么罪恶在于当权者的堕落，而不在于遭鞭打之人的堕落 。同样地，他的老师穆索尼乌斯·鲁弗斯教导道，奸夫与女性奴隶通奸，他真正的罪恶在于意志薄弱，而不在于任何对待女性的不正义行为。 奴隶的真正力量在于其面对命运和苦难时所具有的精神独立性。不对欲望进行强有力的控制是一种罪恶，不论我们谈及的是男性与被奴役的女性厮混，还是女性与被奴役的男性厮混。这里当然存在性别平等的观念，但真正的罪恶，即那种意志上的薄弱，在男人那里更为严重。\n奴役是普遍存在的：我们都被命运和身体的欲望紧紧掌控。自由同样是普遍存在的：我们都享有人性和理性。与亚里士多德的看法相反，斯多葛学派认为，奴役没有任何自然基础，这样的观点简直已是老生常谈了 。我们身处一个拥有共同来源和共同命运的共同体中。\n事情可能确实如此。但是精神上的平等并不意味着日复一日的社会现实境遇上的平等 。塞内卡一生中的大多数时间都生活在富足中。他家中的佣人、随从的数量简直让唐顿庄园都逊色几分。斯多葛学派把获得力量的希望寄托在共同体和对他人的信赖上。但在实践中，这种信赖并不总是可靠的。爱比克泰德训诫道，你的身体“就像一头因背着它自己的驮鞍和缰绳而负载过重的可怜驴子” 。身体是一具会“被迫投入公共服务中”的工具。“不要反抗或者抱怨，否则你就输了。”这就是这场交易在被奴役者身上的体现。\n既然我们在这一课中要为之前的课程作结，我之前还没有表明立场，那么我在此阐述。我的教学和写作都与古典及现代伦理学相关。我对那些文本充满喜爱，我仔细研读它们，与它们辩论，我还要求我的学生对其进行认真的阅读并且努力与它们辩论。我并不是一个严格的斯多葛主义者（不论它对现代人而言意味着什么），也不是一个斯多葛文本的阐释者。我把自己摆在一个好奇又好学的新斯多葛派立场上，捕捉古代斯多葛主义中的精华和现代斯多葛主义中有价值的教益。\n关于构建一种健康的现代斯多葛主义，我已含蓄地采用了一些原则作为背景性的指引：\n1.心理层面的掌控不能以牺牲人类的脆弱性为代价。\n2.对他人的依赖有赖于互相合作、彼此尊重、互相支持的共同体的建立。\n3.否定身体或心灵的痛苦，并不是面对磨难时永恒的解决方案。\n4.要对迅速产生的感觉印象进行密切的注视，包括由恐惧、愤怒和欲望造成的扭曲和偏见。\n对这些原则，我已经展示了我是如何在斯多葛主义的文本中为之找到立足点的——有些与情感的多个层次有关，有的与同理心以及全球人类的连接性有关，有的还与心理和道德上的困扰以及同情在心理创伤治愈中发挥的作用有关，还有的与注意力发挥的作用有关。我对那些文本向来充满敬意。但我同样努力让这些文本开口对我们说话，也让我们对它们说话，对之提出质疑，思考新的实践。\n但我们仍然没能对斯多葛学派关于奴役制度的看法做出合适的清算。在这样一个我们要对自己的奴役史进行清算的时代，在“黑人的命也是命”的时代里，我们应该如何评估现代斯多葛主义呢？\n我们要关注塞内卡的看法，尤其要关注《书信集》里的第47封信。尽管有些现代学者曾把其中塞内卡的观点视为当代人文主义思想的古代根据 ，且认为其具有启蒙特征，但现在人们普遍认为事情恰恰相反。塞内卡“为以仁慈的方式对待那些被奴役者提出了强有力的辩护”，但这更多的是出于自身的利益而非社会良知。奴役制度对罗马上层人士而言十分重要。作为尼禄的御用顾问，塞内卡所强调的完全就是“对现状的接受”。\n“‘他们是奴隶。’不，他们是人。” 所以在与卢基里乌斯（Lucilius）的通信里，塞内卡在开篇就与他讲起应该如何对待他家中被奴役的佣人。他接着立刻就像连珠炮一样对自己的密友说：\n“他们是奴隶。”\n“不，他们是你的室友。”\n“他们是奴隶。”\n“不，他们是出身卑微的友人。”\n而接下来的这一个回合就传递了关键的道德教导：\n“他们是奴隶。”\n“他们是跟你一样的奴隶，尤其是如果你还没忘记你的命运和他们的命运都同样由老天爷说了算。 ……你们是由同样的种子长成的。 ……灾祸能使那些‘出身上流的贵族们’低贱。同等的运气和人性使你们成为平等的人。”\n然而，正如亚里士多德所说，那些出身上流的贵族雇用奴隶，而被奴役者却是工具，即便是在斯多葛主义那里，也只是任凭习俗和机遇支配的奴隶 。那这些工具被用来做什么呢？他们擦净宴会上的唾沫和呕吐物，切开饭桌上的珍禽，在公共场合给别人端茶送水，但在私下却要满足别人的淫欲——“因为他只在聚会上是个男孩，在卧室里他是个男人”。 他了解那些上流人士的品位，哪些食物“能让他喜笑开颜”，哪些会让他“恶心想吐”，哪些食物他“十分渴望”“哪些食物让他开心”；知道他喜欢跟谁一块儿用餐，知道谁“配不上他高贵的地位”。这种从权力的侧面切入、分门别类写好的详尽知识体系是为贵族群体而建立的，而他们则要依赖被奴役的劳动者们。\n塞内卡为仆人订立的在家务中应承担的职能简直数不胜数：“厨子、面包师、按摩师、洗浴服务员、私人训练师、管家（大管事）。” 他的家务如此铺张，此外还会额外雇用美发师、客座发言人、贴身男仆、女招待、勤杂工和迎宾员、垃圾搬运工，以及那些管束病人和疯子的人。从早晨醒来一直到夜晚沉思的时光，都要依赖奴隶的帮助，需要他们帮忙处理贵族化日常生活中的诸多事务——在屋里满足主人所有心血来潮的奇想和需要，在屋外打理花园和土地。“从根本上讲，奴隶的出逃对主人来说是一种困扰……奴隶主们的财产在这方面所遭受的损失从来都不轻。” 这毫不奇怪。失去一名奴隶对家庭的生活方式和家政状况都会造成重大破坏。\n塞内卡也许会在夜晚沉思该如何克制自己对家庭侍从的愤怒，这是因为，在他那个社会，鞭打一个在晚饭时间发出了太多噪声或是打扰了正在整理家庭账务的地主（或者说得更直接些，正如他自己所叙述的那样，“当灯光熄灭，连我的妻子也不再言语”）的奴隶一点儿也不奇怪。在就寝或清晨时通过沉思来预演管制措施，也许意味着这个奴隶不会逃跑，也不会在严酷的审讯下袭击你。\n这就是塞内卡的境遇中以人道的方式对待奴隶所基于的社会基础，这也是对传统习俗做出的调整。而道德上的要求则更为崇高——就此而言，人人都在被奴役着。“告诉我谁能幸免于此！有的人被性欲奴役，有的人被贪婪奴役，还有的人被野心奴役——他们都是欲望的奴隶、恐惧的奴隶。”\n奴役是一种精神状态，在这种意义上人人皆是如此。所以不要认为“朋友只能在集会场所或是议院的大厅里才能交到”。你的后院中和家务事里也有朋友。一个人的“衣着”或是“生活中的地位”与他们真正的自由毫不相关， 应该自由的是精神。\n这既是斯多葛主义具有吸引力的一面，也是其有害的一面。我在整本书中自始至终都在努力将现代斯多葛主义往外在的方向引导——将它所承诺的在世性、连接性和人人共享的理性和人性都呈现出来。我也拓宽了意志和注意力的角度，以使人们能对在更广的范围内影响幸福的感觉印象加以关注。这就是斯多葛主义所做出的全数承诺及其所继承的苏格拉底式遗产：要针对看到的世界中的好事和坏事反复地审视和考察自身。对斯多葛学派而言，“虚假”的好事和坏事都与外部事物或中立之物有关，而它们与理性真正的善以及理性在德性上的完善都没有关系。\n斯多葛学派从来不认为理性对外部资源来说是中立的。恰恰相反，智慧就是在大多数情形中都能选择或偏向与自然相合的善。我们偏好健康胜过疾病，偏好充足的物质条件胜过贫困，偏好善良的孩子和朋友胜过邪恶的人，这都是我们选择的。我们的这些偏好以及在错综复杂的行动世界中表现它们的方式，就是美德的具体体现。理性和理性的卓越与完善是真正的善，因为它们对我们的共同幸福而言是绝对必要的。显然，我们无法控制事情的所有结果，但是我们可以培育理性、求知欲、对真理的敬重，以及相信每个人都配享有足够的资源来对理性进行培育的信念。这是一颗斯多葛主义的种子，尽管它没有在他们那个时代生根发芽。\n所以，对于构建一种现代斯多葛主义而言，斯多葛主义是否能应对得了这一挑战呢？\n身处欧洲理性启蒙传统中的康德开启了这项工作。他发展了人人享有的理性的概念，而这也构成了作为人而非上帝、自然或宇宙的我们，为自身确立道德法则的基础。理性约束着我们，它也是普遍存在的道德责任和义务的根源，同时使责任和义务不因一时便利或私利而被取消。康德系统地构建起了人性的原则，以防止将人仅仅视为被明码标价以达成目的的工具，尽管他的学说比塞内卡的晚了近2000年，却绝不仅仅只是为人类的解放给出了一种理论模型 。\n文本和语境 所以我们该如何对待有些观点存在道德问题的文本呢？要不要删掉？要不要不教授这些内容，或者更极端些，将该作者的全部作品都放弃？或者像斯多葛哲学家们那样，基于自身判断和灵活性来应对这些挑战？我选择后者。在这些情况中，我们面临的挑战在于理解我们并不身处其中的时代和受历史架构影响（有时甚至是深受其影响）的观念。\n即使哲学伪装成超越历史的模样，但它向来都不与历史相割裂。即使某种哲学观点是“无中生有的”，它也是由有血有肉的人，基于特定的基础，被其所在的文化、实践和前辈们影响，又经常以对它们做出回应的方式得出的。\n哲学以论辩之术为傲，但做哲学却绝不仅仅意味着单纯进行论辩。哲学是一种将追随者、忠实支持者和门徒们聚集起来的学科，就像在雅典、在绘有湿壁画柱廊的沉静气氛中，或是在吕克昂的健身场里，抑或是在学园里的人所做的那样。\n但罗马斯多葛派思想家们比起亚里士多德和柏拉图，甚或那些在柱廊里进行集会的古希腊斯多葛哲学家们，仍然是一类不同的哲学家。他们不但论辩，还布道和说教，这也部分地解释了他们在历史上经久不衰的吸引力，这些都是斯多葛思想声势浩大的复兴背后的原因。斯多葛哲学可以是一种世俗宗教，也可以是一种专注于美德和道德进步而不进行宗教建设之积累的精神实践。\n从历史的角度来说，斯多葛派所带来的影响明显地以其他方式表现了出来。早期的犹太教和基督教思想家从异教思想中吸收了一些观念，这也就解释了为什么很多人仍对斯多葛主义感到十分熟悉。斯多葛学派主张控制情绪和重振意志，以此对诱惑和突然的冲动或感觉印象保持警惕，这些都吸引着早期的西方宗教思想家。他们用斯多葛主义来诠释宗教文本并引导道德进步。\n斯多葛主义就其自身而言，开启的是践行沉思的传统，而非表达崇拜的传统。斯多葛式的沉思不是东方实践中常见的那种让忙乱的心灵安静下来的方法，它最终致力于帮助人们在对日常生活中大大小小挑战的处理中寻求平静。它训练的是审慎而非畏惧，从某种程度上讲，审慎并不会使人迷失。\n向前之路 我们生活在一个焦虑的时代。我们的政治观念遭到颠覆，民主制度遭遇威胁，对疾病的掌控力也遭遇考验。经济、社会和健康中的不平等将奴役之罪恶和美国的黑人歧视传统揭露了出来。道德愤慨普遍存在，失业率达到了自大萧条以来的最高水平，这一切都让人难以看清前路。我们需要领导者，需要教育，需要科学，需要更大程度的平等。\n斯多葛哲学家们无法帮我们解决所有这些问题，但他们能在有些困境中给予我们慰藉——关于死亡的教导、面对恐惧的生活技巧、对那些不由自主的情绪进行管理的方法、准备好应对突如其来的变故的更好办法、能支撑坚韧品质的人际关联感，还有仁慈与感恩在我们生命中的重要性。塞内卡提倡培育人性，但这仍然是一项未竟的事业。我们不仅要对灵魂进行修补，也要对社会进行修补。“有些东西取决于我们，而有些则并非如此。” 问题的关键并不在于什么事情发生在了你的身上，而在于你做何反应。这些都是我们所熟知的爱比克泰德给出的教导。然而我们却无法接受爱比克泰德遭受奴役的历史事实，并以此为自己的退却做辩护。从我们当下的身份、所处的时代以及我们所面临的政治挑战来看，退却就是懦弱的表现。我们必须在那些无法接受的事情上做出改变。而我们要改变它就必然不仅要改变我们自身，也要改变将我们这个集体建构起来的制度以及社会结构。这是一项社会性的事业，需要社会大众的决心，也需要对共同人性的信念。这就是奥勒留在战场上目睹破碎的人体部位四处散落之时心中所想之事。他对自己写道，如果你让自己脱离了共同体和共同体的整体福祉，那这就是后果。你会使自己成为被放逐于人类群体之外的“流浪者”。\n斯多葛学派还就价值观的崩塌——虚假的荣誉、贪婪、过分唯物质论提出了警告。塞内卡还对极力要求下属忠诚的暴君提出了警告。他了解那些为宫中谋杀进行掩饰的演讲稿撰写者们。为了让忧心忡忡的民众冷静下来，他们书写仁慈，声称对对方的谋杀是终点而非更多杀戮的起点。塞内卡就是这样的一个演讲稿撰写者，他的双手也不干净。他的哲学作品充满了权力与害怕失去权力之间、忠诚及其代价之间、富裕与节制之间的张力。在某种程度上，他的写作是在祈求救赎。他为寻求自由而写作。\n斯多葛主义是一种在面对威胁生存的严酷的外部制约时，延续和培养内在美德的方法。这是一种适合当时那个时代的哲学，让人感觉它就是为那个时代而生的哲学。然而我们是现代人，我们要从古人那里学习的还有很多，但也有一些错误是我们要避免的。斯多葛式的训练、坚韧、美德以及理性与合理性之间的纽带都能使我们团结起来，应对个人的和集体的挑战。但这只有当理性的血管中流动着同理之心和仁慈之情的血液时才能实现。这就是那条向前之路，那条健康的现代斯多葛之路。\n","date":"2024-05-23 15:00:00","updated":"2024-05-25 16:00:00"}]