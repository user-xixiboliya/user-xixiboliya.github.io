[{"objectID":"1736899200","permalink":"/post/git%E7%9B%B8%E5%85%B3/","title":"Git 相关","content":"本文前半部分较为基础，后半部分对.git目录下进行了相关的解释。\n基本命令 cd : 改变目录 cd .. 退回到上级目录 cd (filename)进入文件夹 pwd 显示当前目录 clear 清屏 ls 显示当前目录下的所有文件 touch （文件名.后缀） 新建一个文件 rm （文件名.后缀） 删除一个文件 mkdir test 建立一个test目录 rm -r test 删除test mv index.txt test 移动index至test中 history 查看历史命令 help 帮助 exit 退出 git项目基础 cd /path/to/your/project # 进入项目目录 git init # 初始化 Git 仓库 git add . # 添加所有文件到暂存区 git commit -m \u0026#34;initial commit\u0026#34; # 提交文件 git remote add origin https://github.com/your_username/your_repository.git # 添加远程仓库 git branch -M main 将本地主分支设置为main git checkout -b new-branch # 创建并切换到新分支 git push -u origin new-branch # 推送到新分支 内容过于基础，不再赘述。 .git /config --global、--system、--local 存在于.git/config中。高级别的设置会覆盖低级别的设置\ninstead of 配置 : git config --global url.git@github.com:.insteadOf https://github.com/ git 别名配置 git config --global alias.cin \u0026quot;commit --amend --no-edit\u0026quot;用cin代替。git commit --amend --no-edit 命令可以修改上一次提交的变更内容。 git config -l 当前项目下的配置 git config --system --list 查看系统的配置 git config --global --list 查看用户的配置 名字 邮箱等等 就是c盘用户目录下的.gitconfig 文件 git config --global user.name 进行更改 cat .git/config输出 git/objects git cat-file -p \u0026lt;commit hash\u0026gt; 这里的\u0026lt;commit hash\u0026gt;是在.git目录下的object的hash码，在项目根目录下使用tree .git可以看到。commit/tree/blob统一称为objects。\nblob 存储文件的内容 Tree存储文件的目录信息 commit存储提交信息，一个commit可以对应唯一版本的代码。 串联起来 通过commit寻找到Tree信息，每个commit都会存储对应的Tree ID。输入git log查看版本历史提交。如下：\ncommit 440c02148f899929c2faa3cbf5ca42f3f8785296 Author: utopia-x \u0026lt;your-email@linboxi123@163.com\u0026gt; Date: Sat Jan 4 16:29:19 2025 +0800 接着， 通过Tree找到对应的目录树信息：\nxixiboliya@laptop-tex4-of-boxing MINGW64 /e/mywebsite/Bertsin\u0026#39;s web (main) $ git cat-file -p 440c02148f899929c2faa3cbf5ca42f3f8785296 tree 91af69bb0a1bb9c836d9c57177cddfe1cd7da56b author utopia-x \u0026lt;your-email@linboxi123@163.com\u0026gt; 1735979359 +0800 committer utopia-x \u0026lt;your-email@linboxi123@163.com\u0026gt; 1735979359 +0800 first commit 通过Tree中获得blob的ID，通过blob获取对应的文件内容。 输入$git cat-file -p 91af69bb0a1bb9c836d9c57177cddfe1cd7da56b有： .git/refs head 分支名字存储在rref/heads文件夹下面。\nxixiboliya@laptop-tex4-of-boxing MINGW64 /e/mywebsite/Bertsin\u0026#39;s web (main) $ cat .git/refs/heads/main 156836544ef549d2a6af0774c7304eda45266672 tag refs文件存储的内容就是对应的commit ID，因此把ref当作指针，指向对应的commit来表示当前ref对应的版本。\ngit tag v0.0.1 annotation tag git -a v0.0.2 -m \u0026#34;add feature 1\u0026#34; cat .git/refs/tags/v0.0.2`输出object的hash值 git cat-file -p [hash] 输出相关信息 其中就有annotation tag。\n回溯历史版本代码 通过ref指向的commit可以获取唯一的代码版本。\ncommit --amend修改最近的一次commit信息，修改之后commit id 会变化。 rebase通过git rebase -i HEAD~3可以实现对最近三个commit的修改。\n合并commit 修改具体的commit message 删除某一个commit git gc 可以删除一些不需要的object以及会对object进行一些打包也锁来减少仓库的体积。\ngit gc --prune=now指定修剪多久之前的对象，默认是两周前。\nreflog reflog是用于记录操作日志，防止误操作后数据丢失。通过reflog来找到丢失的数据，手动将日志设置为过期。\ngit reflog expire --expire=\u0026#34;2.weeks.ago\u0026#34; --all clone与fetch git fetch将远端某些分支最新代码拉取到本地，不会进行merge操作。会修改refs/remote内的分支信息，如果需要和本地代码合并需要手动操作。\npull等于上述clone 和fetch的综合。不知道远端的修改建议先fetch在进行rebase。\n","date":"2025-01-15 00:00:00","updated":"2025-01-15 00:00:00"},{"objectID":"1735510200","permalink":"/post/%E6%88%91%E7%9A%842024%E6%80%BB%E7%BB%93/","title":"my 2024 summary","content":" 我的2024总结 hi~\n","date":"2024-12-29 15:00:00","updated":"2024-12-29 16:00:00"},{"objectID":"1735063200","permalink":"/post/doxygencommit/","title":"Doxygen 与 commit规范","content":" 开始之前 首先推荐大家在vscode中下载插件==通灵译码==或者==GitHub complie==，能极大偷懒提升效率。 示例： 什么是Doxygen Doxygen 是一种文档生成工具，常用于整个项目的Doxyfile的生成，主要用于从源代码中提取注释，并生成技术文档。它广泛用于 C++、C、Java、Python 等多种编程语言中，帮助开发者自动生成文档，从而提高代码的可读性和维护性。\n具体功能： 从代码注释中生成文档：Doxygen 通过解析源代码中的特殊注释格式，将其转换成 HTML、LaTeX、XML 等多种格式的文档。\n支持多种编程语言：除了 C 和 C++，Doxygen 还支持 Java、Python、PHP 等许多其他语言。\n交叉引用代码和文档：Doxygen 可以生成类结构、函数调用图等内容，使得文档与代码紧密结合，便于开发者理解代码的架构。\n可生成不同格式的输出：例如 HTML 文档可以方便地作为在线帮助系统，LaTeX 格式可以用于打印高质量的 PDF 文档。\n下载与使用 vscode插件 在扩展商店里搜索并安装如下扩展\nDoxygen Documentation Generator 接着按下ctrl+shift+p，输入settings.json，打开工作区设置，可以设置快捷键和默认样式\n{ // 触发快捷键 \u0026#34;doxdocgen.c.triggerSequence\u0026#34;: \u0026#34;///\u0026#34; //在函数名前插入 `///`+回车，触发函数注释 } 进一步也可以：\n{ // 起始行样式 \u0026#34;doxdocgen.c.firstLine\u0026#34;: \u0026#34;/*!\u0026#34;, // 模版文件样式 \u0026#34;doxdocgen.cpp.tparamTemplate\u0026#34;: \u0026#34;@tparam{indent:15}{param}\u0026#34;, // 文件头注释样式 \u0026#34;doxdocgen.file.fileTemplate\u0026#34;: \u0026#34;@file{indent:15}{name}\u0026#34;, // 函数注释样式 \u0026#34;doxdocgen.generic.useGitUserName\u0026#34;: true, \u0026#34;doxdocgen.generic.authorTag\u0026#34;: \u0026#34;@author{indent:15}{author}\u0026#34;, \u0026#34;doxdocgen.generic.briefTemplate\u0026#34;: \u0026#34;@brief{indent:15}{text}\u0026#34;, \u0026#34;doxdocgen.generic.dateTemplate\u0026#34;: \u0026#34;@date{indent:15}{date}\u0026#34;, \u0026#34;doxdocgen.generic.paramTemplate\u0026#34;: \u0026#34;@param{indent:15}{param}\u0026#34;, \u0026#34;doxdocgen.generic.returnTemplate\u0026#34;: \u0026#34;@return{indent:15}{type}\u0026#34;, // 自定义标签、顺序 \u0026#34;doxdocgen.file.fileOrder\u0026#34;: [\u0026#34;file\u0026#34;, \u0026#34;author\u0026#34;, \u0026#34;date\u0026#34;], \u0026#34;doxdocgen.generic.customTags\u0026#34;: [\u0026#34;@attention\u0026#34;] } Windows下载doxygen 打开开始菜单，查找“Doxygen”。如果未找到，说明你需要下载并安装 Doxygen。 访问 Doxygen 官方下载页面，下载适用于 Windows 的 Doxygen 安装包。 安装完成后，重新打开 VSCode 尝试运行 doxygen。 Ubuntu / Linux sudo apt-get install doxygen 打开终端，编辑 .bashrc 文件:\nvim ~/.bashrc # 对于 Bash Shell 添加以下内容：\nexport PATH=\u0026#34;/usr/local/bin:$PATH\u0026#34; 保存文件并刷新终端配置：\nsource ~/.bashrc # 使用 Bash 使用 文件头 这部分包括license、版权声明注释、文件描述注释。 函数 接着在函数名前、#include前输入/***/或者///并且分行，便可以使用Doxygen。 将鼠标hover在函数上会出现如下信息： 生成Doxyfile 打开当前工作目录，在终端中输入:\ndoxygen -g // g是generate，用于生成默认的 `Doxyfile` 配置文件。 此时你的项目下会多一个Doxyfile。 如果你想进一步，可以：\ndoxygen 你的项目下会生成html和latex文件夹。\n语法 文件 @file： 文件名 @brief：文件一句话介绍 @author：文件作者 @date：修改日期 @see：额外的一些参考信息，比如有用过的链接 @addtogroup ：创建函数分组 ，@{ 和 @} 表示分组的开始和结束 /** @addtogroup DOXYGEN_API * @brief Doxygen api example. * * Detailed api description. * * @{ */ /** * @brief A sample function in the API group. * * This function demonstrates a typical API function. * * @param a Input parameter. * @return Result of some computation. */ int sample_function(int a) { return a * 2; } /** @} */ 结果在doxygen Doxyfile中：\nAPI Groups: - DOXYGEN_API - sample_function (A sample function in the API group) 变量前的注释 /** * @brief Use brief, otherwise the index won\u0026#39;t have a brief explanation. * Detailed explanation. */ typedef struct BoxStruct { int a; /**\u0026lt; Some documentation for the member BoxStruct#a. */ int b; /**\u0026lt; Some documentation for the member BoxStruct#b. */ double c; /**\u0026lt; Etc. */ } tBoxStruct; API 函数注释样例 /* GLOBAL FUNCTIONS */ /** * @brief Example showing how to document a function with Doxygen. * * Description of what the function does. This part may refer to the parameters * of the function, like @p param1 or @p param2. A word of code can also be * inserted like @c this which is equivalent to \u0026lt;tt\u0026gt;this\u0026lt;/tt\u0026gt; and can be useful * to say that the function returns a @c void or an @c int. If you want to have * more than one word in typewriter font, then just use @\u0026lt;tt@\u0026gt;. * @param [in] param1 Description of the first parameter of the function. * @param [out] param2 The second one, which follows @p param1, and represents output. //变量 * * @return Describe what the function returns. * @retval XXX_OK if successful. * @see doxygen_theSecondFunction * @see Box_The_Last_One * @see \u0026lt;http://website/\u0026gt; * @note Something to note. * @warning Warning. */ int doxygen_theFirstFunction(int param1, int param2); @param：标记变量 [in] [out]表示输入输出方向 @return：返回值描述 @retval：具体返回值及其含义 @see：link信息 @note：备注信息 @warning：需要函数使用者注意的信息，比如：功能未经完全验证 commit规范 1.示例 2. 提交标题（Subject Line） 动词时态：使用 祈使句（动词原型），描述这次提交所做的工作。比如：\nAdd login feature（添加登录功能） Fix button alignment issue（修复按钮对齐问题） Update README for installation instructions（更新 README，添加安装说明） 3. 常见的提交类型 为了规范化提交标题中的描述，项目或团队会使用特定的前缀来标记提交的类型。这些前缀可以帮助人们快速了解提交的目的。例如：\nfeat：引入新功能（feature）。 feat: add user login functionality fix：修复 bug。 fix: resolve password hashing issue docs：仅更新文档。 docs: update API documentation style：代码风格的调整（不涉及功能或逻辑变化），如格式化、空格调整等。 style: reformat code with prettier refactor：重构代码，通常是改善代码结构，但没有新功能或 bug 修复。 refactor: optimize login function test：添加或修改测试。 test: add tests for user authentication chore：不影响源代码的其他更改，如构建过程、依赖管理等。 chore: update npm dependencies perf：性能优化。 perf: improve database query performance 4.参考资料 具体可以参考这篇文档 如何规范你的Git commit？ - 知乎 (zhihu.com)\n","date":"2024-12-24 11:00:00","updated":"2024-12-24 11:00:00"},{"objectID":"1734991800","permalink":"/post/%E7%BD%AE%E8%BA%AB%E4%BA%8B%E5%86%85/","title":"《置身事内》读后记","content":" 《置身事内》 本文作为全书内容的大体回顾会更好一些。\n这是一本关于中国政府与经济发展的书，政府不仅参与公共服务，也深刻影响着资源与分配。 先姑且描述一下各个章节的内容：\n第一章讨论的事权划分的三种理论：公共服务的规模经济与边界、信息复杂性、激励相容。 第二章通过对改开初期以来的分税制改革和土地财政的招商税收，初步概述了土地作为杠杆撬动信贷和各类资金的作用，也为政府债务、融投资埋下伏笔。 第三章重点讲述政府投融资与债务，加快的城镇化建设催生城投债与城投公司的兴起，当然土地投资有成功也有失败，引申出地方债的治理与改革。至于为何投资，涉及到官员激励与腐败的方面。本章使用金融财政学的术语较多，阅读起来需要一些耐心。 第四章讲述政府在工业化进程中的角色，书中举了京东方光电显示产业链和光伏发电从成本高用量少的研发阶段到平价市场化的过程来阐释。并介绍了居住土地和工业用地的定价逻辑以及政府引导基金建立的动机历程。 第五章阐述城市化进程中居民贫富差距的不平衡问题。房价房债、按揭贷款、土地流转以及户籍改革在本章被探讨，重视工业生产将转向重居民重民生，这是作者对服务型转向的一些看法。 对“防范化解重大风险”的讨论，第六章探讨中国政府的债务与风险，从四万亿计划到货币化“棚改”等等，本章聚焦于地方政府融资平台和国企、债主银行的债务。债务根源于我国经济发展的模式与结构，在降债务的过程中必然伴随着一系列深层次结构性改革。 我国经济结构最失衡的特点是消费不足。地方政府重生产重投资导致10年初我国制造业的巨大产能对外输出，进而引发贸易冲突。我国居民拥有高储蓄率但收入占比过低，重扩张的优点是能快速扩大投资和对外贸易，利用全球化的契机拉动经济快速增长，尽管缺点是经济结构上失衡。 本书一共讲述了七章，第五章开始讲述了宏观的经济现象。第八章则是对前述的总结，纵横捭阖颇为精彩。采用市场经济的理论研究中国经济，此二者之间的张力为研究分配制度、改革措施以及发展历程提供了良好的入口。不同“假想”、不同“标准”对于完善市场经济各有判断标准，换一套标准的政策制定可能完全不同。哈佛大学经济学家申克龙的话：“一套严格的概念框架无疑有助于理清问题，但也经常让人错把问题当成答案。社会科学总渴望发现一套‘放之四海而皆准’的方法和规律，这种心态需要成熟起来。不要低估经济现实的复杂性，也不要高估科学工具的质量。”\n这里还有一段精彩的论述：\n经济落后的国家之所以落后，正是因为它缺乏发达国家的很多硬件或软件资源，缺乏完善的市场竞争机制。在推进现代化的进程中， 落后国家所采用的组织和动员资源的方式，注定与发达国家不同。落后国家能否赶超，关键在于能否找到一套适合国情的组织和动 用资源的方式，持续不断地推动经济发展。所谓“市场在资源配置中起到决定性作用”，站在今天的角度上看是未来的趋势之一，但 往后看市场的经济状况也是几十年来经济、政府、社会协同发展和建设的结果。 我国曾在二十世纪六七十年代进行过工业体系的分散化，当时是叫做“三线建设”的开展。以一个全国整合工业资源的角度看确实不妥。这种先分散后整合的方式被解释为能够带动地方农民向工人阶级的转变，为二十一世纪工业加速提供了愿意外出闯荡的大量劳动力，也为地方政府“官场+市场”的竞争和属地管理提供了地区经济的推动力。\n常谈道发展中国家各自的发展模式不尽相同，我国发展中各个省的发展路径和发展方式也不尽相同。社会现实决定了经济发展的政策边界。例如工业化城市化的进程，微观而言则是农民到工人的演变问题，落到个人身上是观念的剧变。作者提到我国可行的政策空间和演变路径受三大制度约束：农村集体所有制、城市土地公有制、户籍制度。因而中国的工业化才离不开乡镇企业的发展，离不开“土地财政”和“土地金融”。政策的制定伴随着利益的约束，研究发展过程的经济学还讨论了发展顺序和发展节奏，政策的路径和步骤、激进与否都有利益冲突，这种必然指引着一种“渐进式改革”的兴起：允许拖低效率的资源错配，建立缓冲机制，因为人需要花时间去适应。\n作者认为，经济学的主要作用仍是发现和提出问题，解决问题仍然只能在摸索中产生——这需要权衡取舍、调整改进、需要魄力。发现和提出好的问题是解决问题的第一步，“提问”本身也是一门艺术，切中要害的问题一定是对于现实具有深刻的理解。“具体问题具体分析”的道理是不会过时的精神。\n推荐书目 冯军旗 《中县干部》 周黎安 《转型中的地方政府：官员激励与治理》\n耶鲁大学哥顿《银行的秘密：现代金融生存启示录》\n保尔森《与中国打交道：亲历一个新经济大国的崛起》\n潘功胜《大行蝶变：中国大型商业银行复兴之路》\n哈佛大学 傅高义 《邓小平时代》\n复旦大学历史地理学家葛剑雄《统一与分裂：中国历史的启示》\n复旦大学陈明明、中山大学肖滨《当代中国政府与政治》\n","date":"2024-12-23 15:00:00","updated":"2024-12-23 16:00:00"},{"objectID":"1732298400","permalink":"/post/datalab/","title":"Datalab","content":" 没得满分是因为在isAsciiDigit中使用了\u0026gt;\u0026gt;违规符号。没有用\u0026gt;\u0026gt;感觉不会写……请求各位大佬对此出谋划策，感谢！\n写在前面 这部分内容参考Arthals\u0026rsquo; ink。 btest：用于测试你的函数是否正确。仅在一个小的测试集上进行测试，不能完全保证你的函数是正确的。\n# 编译并运行 make \u0026amp;\u0026amp; ./btest # 对某个函数进行单元测试 make \u0026amp;\u0026amp; ./btest -f bitXnor # 对某个函数进行单元测试，且指定测试用例，以 -1 指定第一个参数，依次类推 make \u0026amp;\u0026amp; ./btest -f bitXnor -1 7 -2 0xf dlc：用于检查你的代码是否符合规范。\n# 检查是否符合编码规范 ./dlc bits.c driver.pl：用于评分，检查你的函数是否符合规范且正确。\n./driver.pl BitXor int temp = ~(x \u0026amp; y)这一步计算的是 x 和 y 各位同时为1的位置的反，即 temp 中的每个位都代表 x 和 y 对应位不同时为1。换句话说，它标记了 x 和 y 中至少有一个位为0的位置。 int a = ~(x \u0026amp; temp)这里使用 x \u0026amp; temp 获取 x 中与 temp 相应位都为1的位。由于 temp 已经标记了 x 和 y 中不同时为1的位置，x \u0026amp; temp 表示 x 是1且 y 是0的位置。~(x \u0026amp; temp) 则将这些位置置为0，其他位置置为1。 int b = ~(y \u0026amp; temp)类似于上面的 a，这里计算的是 y 中与 temp 相应位都为1的位，即 y 是1而 x 是0的位置。~(y \u0026amp; temp) 将这些位置置为0，其他位置置为1。 return ~(a \u0026amp; b);此步骤中，a \u0026amp; b 会在 x 和 y 中同时为0或同时为1的位上返回1（因为只有这两种情况下，a 和 b 的对应位同时为0，取反后为1）。因此，~(a \u0026amp; b) 将这些位置反转，从而得到 x 和 y 的按位异或结果，即只有当 x 和 y 的某位不同时，该位才为1。 int bitXor(int x, int y) { int temp = ~(x\u0026amp;y); int a = ~(x\u0026amp;temp); int b = ~(y\u0026amp;temp); return ~(a\u0026amp;b); } allOddBits int allOddBits(int x) { int mask0 = 0xAA; int mask1 = mask0 \u0026lt;\u0026lt; 8; int mask2 = mask0 \u0026lt;\u0026lt; 16; int mask3 = mask0 \u0026lt;\u0026lt; 24; int mask = mask0 | mask1 | mask2 | mask3; return !((x\u0026amp;mask)^mask); // ((x|mask)^mask)结果为零的话则说明所有的偶数位均为0 } Tmax answer1 int isTmax(int x) { return !((x+1)^(~x) \u0026amp; ((x+1)\u0026gt;\u0026gt;31)) ; } answer2 当 x 是 Tmax (0x7FFFFFFF):x + 1 会变成 Tmin (0x80000000)，并且 y ^ (~x) 会是0，!!y 会是1，因此返回1。 当 x 不是 Tmax: 如果 x 是其他数，y ^ (~x) 会是非零值，或者 y 为0（针对 x = -1 的情况），结果返回0。\nint isTmax(int x) { //return ( (!((x+1)^(~x))) \u0026amp; ((x+1)\u0026gt;\u0026gt;31) ); int y = x + 1; return !(y ^ (~x)) \u0026amp; !!y; } isMax 我有些违规。。\nint isTmax(int x) { return ( (!((x+1)^(~x))) \u0026amp; ((x+1)\u0026gt;\u0026gt;31) ); //int isTmax(int x) { //int y = x + 1; //return !(y ^ (~x)) \u0026amp; !!y; } } Tmin int tmin(void) { return 1\u0026lt;\u0026lt;31; } negate 返回 -x。这个运用书上的结论就好。。\nint negate(int x) { return ~x+1; } isAsciiDigit 0x30 是 0011 0000，0x39是0011 1001。也就是满足第五位和第六位都是1的前提下，第四位如果是零，则剩下三位怎么取都可以。第四位如果是1，剩下的2、3位只能是0，第1位随意。others是用来检测剩下其它位到底是不是1，因为在make \u0026amp;\u0026amp; ./btest时，对于-1853013669[0x918d415b]出错了。\nint isAsciiDigit(int x) { int others = !(x \u0026gt;\u0026gt; 6); int x6 = (x \u0026amp; 0x30)\u0026gt;\u0026gt;5; int x5 = (x \u0026amp; 0x10)\u0026gt;\u0026gt;4; int x4 = (x \u0026amp; 0x08)\u0026gt;\u0026gt;3; int x23 = !(x \u0026amp; 0x06); //x is \u0026#39;~00~\u0026#39;, then x23 is 1;it\u0026#39;s good. return others \u0026amp; x6 \u0026amp; x5 \u0026amp; ((x4 \u0026amp; x23) | !x4); // 0011 1010 } conditional 本题要求实现same as x ? y : z . Example: conditional(2,4,5) ，使用!!将数映射到{0,1}，如果~x+1的结果全为1的话，使用 \u0026amp;可以保留y的性征，同理z。\nint conditional(int x, int y, int z) { x = !!x; x = ~x+1; return (x \u0026amp; y) | (~x \u0026amp; z) ; } logicalNeg 只有0与它的补码（它自己）的|的最高位为0。\nint logicalNeg(int x) { return !((x | (~x+1)) \u0026gt;\u0026gt; 31); } Floatscale2 通过按位与操作提取符号位、指数位和尾数位：\ns：最高位（第31位）为符号位，决定浮点数是正数还是负数。 exp：指数位（第23到30位），决定浮点数的数量级。 frac：尾数位（第0到22位），决定浮点数的小数部分。 处理非归一化数（exp == 0 的情况） 如果尾数的最高有效位（第22位）为 1，则此时需要将指数加 1，表示进入归一化数状态，同时将尾数左移一位。否则，直接将尾数左移一位，表示乘以 2。 处理归一化数（exp != 0 且 exp != 0x7F800000 的情况）： 正常情况下，指数加 1，表示乘以 2。如果指数加 1 后变为全 1，则表示结果为无穷大，尾数置为 0。 最后没想到是要写!(exp ^ 0x7F800000)，写成!(~(exp \u0026amp; 0x7F800000 ))不行！？ unsigned floatScale2(unsigned uf) { int s = uf \u0026amp; 0x80000000; int exp = uf \u0026amp; 0x7F800000; int frac = uf \u0026amp; 0x007FFFFF; if (exp == 0) { if (frac \u0026amp; 0x00400000) { exp += 0x00800000; frac = (frac\u0026lt;\u0026lt;1) \u0026amp; 0x007FFFFF; } else { frac = frac \u0026lt;\u0026lt;1; } } else if (!(exp ^ 0x7F800000)){ // wu qiong return uf; } else { exp += 0x00800000; //如果 `exp == 0x7F800000`，即指数全为 1，表示无穷大或 NaN，直接返回原数值。 if (exp==0x7F800000){ frac = 0; } return s | exp | frac; // 最后将符号位、指数位、尾数位重新组合为一个无符号整数返回 } floatPower2 unsigned floatPower2(int x) { int exp = x \u0026amp; 0x7F800000; int ret; exp = exp \u0026gt;\u0026gt; 23; if (x\u0026gt;127) return (0xFF\u0026lt;\u0026lt;23); if (x\u0026lt;-149) return 0; if(x \u0026lt; -126) return 0x1 \u0026lt;\u0026lt; (x + 149); exp = x + 127; ret = exp \u0026lt;\u0026lt; 23; return ret; } howMantBits 最具有难度的一个。 (b16 + b8 + b4 + b2 + b1 + x + 1) 正负数都是因为x -\u0026gt; |x| -1 才要补上1的。\nint howManyBits(int x) { int s = x\u0026gt;\u0026gt;31; int b16,b8,b4,b2,b1; x = x ^ s; //calculate right shift 这里无形中是算术右移，s=0xFFFFFFFF //result is x -\u0026gt; |x| -1 b16 = !!(x\u0026gt;\u0026gt;16) \u0026lt;\u0026lt;4;/* 0000 0000 0000 1000 0000 0000 0000 0000 */ x = x \u0026gt;\u0026gt; b16; b8 = !!(x\u0026gt;\u0026gt;8) \u0026lt;\u0026lt; 3; x = x \u0026gt;\u0026gt; b8; b4 = !!(x \u0026gt;\u0026gt; 4) \u0026lt;\u0026lt; 2; x = x \u0026gt;\u0026gt; b4; b2 = !!(x \u0026gt;\u0026gt; 2) \u0026lt;\u0026lt; 1; x = x \u0026gt;\u0026gt; b2; b1 = !!(x \u0026gt;\u0026gt; 1) \u0026lt;\u0026lt; 0; x = x \u0026gt;\u0026gt; b1; return (b16 + b8 + b4 + b2 + b1 + x + 1); } 至此，完成。\n","date":"2024-11-22 11:00:00","updated":"2024-12-20 11:00:00"},{"objectID":"1731542400","permalink":"/post/vpn%E6%95%99%E7%A8%8B/","title":"Linux/ubuntu VPN教程","content":" Ubuntu 22.04 VPN配置教程 ubuntu版本不同其实差别不是很大。\n步骤一：建立clash文件夹并导入安装包 mkdir clash cd clash 之后在本仓库下载clashpremium-release-linux-amd64.s1lSU-Ho.tar.gz导入到~/clash/路径下，换言之，就是将安装包放置在clash文件夹里面，之后解压该文件，并修改命名为clash\nbash tar -xzvf clashpremium-release-linux-amd64.s1lSU-Ho.tar.gz.tar.gz 步骤二：配置VPN参数文件 wget -O config.yaml \u0026#34;https://cqd4w.no-mad-world.club/link/JMdr9H6ofZOHDvJO?clash=3\u0026#34; 步骤三：执行配置命令实现启动clash和VPN代理 chmod +x clash ./clash -d . 执行效果图如下所示： 步骤四：购买机场提供的稳定VPN,并修改设置网络参数 机场链接IKUUU VPN\n在这个机场里面选择VPN网络包,效果如下图所示 以 Ubuntu 20.04 为例，打开系统设置，选择网络，点击网络代理右边的设置按钮，选择手动，填写 HTTP 和 HTTPS 代理为 127.0.0.1:7890，填写 Socks 主机为 127.0.0.1:7891，即可启用系统代理\n修改图如下所示\n之后点击clash链接clash board\nclash界面如下图所示\n点击确定，之后便可享用VPN了\n最终clash效果图如下所示：\n外网游行\u0026ndash;Youtube展示:\n平日开启VPN的方法 在终端中cd到clash的文件夹下，输入./clash -d .启动clash，启动完之后一般不要使用ctrl+c或ctrl+z打断运行，否则再次输入./clash -d .运行会出现端口占用，如果打断了就只能：\npa aux | grep clash kill -9 [端口号] 在浏览器中打开ikuuu的dashboard，里面可以配置代理和节点。\n","date":"2024-11-14 00:00:00","updated":"2024-11-14 00:00:00"},{"objectID":"1716502200","permalink":"/post/%E5%81%A5%E5%BA%B7%E7%9A%84%E6%96%AF%E5%A4%9A%E8%91%9B%E4%B8%BB%E4%B9%89/","title":"一种健康的现代斯多葛主义","content":" 一次最意外的考验 “骑行者vs.小鹿”——这是护士递给我的医学报告的标题。在我正为这本书写结尾时，我迎来了一场最终的考验，而这恰是我未曾预演的事情。我先生马歇尔那时正在离家不远的岩溪公园（Rock Greek Park）骑车，他碰到了一只拿不定主意该如何过马路的鹿。它起初选择了一个方向，已经快要到达马路的另一边了，但是看到一辆车开过来，它立即转身返回，然后又再次尝试过马路。我先生和那只鹿发生了碰撞。那只鹿毫发无伤地逃走了，而留给我先生的是：七根断了的肋骨、肺萎陷和肩膀脱臼。急诊室医生告诉我，他“遭遇了惨烈的撞击”，我听到这个消息之后一度昏厥。“我们将不得不把他送到华盛顿特区的一家创伤中心。”医生说。\n新型冠状病毒正在我们的城市肆虐。我和先生已经采取了全部的防护措施并且基本上在封锁中度过了5个月的时间，而现在我们要去一家大的城市医院。\n作为一个斯多葛主义者，我此时应该如何思考问题？爱比克泰德在我耳边轻语道：“那只是他的躯体而已。”\n你一定是在开玩笑，我想。他的大脑就在他的躯体中。我有些朋友是当医生的，他们帮我理解了“连枷胸”（flailed chests）、肺炎、肺部功能、神经学问题以及应当在认知的层面上注意什么。他们让我做到的事情是否有认知上的谬误呢？“那真的只是他的躯体吗？”斯托克代尔曾是一名海军飞行员，他在战争中被击落，落入敌军手中，他的腿可能就是在此期间被打伤的，后来成为战俘的他又被敌军折磨了超过7年的时间。他在爱比克泰德那里找到了救命稻草。爱比克泰德是一个曾遭奴役的斯多葛思想家，同样是个瘸子。然而我的先生却不是战俘。最近一直让我忧虑的敌人是一种恶性病毒，我们正在尽最大努力巧妙地跟它斗争。但我没想过他会被一头犹豫不决的鹿撞到。\n“惨烈的撞击”在我脑中反复盘旋。我已经花了整整一周的时间来专门思考罗马奴隶们遭受的残酷殴打和斯多葛式的评论。斯多葛学派看轻身体上的痛苦，这一点众所周知。但因运气不好而遭受的苦难与因他人的非正义行为所遭受的苦难之间的界线也被他们磨平了。如果你是个谨慎并且负责的骑行者，那么被鹿撞到是源于运气不好，然而被当成奴隶严刑拷打就是源于非正义的行为。\n塞内卡抨击了施加在罗马奴隶身上的残酷行为。但是这更多的是一种利己性的考量而不是为人性所做的辩护：被奴役者可能背叛奴役他的人；让奴隶们感到感激总比让他们感到害怕要好；对他们施以恩惠，他们也许会以恩惠回报，比如代你赴死：“假设我告诉你，有人不顾自己的安危也要保护主人，伤痕累累，抛头颅洒热血，以自己的生命为代价为他的主人争取逃脱的时间。”\n这里所说的道德上的教益在于，被奴役之人也能表达仁慈。而这一点在政治上为塞内卡的目标受众（即精英阶层）带来的教益则在于，当你想鞭打仆人时，对你盛怒的情绪加以控制是有好处的。而肉体、肉体的完整性和肉体痛苦，还有人以及他因其人性而应得的尊重，都不在这些道德和政治上的教益范围中。\n斯多葛学派教导我们，我们都为外在的权力所奴役。但他们也教导我们，我们中的有些人却比别人拥有更多的世俗权力。道德是一回事，而合法性和社会现实则是另外一回事。斯多葛学派从来都不挑战奴役制度。\n这也就为我们将要做出的最后思考奠定了基础。我们要如何在古希腊和古罗马文化的基础上建立起一种健康的现代斯多葛主义呢？在当下的“取消主义文化”盛行以及对前代典范全盘推翻的背景下，为什么还要与那些不仅纵容奴隶制，而且还将内在自由赞美为最神圣的解放的古代哲学家为伍呢？\n犬儒者第欧根尼是斯多葛主义极具代表性的人物，他穿着异性的服装，在公众面前炫耀自己的身体部位，他还排斥婚姻，认为这只是一种习俗，但不论他在多大程度上与传统习俗相背离，他都没有反对过奴役的传统，即使他自己就是个奴隶。他在追求一种别样的自由与掌控。因此，他在拍卖台上指着人群中的一个科林斯人厚着脸皮打趣道：“快把我卖给这个人吧，他需要一个主人。”\n内在的主宰才是真正的解放。最负盛名的被奴役的斯多葛思想家爱比克泰德成了一位受过良好教育的老师，他的追随者不计其数，其中还包括一位君主。但他从来没有抨击过奴隶制度。如果说鞭打被奴役者会在道德上遭到反对，那么罪恶在于当权者的堕落，而不在于遭鞭打之人的堕落 。同样地，他的老师穆索尼乌斯·鲁弗斯教导道，奸夫与女性奴隶通奸，他真正的罪恶在于意志薄弱，而不在于任何对待女性的不正义行为。 奴隶的真正力量在于其面对命运和苦难时所具有的精神独立性。不对欲望进行强有力的控制是一种罪恶，不论我们谈及的是男性与被奴役的女性厮混，还是女性与被奴役的男性厮混。这里当然存在性别平等的观念，但真正的罪恶，即那种意志上的薄弱，在男人那里更为严重。\n奴役是普遍存在的：我们都被命运和身体的欲望紧紧掌控。自由同样是普遍存在的：我们都享有人性和理性。与亚里士多德的看法相反，斯多葛学派认为，奴役没有任何自然基础，这样的观点简直已是老生常谈了 。我们身处一个拥有共同来源和共同命运的共同体中。\n事情可能确实如此。但是精神上的平等并不意味着日复一日的社会现实境遇上的平等 。塞内卡一生中的大多数时间都生活在富足中。他家中的佣人、随从的数量简直让唐顿庄园都逊色几分。斯多葛学派把获得力量的希望寄托在共同体和对他人的信赖上。但在实践中，这种信赖并不总是可靠的。爱比克泰德训诫道，你的身体“就像一头因背着它自己的驮鞍和缰绳而负载过重的可怜驴子” 。身体是一具会“被迫投入公共服务中”的工具。“不要反抗或者抱怨，否则你就输了。”这就是这场交易在被奴役者身上的体现。\n既然我们在这一课中要为之前的课程作结，我之前还没有表明立场，那么我在此阐述。我的教学和写作都与古典及现代伦理学相关。我对那些文本充满喜爱，我仔细研读它们，与它们辩论，我还要求我的学生对其进行认真的阅读并且努力与它们辩论。我并不是一个严格的斯多葛主义者（不论它对现代人而言意味着什么），也不是一个斯多葛文本的阐释者。我把自己摆在一个好奇又好学的新斯多葛派立场上，捕捉古代斯多葛主义中的精华和现代斯多葛主义中有价值的教益。\n关于构建一种健康的现代斯多葛主义，我已含蓄地采用了一些原则作为背景性的指引：\n1.心理层面的掌控不能以牺牲人类的脆弱性为代价。\n2.对他人的依赖有赖于互相合作、彼此尊重、互相支持的共同体的建立。\n3.否定身体或心灵的痛苦，并不是面对磨难时永恒的解决方案。\n4.要对迅速产生的感觉印象进行密切的注视，包括由恐惧、愤怒和欲望造成的扭曲和偏见。\n对这些原则，我已经展示了我是如何在斯多葛主义的文本中为之找到立足点的——有些与情感的多个层次有关，有的与同理心以及全球人类的连接性有关，有的还与心理和道德上的困扰以及同情在心理创伤治愈中发挥的作用有关，还有的与注意力发挥的作用有关。我对那些文本向来充满敬意。但我同样努力让这些文本开口对我们说话，也让我们对它们说话，对之提出质疑，思考新的实践。\n但我们仍然没能对斯多葛学派关于奴役制度的看法做出合适的清算。在这样一个我们要对自己的奴役史进行清算的时代，在“黑人的命也是命”的时代里，我们应该如何评估现代斯多葛主义呢？\n我们要关注塞内卡的看法，尤其要关注《书信集》里的第47封信。尽管有些现代学者曾把其中塞内卡的观点视为当代人文主义思想的古代根据 ，且认为其具有启蒙特征，但现在人们普遍认为事情恰恰相反。塞内卡“为以仁慈的方式对待那些被奴役者提出了强有力的辩护”，但这更多的是出于自身的利益而非社会良知。奴役制度对罗马上层人士而言十分重要。作为尼禄的御用顾问，塞内卡所强调的完全就是“对现状的接受”。\n“‘他们是奴隶。’不，他们是人。” 所以在与卢基里乌斯（Lucilius）的通信里，塞内卡在开篇就与他讲起应该如何对待他家中被奴役的佣人。他接着立刻就像连珠炮一样对自己的密友说：\n“他们是奴隶。”\n“不，他们是你的室友。”\n“他们是奴隶。”\n“不，他们是出身卑微的友人。”\n而接下来的这一个回合就传递了关键的道德教导：\n“他们是奴隶。”\n“他们是跟你一样的奴隶，尤其是如果你还没忘记你的命运和他们的命运都同样由老天爷说了算。 ……你们是由同样的种子长成的。 ……灾祸能使那些‘出身上流的贵族们’低贱。同等的运气和人性使你们成为平等的人。”\n然而，正如亚里士多德所说，那些出身上流的贵族雇用奴隶，而被奴役者却是工具，即便是在斯多葛主义那里，也只是任凭习俗和机遇支配的奴隶 。那这些工具被用来做什么呢？他们擦净宴会上的唾沫和呕吐物，切开饭桌上的珍禽，在公共场合给别人端茶送水，但在私下却要满足别人的淫欲——“因为他只在聚会上是个男孩，在卧室里他是个男人”。 他了解那些上流人士的品位，哪些食物“能让他喜笑开颜”，哪些会让他“恶心想吐”，哪些食物他“十分渴望”“哪些食物让他开心”；知道他喜欢跟谁一块儿用餐，知道谁“配不上他高贵的地位”。这种从权力的侧面切入、分门别类写好的详尽知识体系是为贵族群体而建立的，而他们则要依赖被奴役的劳动者们。\n塞内卡为仆人订立的在家务中应承担的职能简直数不胜数：“厨子、面包师、按摩师、洗浴服务员、私人训练师、管家（大管事）。” 他的家务如此铺张，此外还会额外雇用美发师、客座发言人、贴身男仆、女招待、勤杂工和迎宾员、垃圾搬运工，以及那些管束病人和疯子的人。从早晨醒来一直到夜晚沉思的时光，都要依赖奴隶的帮助，需要他们帮忙处理贵族化日常生活中的诸多事务——在屋里满足主人所有心血来潮的奇想和需要，在屋外打理花园和土地。“从根本上讲，奴隶的出逃对主人来说是一种困扰……奴隶主们的财产在这方面所遭受的损失从来都不轻。” 这毫不奇怪。失去一名奴隶对家庭的生活方式和家政状况都会造成重大破坏。\n塞内卡也许会在夜晚沉思该如何克制自己对家庭侍从的愤怒，这是因为，在他那个社会，鞭打一个在晚饭时间发出了太多噪声或是打扰了正在整理家庭账务的地主（或者说得更直接些，正如他自己所叙述的那样，“当灯光熄灭，连我的妻子也不再言语”）的奴隶一点儿也不奇怪。在就寝或清晨时通过沉思来预演管制措施，也许意味着这个奴隶不会逃跑，也不会在严酷的审讯下袭击你。\n这就是塞内卡的境遇中以人道的方式对待奴隶所基于的社会基础，这也是对传统习俗做出的调整。而道德上的要求则更为崇高——就此而言，人人都在被奴役着。“告诉我谁能幸免于此！有的人被性欲奴役，有的人被贪婪奴役，还有的人被野心奴役——他们都是欲望的奴隶、恐惧的奴隶。”\n奴役是一种精神状态，在这种意义上人人皆是如此。所以不要认为“朋友只能在集会场所或是议院的大厅里才能交到”。你的后院中和家务事里也有朋友。一个人的“衣着”或是“生活中的地位”与他们真正的自由毫不相关， 应该自由的是精神。\n这既是斯多葛主义具有吸引力的一面，也是其有害的一面。我在整本书中自始至终都在努力将现代斯多葛主义往外在的方向引导——将它所承诺的在世性、连接性和人人共享的理性和人性都呈现出来。我也拓宽了意志和注意力的角度，以使人们能对在更广的范围内影响幸福的感觉印象加以关注。这就是斯多葛主义所做出的全数承诺及其所继承的苏格拉底式遗产：要针对看到的世界中的好事和坏事反复地审视和考察自身。对斯多葛学派而言，“虚假”的好事和坏事都与外部事物或中立之物有关，而它们与理性真正的善以及理性在德性上的完善都没有关系。\n斯多葛学派从来不认为理性对外部资源来说是中立的。恰恰相反，智慧就是在大多数情形中都能选择或偏向与自然相合的善。我们偏好健康胜过疾病，偏好充足的物质条件胜过贫困，偏好善良的孩子和朋友胜过邪恶的人，这都是我们选择的。我们的这些偏好以及在错综复杂的行动世界中表现它们的方式，就是美德的具体体现。理性和理性的卓越与完善是真正的善，因为它们对我们的共同幸福而言是绝对必要的。显然，我们无法控制事情的所有结果，但是我们可以培育理性、求知欲、对真理的敬重，以及相信每个人都配享有足够的资源来对理性进行培育的信念。这是一颗斯多葛主义的种子，尽管它没有在他们那个时代生根发芽。\n所以，对于构建一种现代斯多葛主义而言，斯多葛主义是否能应对得了这一挑战呢？\n身处欧洲理性启蒙传统中的康德开启了这项工作。他发展了人人享有的理性的概念，而这也构成了作为人而非上帝、自然或宇宙的我们，为自身确立道德法则的基础。理性约束着我们，它也是普遍存在的道德责任和义务的根源，同时使责任和义务不因一时便利或私利而被取消。康德系统地构建起了人性的原则，以防止将人仅仅视为被明码标价以达成目的的工具，尽管他的学说比塞内卡的晚了近2000年，却绝不仅仅只是为人类的解放给出了一种理论模型 。\n文本和语境 所以我们该如何对待有些观点存在道德问题的文本呢？要不要删掉？要不要不教授这些内容，或者更极端些，将该作者的全部作品都放弃？或者像斯多葛哲学家们那样，基于自身判断和灵活性来应对这些挑战？我选择后者。在这些情况中，我们面临的挑战在于理解我们并不身处其中的时代和受历史架构影响（有时甚至是深受其影响）的观念。\n即使哲学伪装成超越历史的模样，但它向来都不与历史相割裂。即使某种哲学观点是“无中生有的”，它也是由有血有肉的人，基于特定的基础，被其所在的文化、实践和前辈们影响，又经常以对它们做出回应的方式得出的。\n哲学以论辩之术为傲，但做哲学却绝不仅仅意味着单纯进行论辩。哲学是一种将追随者、忠实支持者和门徒们聚集起来的学科，就像在雅典、在绘有湿壁画柱廊的沉静气氛中，或是在吕克昂的健身场里，抑或是在学园里的人所做的那样。\n但罗马斯多葛派思想家们比起亚里士多德和柏拉图，甚或那些在柱廊里进行集会的古希腊斯多葛哲学家们，仍然是一类不同的哲学家。他们不但论辩，还布道和说教，这也部分地解释了他们在历史上经久不衰的吸引力，这些都是斯多葛思想声势浩大的复兴背后的原因。斯多葛哲学可以是一种世俗宗教，也可以是一种专注于美德和道德进步而不进行宗教建设之积累的精神实践。\n从历史的角度来说，斯多葛派所带来的影响明显地以其他方式表现了出来。早期的犹太教和基督教思想家从异教思想中吸收了一些观念，这也就解释了为什么很多人仍对斯多葛主义感到十分熟悉。斯多葛学派主张控制情绪和重振意志，以此对诱惑和突然的冲动或感觉印象保持警惕，这些都吸引着早期的西方宗教思想家。他们用斯多葛主义来诠释宗教文本并引导道德进步。\n斯多葛主义就其自身而言，开启的是践行沉思的传统，而非表达崇拜的传统。斯多葛式的沉思不是东方实践中常见的那种让忙乱的心灵安静下来的方法，它最终致力于帮助人们在对日常生活中大大小小挑战的处理中寻求平静。它训练的是审慎而非畏惧，从某种程度上讲，审慎并不会使人迷失。\n向前之路 我们生活在一个焦虑的时代。我们的政治观念遭到颠覆，民主制度遭遇威胁，对疾病的掌控力也遭遇考验。经济、社会和健康中的不平等将奴役之罪恶和美国的黑人歧视传统揭露了出来。道德愤慨普遍存在，失业率达到了自大萧条以来的最高水平，这一切都让人难以看清前路。我们需要领导者，需要教育，需要科学，需要更大程度的平等。\n斯多葛哲学家们无法帮我们解决所有这些问题，但他们能在有些困境中给予我们慰藉——关于死亡的教导、面对恐惧的生活技巧、对那些不由自主的情绪进行管理的方法、准备好应对突如其来的变故的更好办法、能支撑坚韧品质的人际关联感，还有仁慈与感恩在我们生命中的重要性。塞内卡提倡培育人性，但这仍然是一项未竟的事业。我们不仅要对灵魂进行修补，也要对社会进行修补。“有些东西取决于我们，而有些则并非如此。” 问题的关键并不在于什么事情发生在了你的身上，而在于你做何反应。这些都是我们所熟知的爱比克泰德给出的教导。然而我们却无法接受爱比克泰德遭受奴役的历史事实，并以此为自己的退却做辩护。从我们当下的身份、所处的时代以及我们所面临的政治挑战来看，退却就是懦弱的表现。我们必须在那些无法接受的事情上做出改变。而我们要改变它就必然不仅要改变我们自身，也要改变将我们这个集体建构起来的制度以及社会结构。这是一项社会性的事业，需要社会大众的决心，也需要对共同人性的信念。这就是奥勒留在战场上目睹破碎的人体部位四处散落之时心中所想之事。他对自己写道，如果你让自己脱离了共同体和共同体的整体福祉，那这就是后果。你会使自己成为被放逐于人类群体之外的“流浪者”。\n斯多葛学派还就价值观的崩塌——虚假的荣誉、贪婪、过分唯物质论提出了警告。塞内卡还对极力要求下属忠诚的暴君提出了警告。他了解那些为宫中谋杀进行掩饰的演讲稿撰写者们。为了让忧心忡忡的民众冷静下来，他们书写仁慈，声称对对方的谋杀是终点而非更多杀戮的起点。塞内卡就是这样的一个演讲稿撰写者，他的双手也不干净。他的哲学作品充满了权力与害怕失去权力之间、忠诚及其代价之间、富裕与节制之间的张力。在某种程度上，他的写作是在祈求救赎。他为寻求自由而写作。\n斯多葛主义是一种在面对威胁生存的严酷的外部制约时，延续和培养内在美德的方法。这是一种适合当时那个时代的哲学，让人感觉它就是为那个时代而生的哲学。然而我们是现代人，我们要从古人那里学习的还有很多，但也有一些错误是我们要避免的。斯多葛式的训练、坚韧、美德以及理性与合理性之间的纽带都能使我们团结起来，应对个人的和集体的挑战。但这只有当理性的血管中流动着同理之心和仁慈之情的血液时才能实现。这就是那条向前之路，那条健康的现代斯多葛之路。\n","date":"2024-05-23 15:00:00","updated":"2024-05-25 16:00:00"}]